// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"55EVS":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "d31b34ad88ac1ca2";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets, assetsToDispose, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets); // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                } // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle, id) {
    // Execute the module.
    bundle(id); // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            }); // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"hMOu1":[function(require,module,exports) {
var _room = require("@skyway-sdk/room");
// import { appId, secret } from './env';
const appId = "3bf55f28-4d2d-4dca-9d3b-7278400ace62";
const secret = "2EswIdxSFAYcRHWyc/HHf8zTltBUxgueIXk8pJhyom0=";
const token = new (0, _room.SkyWayAuthToken)({
    jti: (0, _room.uuidV4)(),
    iat: (0, _room.nowInSec)(),
    exp: (0, _room.nowInSec)() + 86400,
    scope: {
        app: {
            id: appId,
            turn: true,
            actions: [
                "read"
            ],
            channels: [
                {
                    id: "*",
                    name: "*",
                    actions: [
                        "write"
                    ],
                    members: [
                        {
                            id: "*",
                            name: "*",
                            actions: [
                                "write"
                            ],
                            publication: {
                                actions: [
                                    "write"
                                ]
                            },
                            subscription: {
                                actions: [
                                    "write"
                                ]
                            }
                        }
                    ],
                    sfuBots: [
                        {
                            actions: [
                                "write"
                            ],
                            forwardings: [
                                {
                                    actions: [
                                        "write"
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    }
}).encode(secret);
(async ()=>{
    const localVideo = document.getElementById("local-video");
    const buttonArea = document.getElementById("button-area");
    const remoteMediaArea = document.getElementById("remote-media-area");
    const channelNameInput = document.getElementById("channel-name");
    const dataStreamInput = document.getElementById("data-stream");
    const myId = document.getElementById("my-id");
    const joinButton = document.getElementById("join");
    const writeButton = document.getElementById("write");
    const { audio , video  } = await (0, _room.SkyWayStreamFactory).createMicrophoneAudioAndCameraStream();
    video.attach(localVideo);
    await localVideo.play();
    let myid = "";
    const data = await (0, _room.SkyWayStreamFactory).createDataStream();
    writeButton.onclick = ()=>{
        data.write(dataStreamInput.value);
        const elm = document.createElement("div");
        remoteMediaArea.appendChild(elm);
        console.log(data);
        elm.innerText = "\n";
        elm.innerText += myid + ": " + dataStreamInput.value + "";
        dataStreamInput.value = "";
    };
    joinButton.onclick = async ()=>{
        if (channelNameInput.value === "") return;
        const context = await (0, _room.SkyWayContext).Create(token);
        const channel = await (0, _room.SkyWayRoom).FindOrCreate(context, {
            type: "p2p",
            name: channelNameInput.value
        });
        const me = await channel.join();
        myId.textContent = me.id;
        myid = me.id;
        await me.publish(audio);
        await me.publish(video);
        await me.publish(data);
        const subscribeAndAttach = (publication)=>{
            if (publication.publisher.id === me.id) return;
            const subscribeButton = document.createElement("button");
            if (publication.contentType == "data") {
                subscribeButton.textContent = `${publication.publisher.id}: ${publication.contentType}`;
                buttonArea.appendChild(subscribeButton);
            }
            subscribeButton.onclick = async ()=>{
                const { stream  } = await me.subscribe(publication.id);
                switch(stream.contentType){
                    case "video":
                        {
                            const elm = document.createElement("video");
                            elm.className = "hide";
                            elm.playsInline = true;
                            elm.autoplay = true;
                            stream.attach(elm);
                            remoteMediaArea.appendChild(elm);
                        }
                        break;
                    case "audio":
                        {
                            const elm = document.createElement("audio");
                            elm.className = "hide";
                            elm.controls = true;
                            elm.autoplay = true;
                            stream.attach(elm);
                            remoteMediaArea.appendChild(elm);
                        }
                        break;
                    case "data":
                        {
                            const elm = document.createElement("div");
                            remoteMediaArea.appendChild(elm);
                            elm.innerText = "\n";
                            stream.onData.add((data)=>{
                                elm.innerText += publication.publisher.id + ": " + data + "\n";
                            });
                        }
                }
            };
        };
        channel.publications.forEach(subscribeAndAttach);
        channel.onStreamPublished.add((e)=>subscribeAndAttach(e.publication));
    };
})();

},{"@skyway-sdk/room":"k71pc"}],"k71pc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errors", ()=>(0, _errors.errors));
parcelHelpers.export(exports, "AudioMediaTrackConstraints", ()=>(0, _core.AudioMediaTrackConstraints));
parcelHelpers.export(exports, "ChannelState", ()=>(0, _core.ChannelState));
parcelHelpers.export(exports, "Codec", ()=>(0, _core.Codec));
parcelHelpers.export(exports, "CodecParameters", ()=>(0, _core.CodecParameters));
parcelHelpers.export(exports, "ContentType", ()=>(0, _core.ContentType));
parcelHelpers.export(exports, "ContextConfig", ()=>(0, _core.ContextConfig));
parcelHelpers.export(exports, "createTestVideoTrack", ()=>(0, _core.createTestVideoTrack));
parcelHelpers.export(exports, "DataStreamMessageType", ()=>(0, _core.DataStreamMessageType));
parcelHelpers.export(exports, "DataStreamOptions", ()=>(0, _core.DataStreamOptions));
parcelHelpers.export(exports, "DisplayStreamOptions", ()=>(0, _core.DisplayStreamOptions));
parcelHelpers.export(exports, "EncodingParameters", ()=>(0, _core.EncodingParameters));
parcelHelpers.export(exports, "Event", ()=>(0, _core.Event));
parcelHelpers.export(exports, "Events", ()=>(0, _core.Events));
parcelHelpers.export(exports, "getBitrateFromPeerConnection", ()=>(0, _core.getBitrateFromPeerConnection));
parcelHelpers.export(exports, "getRtcRtpCapabilities", ()=>(0, _core.getRtcRtpCapabilities));
parcelHelpers.export(exports, "LocalAudioStream", ()=>(0, _core.LocalAudioStream));
parcelHelpers.export(exports, "LocalCustomVideoStream", ()=>(0, _core.LocalCustomVideoStream));
parcelHelpers.export(exports, "LocalDataStream", ()=>(0, _core.LocalDataStream));
parcelHelpers.export(exports, "LocalMediaStreamBase", ()=>(0, _core.LocalMediaStreamBase));
parcelHelpers.export(exports, "LocalMediaStreamOptions", ()=>(0, _core.LocalMediaStreamOptions));
parcelHelpers.export(exports, "LocalStream", ()=>(0, _core.LocalStream));
parcelHelpers.export(exports, "LocalStreamBase", ()=>(0, _core.LocalStreamBase));
parcelHelpers.export(exports, "LocalVideoStream", ()=>(0, _core.LocalVideoStream));
parcelHelpers.export(exports, "MediaDevice", ()=>(0, _core.MediaDevice));
parcelHelpers.export(exports, "MemberKeepAliveConfig", ()=>(0, _core.MemberKeepAliveConfig));
parcelHelpers.export(exports, "MemberSide", ()=>(0, _core.MemberSide));
parcelHelpers.export(exports, "MemberState", ()=>(0, _core.MemberState));
parcelHelpers.export(exports, "MemberType", ()=>(0, _core.MemberType));
parcelHelpers.export(exports, "PersonInit", ()=>(0, _core.PersonInit));
parcelHelpers.export(exports, "PublicationOptions", ()=>(0, _core.PublicationOptions));
parcelHelpers.export(exports, "PublicationState", ()=>(0, _core.PublicationState));
parcelHelpers.export(exports, "RemoteAudioStream", ()=>(0, _core.RemoteAudioStream));
parcelHelpers.export(exports, "RemoteDataStream", ()=>(0, _core.RemoteDataStream));
parcelHelpers.export(exports, "RemoteMediaStreamBase", ()=>(0, _core.RemoteMediaStreamBase));
parcelHelpers.export(exports, "RemoteStream", ()=>(0, _core.RemoteStream));
parcelHelpers.export(exports, "RemoteStreamBase", ()=>(0, _core.RemoteStreamBase));
parcelHelpers.export(exports, "RemoteVideoStream", ()=>(0, _core.RemoteVideoStream));
parcelHelpers.export(exports, "ReplaceStreamOptions", ()=>(0, _core.ReplaceStreamOptions));
parcelHelpers.export(exports, "RtcApiConfig", ()=>(0, _core.RtcApiConfig));
parcelHelpers.export(exports, "RtcRpcApiConfig", ()=>(0, _core.RtcRpcApiConfig));
parcelHelpers.export(exports, "SkyWayConfigOptions", ()=>(0, _core.SkyWayConfigOptions));
parcelHelpers.export(exports, "SkyWayContext", ()=>(0, _core.SkyWayContext));
parcelHelpers.export(exports, "SkyWayStreamFactory", ()=>(0, _core.SkyWayStreamFactory));
parcelHelpers.export(exports, "Stream", ()=>(0, _core.Stream));
parcelHelpers.export(exports, "StreamFactory", ()=>(0, _core.StreamFactory));
parcelHelpers.export(exports, "SubscriptionOptions", ()=>(0, _core.SubscriptionOptions));
parcelHelpers.export(exports, "SubscriptionState", ()=>(0, _core.SubscriptionState));
parcelHelpers.export(exports, "TransportConnectionState", ()=>(0, _core.TransportConnectionState));
parcelHelpers.export(exports, "TurnPolicy", ()=>(0, _core.TurnPolicy));
parcelHelpers.export(exports, "TurnProtocol", ()=>(0, _core.TurnProtocol));
parcelHelpers.export(exports, "VideoMediaTrackConstraints", ()=>(0, _core.VideoMediaTrackConstraints));
parcelHelpers.export(exports, "WebRTCStats", ()=>(0, _core.WebRTCStats));
var _errors = require("./errors");
var _member = require("./member");
parcelHelpers.exportAll(_member, exports);
var _base = require("./member/local/base");
parcelHelpers.exportAll(_base, exports);
var _p2P = require("./member/local/p2p");
parcelHelpers.exportAll(_p2P, exports);
var _sfu = require("./member/local/sfu");
parcelHelpers.exportAll(_sfu, exports);
var _base1 = require("./member/remote/base");
parcelHelpers.exportAll(_base1, exports);
var _publication = require("./publication");
parcelHelpers.exportAll(_publication, exports);
var _room = require("./room");
parcelHelpers.exportAll(_room, exports);
var _base2 = require("./room/base");
parcelHelpers.exportAll(_base2, exports);
var _event = require("./room/event");
parcelHelpers.exportAll(_event, exports);
var _p2P1 = require("./room/p2p");
parcelHelpers.exportAll(_p2P1, exports);
var _sfu1 = require("./room/sfu");
parcelHelpers.exportAll(_sfu1, exports);
var _subscription = require("./subscription");
parcelHelpers.exportAll(_subscription, exports);
var _version = require("./version");
parcelHelpers.exportAll(_version, exports);
var _common = require("@skyway-sdk/common");
parcelHelpers.exportAll(_common, exports);
var _core = require("@skyway-sdk/core");
var _token = require("@skyway-sdk/token");
parcelHelpers.exportAll(_token, exports);

},{"./errors":"d7AJ6","./member":"25K2E","./member/local/base":"gVaVo","./member/local/p2p":"a3Zkj","./member/local/sfu":"9Q67n","./member/remote/base":"6Diig","./publication":"k9w39","./room":"04C1D","./room/base":"6Kn8X","./room/event":"4XuZD","./room/p2p":"5YKHT","./room/sfu":"b6OSm","./subscription":"3WOdj","./version":"67gDN","@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","@skyway-sdk/token":"1nlc7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7AJ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "roomErrors", ()=>roomErrors);
parcelHelpers.export(exports, "errors", ()=>errors);
var _core = require("@skyway-sdk/core");
var _sfuBot = require("@skyway-sdk/sfu-bot");
const roomErrors = {
    invalidParameter: {
        name: "invalidParameter",
        detail: "",
        solution: ""
    },
    timeout: {
        name: "timeout",
        detail: "",
        solution: ""
    },
    internal: {
        name: "internal",
        detail: "",
        solution: ""
    },
    notImplemented: {
        name: "notImplemented",
        detail: "対応していないRoomTypeです",
        solution: "正しいRoomTypeを指定してください"
    },
    roomNotOpened: {
        name: "roomNotOpened",
        detail: "RoomがOpenされていません",
        solution: "Roomの状態を確かめてください"
    },
    subscribeOtherMemberType: {
        name: "subscribeOtherMemberType",
        detail: "RemoteMemberにSubscribe/Unsubscribeさせる場合、対象のMemberのTypeはPersonである必要があります",
        solution: "対象のRemoteMemberが正しいか確認してください"
    },
    sfuRoomNotSupportDataStream: {
        name: "sfuRoomNotSupportDataStream",
        detail: "SFURoomでDataStreamを使うことは出来ません",
        solution: "ありません"
    },
    publicationNotHasOrigin: {
        name: "publicationNotHasOrigin",
        detail: "SfuRoomで操作するPublicationはOriginをもつ必要があります",
        solution: "SfuRoomとP2PRoomを同一のIDで混在させていないか確かめてください"
    },
    notFound: {
        name: "notFound",
        detail: "参照しようとしていたものが見つかりません",
        solution: "参照しようとしたものが存在するか確かめてください"
    }
};
const errors = {
    ...(0, _core.errors),
    ...(0, _sfuBot.errors),
    ...roomErrors
};

},{"@skyway-sdk/core":"kbrOO","@skyway-sdk/sfu-bot":"fgRbl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kbrOO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _channel = require("./channel");
parcelHelpers.exportAll(_channel, exports);
var _event = require("./channel/event");
parcelHelpers.exportAll(_event, exports);
var _config = require("./config");
parcelHelpers.exportAll(_config, exports);
var _context = require("./context");
parcelHelpers.exportAll(_context, exports);
var _errors = require("./errors");
parcelHelpers.exportAll(_errors, exports);
var _analytics = require("./external/analytics");
parcelHelpers.exportAll(_analytics, exports);
var _ice = require("./external/ice");
parcelHelpers.exportAll(_ice, exports);
var _media = require("./media");
parcelHelpers.exportAll(_media, exports);
var _factory = require("./media/factory");
parcelHelpers.exportAll(_factory, exports);
var _stream = require("./media/stream");
parcelHelpers.exportAll(_stream, exports);
var _local = require("./media/stream/local");
parcelHelpers.exportAll(_local, exports);
var _audio = require("./media/stream/local/audio");
parcelHelpers.exportAll(_audio, exports);
var _customVideo = require("./media/stream/local/customVideo");
parcelHelpers.exportAll(_customVideo, exports);
var _data = require("./media/stream/local/data");
parcelHelpers.exportAll(_data, exports);
var _video = require("./media/stream/local/video");
parcelHelpers.exportAll(_video, exports);
var _remote = require("./media/stream/remote");
parcelHelpers.exportAll(_remote, exports);
var _audio1 = require("./media/stream/remote/audio");
parcelHelpers.exportAll(_audio1, exports);
var _data1 = require("./media/stream/remote/data");
parcelHelpers.exportAll(_data1, exports);
var _factory1 = require("./media/stream/remote/factory");
parcelHelpers.exportAll(_factory1, exports);
var _media1 = require("./media/stream/remote/media");
parcelHelpers.exportAll(_media1, exports);
var _video1 = require("./media/stream/remote/video");
parcelHelpers.exportAll(_video1, exports);
var _member = require("./member");
parcelHelpers.exportAll(_member, exports);
var _localPerson = require("./member/localPerson");
parcelHelpers.exportAll(_localPerson, exports);
var _adapter = require("./member/localPerson/adapter");
parcelHelpers.exportAll(_adapter, exports);
var _person = require("./member/person");
parcelHelpers.exportAll(_person, exports);
var _remoteMember = require("./member/remoteMember");
parcelHelpers.exportAll(_remoteMember, exports);
var _connection = require("./plugin/interface/connection");
parcelHelpers.exportAll(_connection, exports);
var _plugin = require("./plugin/interface/plugin");
parcelHelpers.exportAll(_plugin, exports);
var _connection1 = require("./plugin/internal/person/connection");
parcelHelpers.exportAll(_connection1, exports);
var _member1 = require("./plugin/internal/person/member");
parcelHelpers.exportAll(_member1, exports);
var _util = require("./plugin/internal/person/util");
parcelHelpers.exportAll(_util, exports);
var _publication = require("./publication");
parcelHelpers.exportAll(_publication, exports);
var _subscription = require("./subscription");
parcelHelpers.exportAll(_subscription, exports);
var _util1 = require("./util");
parcelHelpers.exportAll(_util1, exports);
var _version = require("./version");
parcelHelpers.exportAll(_version, exports);
var _common = require("@skyway-sdk/common");
parcelHelpers.exportAll(_common, exports);
var _token = require("@skyway-sdk/token");
parcelHelpers.exportAll(_token, exports);

},{"./channel":"8vQRp","./channel/event":"963Vz","./config":"c9WRi","./context":"dGqOo","./errors":"gDbIj","./external/analytics":"kCrov","./external/ice":"hAK93","./media":"kj0Km","./media/factory":"qXbjM","./media/stream":"lWTWB","./media/stream/local":"gov7A","./media/stream/local/audio":"bIWhI","./media/stream/local/customVideo":"1Q3u4","./media/stream/local/data":"T39q0","./media/stream/local/video":"hcUYM","./media/stream/remote":"du0SC","./media/stream/remote/audio":"8TpY5","./media/stream/remote/data":"8kcOV","./media/stream/remote/factory":"ezfKU","./media/stream/remote/media":"llk9G","./media/stream/remote/video":"bjaWL","./member":"dkuHe","./member/localPerson":"dbPdD","./member/localPerson/adapter":"9IpNZ","./member/person":"giYd5","./member/remoteMember":"hAw7O","./plugin/interface/connection":"k9reH","./plugin/interface/plugin":"3MSpg","./plugin/internal/person/connection":"9R3XO","./plugin/internal/person/member":"k0JDW","./plugin/internal/person/util":"5vybP","./publication":"3aobm","./subscription":"5Tclz","./util":"ey5Lv","./version":"3jBjn","@skyway-sdk/common":"3hyrG","@skyway-sdk/token":"1nlc7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8vQRp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "SkyWayChannelImpl", ()=>SkyWayChannelImpl);
parcelHelpers.export(exports, "SkyWayChannel", ()=>SkyWayChannel);
var _common = require("@skyway-sdk/common");
var _errors = require("../errors");
var _localPerson = require("../member/localPerson");
var _factory = require("../publication/factory");
var _factory1 = require("../subscription/factory");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/core/src/channel/index.ts");
class SkyWayChannelImpl {
    _addMember(memberDto) {
        const exist = this._getMember(memberDto.id);
        if (exist) return exist;
        const member = this._context._createRemoteMember(this, memberDto);
        this._members[member.id] = member;
        return member;
    }
    _removeMember(memberId) {
        delete this._members[memberId];
    }
    /**@private */ _addPublication(p) {
        const exist = this._getPublication(p.id);
        if (exist) return exist;
        const publication = (0, _factory.createPublication)(this, p);
        this._publications[p.id] = publication;
        return publication;
    }
    _removePublication(publicationId) {
        delete this._publications[publicationId];
    }
    /**@private */ _addSubscription(s) {
        const exist = this._getSubscription(s.id);
        if (exist) return exist;
        const subscription = (0, _factory1.createSubscription)(this, s);
        this._subscriptions[s.id] = subscription;
        return subscription;
    }
    _removeSubscription(subscriptionId) {
        delete this._subscriptions[subscriptionId];
    }
    constructor(_context, _channelImpl){
        this._context = _context;
        this._channelImpl = _channelImpl;
        this.id = this._channelImpl.id;
        this.name = this._channelImpl.name;
        this.appId = this._context.appId;
        this.disposed = false;
        this.config = this._context.config;
        this._state = "opened";
        this._api = this._context._api;
        this._members = {};
        this./**@private */ _getMember = (id)=>this._members[id];
        this._publications = {};
        this./**@private */ _getPublication = (id)=>this._publications[id];
        this._subscriptions = {};
        this./**@private */ _getSubscription = (id)=>this._subscriptions[id];
        this._events = new (0, _common.Events)();
        this.onClosed = this._events.make();
        this.onMetadataUpdated = this._events.make();
        this.onMemberListChanged = this._events.make();
        this.onMemberJoined = this._events.make();
        this.onMemberLeft = this._events.make();
        this.onMemberMetadataUpdated = this._events.make();
        this.onPublicationListChanged = this._events.make();
        this.onStreamPublished = this._events.make();
        this.onStreamUnpublished = this._events.make();
        this.onPublicationMetadataUpdated = this._events.make();
        this.onPublicationEnabled = this._events.make();
        this.onPublicationDisabled = this._events.make();
        this.onSubscriptionListChanged = this._events.make();
        this.onPublicationSubscribed = this._events.make();
        this.onPublicationUnsubscribed = this._events.make();
        this._onDisposed = this._events.make();
        this.leave = async (member)=>this._channelImpl.leave(this.id, member.id);
        this.updateMetadata = (metadata)=>this._channelImpl.updateChannelMetadata(metadata);
        this.close = ()=>new Promise(async (r, f)=>{
                if (this.state === "closed") {
                    f((0, _util.createError)({
                        operationName: "SkyWayChannelImpl.close",
                        path: log.prefix,
                        info: (0, _errors.errors).alreadyChannelClosed,
                        channel: this,
                        context: this._context,
                        payload: this.toJSON()
                    }));
                    return;
                }
                const timestamp = log.info("[start] close channel", await (0, _util.createLogPayload)({
                    operationName: "SkyWayChannelImpl.close",
                    channel: this
                }));
                try {
                    await this._channelImpl.close().catch((e)=>{
                        const error = (0, _util.createError)({
                            operationName: "SkyWayChannelImpl.close",
                            context: this._context,
                            info: {
                                ...(0, _errors.errors).internal,
                                detail: "_api.deleteChannel failed"
                            },
                            error: e,
                            path: log.prefix,
                            channel: this
                        });
                        throw error;
                    });
                    if (this._state !== "closed") await this.onClosed.asPromise(this._context.config.rtcApi.timeout).catch((e)=>{
                        const error = (0, _util.createError)({
                            operationName: "SkyWayChannelImpl.close",
                            context: this._context,
                            info: {
                                ...(0, _errors.errors).timeout,
                                detail: "channel.onClosed"
                            },
                            error: e,
                            path: log.prefix,
                            channel: this
                        });
                        throw error;
                    });
                } catch (error) {
                    log.error(error.message, error);
                    f(error);
                }
                log.elapsed(timestamp, "[end] close channel", await (0, _util.createLogPayload)({
                    operationName: "SkyWayChannelImpl.close",
                    channel: this
                }));
                r();
            });
        this._updateMemberTtl = (memberId, ttlSec)=>this._channelImpl.updateMemberTtl(memberId, ttlSec);
        this._updateMemberMetadata = (memberId, metadata)=>this._channelImpl.updateMemberMetadata(memberId, metadata);
        this._publish = (init)=>this._channelImpl.publish(init);
        this._unpublish = async (publicationId)=>this._channelImpl.unpublish(publicationId);
        this._subscribe = (subscriberId, publicationId)=>{
            const publication = this._getPublication(publicationId);
            const subscriber = this._getMember(subscriberId);
            if (subscriber == undefined) throw (0, _util.createError)({
                operationName: "SkyWayChannelImpl._subscribe",
                path: log.prefix,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "subscriber not found"
                },
                channel: this,
                context: this._context,
                payload: {
                    subscriberId,
                    publicationId
                }
            });
            return this._channelImpl.subscribe({
                publication: publication.toJSON(),
                subscriber: subscriber.toJSON()
            });
        };
        this._unsubscribe = async (subscriptionId)=>{
            if (!this._getSubscription(subscriptionId)) throw (0, _util.createError)({
                operationName: "SkyWayChannelImpl._unsubscribe",
                path: log.prefix,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "can't unsubscribe not exist subscription"
                },
                channel: this,
                context: this._context,
                payload: {
                    subscriptionId
                }
            });
            await this._channelImpl.unsubscribe(subscriptionId);
        };
        this._updatePublicationMetadata = (publicationId, metadata)=>this._channelImpl.updatePublicationMetadata(publicationId, metadata);
        this._disablePublication = (publicationId)=>this._channelImpl.disablePublication(publicationId);
        this._enablePublication = (publicationId)=>this._channelImpl.enablePublication(publicationId);
        this._setupPropertiesFromChannel();
        this._setupListenChannelEvent();
        _context._onDisposed.once(()=>{
            this.dispose();
        });
        log.debug("channel spawned", this.toJSON());
    }
    get localPerson() {
        return this._localPerson;
    }
    get members() {
        return Object.values(this._members);
    }
    get bots() {
        return this.members.filter((m)=>m.type === "bot");
    }
    get publications() {
        return Object.values(this._publications);
    }
    get subscriptions() {
        return Object.values(this._subscriptions);
    }
    get metadata() {
        return this._channelImpl.metadata;
    }
    get state() {
        return this._state;
    }
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            appId: this.appId,
            metadata: this.metadata,
            members: this.members,
            publications: this.publications,
            subscriptions: this.subscriptions
        };
    }
    _setupPropertiesFromChannel() {
        this._channelImpl.members.forEach((memberDto)=>{
            this._addMember(memberDto);
        });
        this._channelImpl.publications.forEach((publicationDto)=>{
            this._addPublication(publicationDto);
        });
        this._channelImpl.subscriptions.forEach((subscriptionDto)=>{
            this._addSubscription(subscriptionDto);
        });
    }
    _setupListenChannelEvent() {
        this._channelImpl.onClosed.add(()=>this._handleOnChannelClose());
        this._channelImpl.onMetadataUpdated.add(({ channel  })=>this._handleOnChannelMetadataUpdate(channel.metadata));
        this._channelImpl.onMemberJoined.add(({ member  })=>{
            this._handleOnMemberJoin(member);
        });
        this._channelImpl.onMemberLeft.add(({ member  })=>{
            this._handleOnMemberLeft(member);
        });
        this._channelImpl.onMemberListChanged.pipe(this.onMemberListChanged);
        this._channelImpl.onMemberMetadataUpdated.add(({ member  })=>{
            this._handleOnMemberMetadataUpdate(member, member.metadata);
        });
        this._channelImpl.onStreamPublished.add(({ publication  })=>{
            this._handleOnStreamPublish(publication);
        });
        this._channelImpl.onStreamUnpublished.add(({ publication  })=>{
            this._handleOnStreamUnpublish(publication);
        });
        this._channelImpl.onPublicationListChanged.pipe(this.onPublicationListChanged);
        this._channelImpl.onPublicationMetadataUpdated.add(({ publication  })=>{
            this._handleOnPublicationMetadataUpdate(publication, publication.metadata);
        });
        this._channelImpl.onPublicationEnabled.add(async ({ publication  })=>await this._handleOnPublicationEnabled(publication));
        this._channelImpl.onPublicationDisabled.add(async ({ publication  })=>await this._handleOnPublicationDisabled(publication));
        this._channelImpl.onPublicationSubscribed.add(({ subscription  })=>{
            this._handleOnStreamSubscribe(subscription);
        });
        this._channelImpl.onPublicationUnsubscribed.add(({ subscription  })=>{
            this._handleOnStreamUnsubscribe(subscription);
        });
        this._channelImpl.onSubscriptionListChanged.pipe(this.onSubscriptionListChanged);
    }
    _handleOnChannelClose() {
        this._state = "closed";
        this.onClosed.emit({});
        this.dispose();
    }
    _handleOnChannelMetadataUpdate(metadata) {
        this.onMetadataUpdated.emit({
            metadata
        });
    }
    _handleOnMemberJoin(memberDto) {
        const member = this._addMember(memberDto);
        this.onMemberJoined.emit({
            member
        });
    }
    _handleOnMemberLeft(memberDto) {
        const member = this._getMember(memberDto.id);
        this._removeMember(member.id);
        member._left();
        if (this.localPerson?.id === memberDto.id) {
            this.localPerson._left();
            this._localPerson = undefined;
        }
        this.onMemberLeft.emit({
            member
        });
    }
    _handleOnMemberMetadataUpdate(memberDto, metadata) {
        const member = this._getMember(memberDto.id);
        member._metadataUpdated(metadata);
        if (this.localPerson?.id === memberDto.id) this.localPerson._metadataUpdated(metadata);
        this.onMemberMetadataUpdated.emit({
            member,
            metadata
        });
    }
    _handleOnStreamPublish(publicationDto) {
        const publication = this._addPublication(publicationDto);
        this.onStreamPublished.emit({
            publication
        });
    }
    _handleOnStreamUnpublish(publicationDto) {
        const publication = this._getPublication(publicationDto.id);
        this._removePublication(publication.id);
        publication._unpublished();
        this.onStreamUnpublished.emit({
            publication
        });
    }
    _handleOnPublicationMetadataUpdate(publicationDto, metadata) {
        const publication = this._getPublication(publicationDto.id);
        publication._updateMetadata(metadata);
        this.onPublicationMetadataUpdated.emit({
            publication,
            metadata
        });
    }
    async _handleOnPublicationEnabled(publicationDto) {
        const publication = this._getPublication(publicationDto.id);
        publication._enable();
        this.onPublicationEnabled.emit({
            publication
        });
    }
    async _handleOnPublicationDisabled(publicationDto) {
        const publication = this._getPublication(publicationDto.id);
        await publication._disable();
        this.onPublicationDisabled.emit({
            publication
        });
    }
    _handleOnStreamSubscribe(subscriptionDto) {
        const subscription = this._addSubscription(subscriptionDto);
        const publication = this._getPublication(subscription.publication.id);
        publication._subscribed(subscription);
        this.onPublicationSubscribed.emit({
            subscription
        });
    }
    _handleOnStreamUnsubscribe(subscriptionDto) {
        const subscription = this._getSubscription(subscriptionDto.id);
        this._removeSubscription(subscription.id);
        subscription._canceled();
        const publication = this._getPublication(subscription.publication.id);
        publication._unsubscribed(subscription);
        this.onPublicationUnsubscribed.emit({
            subscription
        });
    }
    async join(options = {}) {
        const timestamp = log.info("[start] join", await (0, _util.createLogPayload)({
            operationName: "SkyWayChannelImpl.join",
            channel: this
        }));
        if (this._localPerson) throw (0, _util.createError)({
            operationName: "SkyWayChannelImpl.join",
            path: log.prefix,
            info: (0, _errors.errors).alreadyLocalPersonExist,
            channel: this,
            context: this._context
        });
        if (options.name != undefined) {
            const exist = this.members.find((m)=>m.name === options.name);
            if (exist) throw (0, _util.createError)({
                operationName: "SkyWayChannelImpl.join",
                path: log.prefix,
                info: (0, _errors.errors).alreadySameNameMemberExist,
                channel: this,
                context: this._context,
                payload: options
            });
        }
        options.keepaliveIntervalSec ??= this.config.member.keepaliveIntervalSec;
        options.keepaliveIntervalGapSec ??= this.config.member.keepaliveIntervalGapSec;
        const init = {
            ...options,
            type: "person",
            subtype: "person"
        };
        if (options.keepaliveIntervalSec !== null) init["ttlSec"] = await this._context._api.getServerUnixtimeInSec() + options.keepaliveIntervalSec;
        const member = await this._channelImpl.joinChannel(init).catch((e)=>{
            log.error("[failed] join", e);
            throw e;
        });
        log.elapsed(timestamp, "[elapsed] join / channelImpl.joinChannel", {
            member
        });
        const person = await this._createLocalPerson(member, options);
        const adapter = new (0, _localPerson.LocalPersonAdapter)(person);
        log.elapsed(timestamp, "[end] join", {
            person
        });
        return adapter;
    }
    async moveChannel(adapter) {
        if (this._localPerson) throw (0, _util.createError)({
            operationName: "SkyWayChannelImpl.moveChannel",
            path: log.prefix,
            info: (0, _errors.errors).alreadyLocalPersonExist,
            channel: this,
            context: this._context
        });
        if (!(adapter instanceof (0, _localPerson.LocalPersonAdapter))) throw (0, _util.createError)({
            operationName: "SkyWayChannelImpl.moveChannel",
            path: log.prefix,
            info: (0, _errors.errors).invalidArgumentValue,
            channel: this,
            context: this._context
        });
        const leaveChannel = adapter.channel;
        if (this.id === leaveChannel.id) throw (0, _util.createError)({
            operationName: "SkyWayChannelImpl.moveChannel",
            path: log.prefix,
            info: (0, _errors.errors).cantMoveSameIdChannel,
            channel: this,
            context: this._context
        });
        await leaveChannel.leave(adapter);
        const init = {
            name: adapter.name,
            type: adapter.type,
            subtype: adapter.subtype,
            metadata: adapter.metadata
        };
        if (adapter.keepaliveIntervalSec != undefined) init["ttlSec"] = await this._context._api.getServerUnixtimeInSec() + adapter.keepaliveIntervalSec;
        const member = await this._channelImpl.joinChannel(init);
        const person = await this._createLocalPerson(member, {
            keepaliveIntervalSec: adapter.keepaliveIntervalSec,
            keepaliveIntervalGapSec: adapter.keepaliveIntervalGapSec,
            disableSignaling: adapter.disableSignaling,
            disableAnalytics: adapter.disableAnalytics
        });
        adapter.apply(person);
    }
    async _createLocalPerson(member, config) {
        const person = await (0, _localPerson.createLocalPerson)(this._context, this, member, config);
        this._localPerson = person;
        return person;
    }
    dispose() {
        if (this.disposed) return;
        this.disposed = true;
        log.debug("disposed", this.toJSON());
        this._channelImpl.dispose();
        this._onDisposed.emit();
        this._events.dispose();
    }
}
class SkyWayChannel {
    /**
   * @description [japanese] Channelの作成
   */ static async Create(context, init = {}) {
        const timestamp = log.info("[start] createChannel", {
            operationName: "SkyWayChannel.Create"
        });
        const channelImpl = await context._api.createChannel(init).catch((e)=>{
            log.error("[failed] createChannel", e);
            throw e;
        });
        const channel = new SkyWayChannelImpl(context, channelImpl);
        log.elapsed(timestamp, "[end] createChannel");
        return channel;
    }
    /**
   * @description [japanese] 既存のChannelの取得
   */ static async Find(context, query) {
        const timestamp = log.info("[start] findChannel", {
            operationName: "SkyWayChannel.Find"
        });
        const channelImpl = await context._api.findChannel(query).catch((e)=>{
            log.error("[failed] findChannel", e);
            throw e;
        });
        const channel = new SkyWayChannelImpl(context, channelImpl);
        log.elapsed(timestamp, "[end] findChannel");
        return channel;
    }
    /**
   * @description [japanese] Channelの取得を試み、存在しなければ作成する
   */ static async FindOrCreate(context, query) {
        const timestamp = log.info("[start] findOrCreateChannel", {
            operationName: "SkyWayChannel.FindOrCreate"
        });
        const channelImpl = await context._api.findOrCreateChannel(query).catch((e)=>{
            log.error("[failed] findOrCreateChannel", e);
            throw e;
        });
        const channel = new SkyWayChannelImpl(context, channelImpl);
        log.elapsed(timestamp, "[end] findOrCreateChannel");
        return channel;
    }
    /**@private */ constructor(){}
}

},{"@skyway-sdk/common":"3hyrG","../errors":"gDbIj","../member/localPerson":"dbPdD","../publication/factory":"kiBCx","../subscription/factory":"89UU8","../util":"ey5Lv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3hyrG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _error = require("./error");
parcelHelpers.exportAll(_error, exports);
var _event = require("./event");
parcelHelpers.exportAll(_event, exports);
var _http = require("./http");
parcelHelpers.exportAll(_http, exports);
var _logger = require("./logger");
parcelHelpers.exportAll(_logger, exports);
var _promise = require("./promise");
parcelHelpers.exportAll(_promise, exports);
var _util = require("./util");
parcelHelpers.exportAll(_util, exports);

},{"./error":"hzCoy","./event":"jhfgg","./http":"ayzca","./logger":"3kwcm","./promise":"kqVCg","./util":"bE3nE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hzCoy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SkyWayError", ()=>SkyWayError);
var _logger = require("./logger");
const log = new (0, _logger.Logger)("packages/common/src/error.ts");
class SkyWayError extends Error {
    id = Math.random().toString().slice(2, 10);
    /**@internal */ constructor(init, logging = true){
        super(init.info.detail);
        Object.assign(this, init);
        this.name = this.info.name;
        if (logging) {
            const messages = [
                "SkyWayError",
                `name:${this.info.name}, detail:${this.info.detail}, solution:${this.info.solution}`
            ];
            if (this.path) messages.push(this.path);
            if (this.error) messages.push(this.error);
            if (this.payload) messages.push(this.payload);
            messages.push(this.id);
            log.warn(...messages);
        }
    }
    toJSON() {
        return {
            id: this.id,
            info: this.info,
            path: this.path,
            payload: this.payload,
            error: this.error,
            stack: this.stack
        };
    }
}

},{"./logger":"3kwcm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3kwcm":[function(require,module,exports) {
/**
 * @description [japanese]
 * 以下のいずれかを指定可能
 * - disable: ログの出力を無効化する。
 * - error: 回復不能なエラーに関する情報を出力する。
 * - warn: SDK 内部で発生した、一時的なエラーに関する情報を出力する。基本的には SDK が内部でリトライ処理を行うことで回復する。
 * - info: SDK が提供しているメソッドの呼び出しに関する情報を出力する。
 * - debug: SDK の内部のメソッド呼び出しや、リクエスト・レスポンスに関する情報など、最も詳細なログを出力する。
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logLevelTypes", ()=>logLevelTypes);
parcelHelpers.export(exports, "Logger", ()=>Logger);
const logLevelTypes = [
    "disable",
    "error",
    "warn",
    "info",
    "debug"
];
class Logger {
    static level = "error";
    static format = "object";
    static onLog = ()=>{};
    /**@internal */ static id = Math.random().toString().slice(2, 7);
    /**@internal */ constructor(prefix){
        this.prefix = prefix;
    }
    /**@internal */ debug = (...msg)=>{
        this._log("debug", ...msg);
        return Date.now();
    };
    /**@internal */ info = (...msg)=>{
        this._log("info", ...msg);
        return Date.now();
    };
    /**@internal */ warn = (...msg)=>{
        this._log("warn", ...msg);
    };
    /**@internal */ error = (...msg)=>{
        this._log("error", ...msg);
    };
    /**@internal */ elapsed = (timestamp, ...msg)=>{
        const elapsed = Date.now() - timestamp;
        this._log("info", `elapsed ms:${elapsed}`, ...msg);
    };
    _log(level, ...msg) {
        const logType = logLevelTypes.indexOf(level);
        const logLevel = logLevelTypes.indexOf(Logger.level);
        if (logLevel >= logType) {
            const timestamp = new Date(Date.now() + 32400000).toISOString() + "+JST";
            const parsed = [
                this.prefix,
                ...msg
            ].map((m)=>{
                if (m instanceof Error) {
                    if (m.toJSON) return m.toJSON();
                    return {
                        name: m.name,
                        message: m.message,
                        stack: m.stack
                    };
                }
                if (typeof m === "object") try {
                    return JSON.parse(JSON.stringify(m));
                } catch (error) {
                    return "json error";
                }
                return m;
            });
            msg = parsed;
            let log = [
                timestamp,
                level,
                ...msg
            ];
            if (Logger.format === "string") log = [
                timestamp + " " + level + " " + JSON.stringify(msg)
            ];
            switch(level){
                case "debug":
                    console.log(...log);
                    break;
                case "info":
                    console.info(...log);
                    break;
                case "warn":
                    console.warn(...log);
                    break;
                case "error":
                    console.error(...log);
                    break;
            }
            Logger.onLog({
                id: Logger.id,
                timestamp,
                level,
                message: msg
            });
        }
    }
    /**@internal */ createBlock(info) {
        return {
            warn: (...msg)=>{
                this.warn({
                    ...info
                }, ...msg);
            },
            debug: (...msg)=>{
                this.debug({
                    ...info
                }, ...msg);
            },
            info: (...msg)=>{
                this.info({
                    ...info
                }, ...msg);
            },
            error: (...msg)=>{
                this.error({
                    ...info
                }, ...msg);
            }
        };
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"jhfgg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Event", ()=>Event);
/**@internal */ parcelHelpers.export(exports, "Events", ()=>Events);
/**@internal */ parcelHelpers.export(exports, "EventDisposer", ()=>EventDisposer);
var _logger = require("./logger");
const log = new (0, _logger.Logger)("packages/common/src/event.ts");
class Event {
    /**@internal */ constructor(_onSetListener = ()=>{}){
        this._onSetListener = _onSetListener;
        this._stack = [];
        this._eventIndex = 0;
        this./**@internal */ emit = (arg)=>{
            for (const task of this._stack)try {
                task.execute(arg);
            } catch (error) {
                log.error("task throws error", error);
            }
        };
        this./**@internal */ removeAllListeners = ()=>{
            this._stack = [];
        };
        this./**@internal */ pipe = (event)=>{
            return this.add((arg)=>event.emit(arg));
        };
        this./**
   * イベントが起きた時に実行する関数を登録する。
   * 戻り値として関数の登録を解除する関数が帰ってくる
   */ add = (callback)=>{
            const id = this._eventIndex;
            this._stack.push({
                execute: callback,
                id
            });
            this._eventIndex++;
            const removeListener = ()=>{
                this._stack = this._stack.filter((item)=>item.id !== id && item);
            };
            const disposer = (disposer)=>{
                disposer.push(removeListener);
            };
            this._onSetListener();
            return {
                removeListener,
                disposer
            };
        };
        this./**イベントが起きた時に一度だけ実行される関数を登録する */ once = (callback)=>{
            const off = this.add((arg)=>{
                off.removeListener();
                callback(arg);
            });
            return off;
        };
        this./**
   * イベントが起きた時に Promise が resolve される
   * @param timeLimit ms
   */ asPromise = (timeLimit)=>new Promise((resolve, reject)=>{
                const timeout = timeLimit && setTimeout(()=>{
                    reject(new SerializableError("Event asPromise timeout : " + timeLimit));
                }, timeLimit);
                this.once((arg)=>{
                    if (timeout) clearTimeout(timeout);
                    resolve(arg);
                });
            });
        this./**
   * イベントが起きた時に実行される boolean を返す関数を登録する。
   * 登録した関数が true を返した時に Promise が resolve される
   * */ watch = (callback, /**ms */ timeLimit)=>new Promise((resolve, reject)=>{
                const timeout = timeLimit && setTimeout(()=>{
                    reject(new SerializableError("Event watch timeout : " + timeLimit));
                }, timeLimit);
                const { removeListener  } = this.add((arg)=>{
                    const done = callback(arg);
                    if (done) {
                        if (timeout) clearTimeout(timeout);
                        removeListener();
                        resolve(arg);
                    }
                });
            });
    }
    /**@internal */ get length() {
        return this._stack.length;
    }
}
class Events {
    events = [];
    make() {
        const event = new Event();
        this.events.push(event);
        return event;
    }
    dispose() {
        this.events.forEach((event)=>event.removeAllListeners());
        this.events = [];
    }
}
class EventDisposer {
    _disposer = [];
    push(disposer) {
        this._disposer.push(disposer);
    }
    dispose() {
        this._disposer.forEach((d)=>d());
        this._disposer = [];
    }
}
class SerializableError extends Error {
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            stack: this.stack
        };
    }
}

},{"./logger":"3kwcm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ayzca":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "HttpClient", ()=>HttpClient);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _logger = require("./logger");
const log = new (0, _logger.Logger)("packages/common/src/http.ts");
class HttpClient {
    constructor(baseURL){
        this.api = (0, _axiosDefault.default).create({
            baseURL
        });
    }
    /**@throws {@link HttpResponse} */ async get(url, config) {
        const res = await this.api.get(url, config).catch((err)=>err);
        if ((0, _axiosDefault.default).isAxiosError(res)) {
            const error = {
                ...res.response,
                message: res.message
            };
            if (config?.retry) {
                const retry = await config.retry(error);
                if (retry) {
                    log.warn("retry get", {
                        url
                    });
                    return this.get(url, config);
                } else {
                    log.warn("retry get failed", {
                        url
                    });
                    throw error;
                }
            }
            log.warn("response error", {
                error
            });
            throw error;
        } else return res.data;
    }
    /**@throws {@link HttpResponse} */ async post(url, data, config) {
        const res = await this.api.post(url, data, config).catch((err)=>err);
        if ((0, _axiosDefault.default).isAxiosError(res)) {
            const error = {
                data: res.response?.data,
                status: res.response?.status,
                statusText: res.response?.statusText,
                message: res.message
            };
            log.warn("error received", error);
            if (config?.retry) {
                const needRetry = await config.retry(error);
                if (needRetry) {
                    log.warn("retry post", url, {
                        data,
                        error,
                        needRetry
                    });
                    return this.post(url, data, config);
                } else throw error;
            }
            throw error;
        } else return res.data;
    }
    /**@throws {@link HttpResponse} */ async put(url, data, config) {
        const res = await this.api.put(url, data, config).catch((err)=>err);
        if ((0, _axiosDefault.default).isAxiosError(res)) {
            const error = {
                ...res.response,
                message: res.message
            };
            if (config?.retry) {
                const retry = await config.retry(error);
                if (retry) {
                    log.warn("retry put", {
                        url,
                        data
                    });
                    return this.put(url, data, config);
                } else {
                    log.warn("retry put failed", {
                        url,
                        data
                    });
                    throw error;
                }
            }
            log.warn("response error", {
                error
            });
            throw error;
        } else return res.data;
    }
    /**@throws {@link HttpResponse} */ async delete(url, config) {
        const res = await this.api.delete(url, config).catch((err)=>err);
        if ((0, _axiosDefault.default).isAxiosError(res)) {
            const error = {
                ...res.response,
                message: res.message
            };
            if (config?.retry) {
                const retry = await config.retry(error);
                if (retry) {
                    log.warn("retry delete", {
                        url
                    });
                    return this.delete(url, config);
                } else {
                    log.warn("retry delete failed", {
                        url
                    });
                    throw error;
                }
            }
            log.warn("response error", {
                error
            });
            throw error;
        } else return res.data;
    }
}

},{"axios":"jo6P5","./logger":"3kwcm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jo6P5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _axiosJsDefault.default));
parcelHelpers.export(exports, "Axios", ()=>Axios);
parcelHelpers.export(exports, "AxiosError", ()=>AxiosError);
parcelHelpers.export(exports, "CanceledError", ()=>CanceledError);
parcelHelpers.export(exports, "isCancel", ()=>isCancel);
parcelHelpers.export(exports, "CancelToken", ()=>CancelToken);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "Cancel", ()=>Cancel);
parcelHelpers.export(exports, "isAxiosError", ()=>isAxiosError);
parcelHelpers.export(exports, "spread", ()=>spread);
parcelHelpers.export(exports, "toFormData", ()=>toFormData);
parcelHelpers.export(exports, "AxiosHeaders", ()=>AxiosHeaders);
parcelHelpers.export(exports, "HttpStatusCode", ()=>HttpStatusCode);
parcelHelpers.export(exports, "formToJSON", ()=>formToJSON);
parcelHelpers.export(exports, "getAdapter", ()=>getAdapter);
parcelHelpers.export(exports, "mergeConfig", ()=>mergeConfig);
var _axiosJs = require("./lib/axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const { Axios , AxiosError , CanceledError , isCancel , CancelToken , VERSION , all , Cancel , isAxiosError , spread , toFormData , AxiosHeaders , HttpStatusCode , formToJSON , getAdapter , mergeConfig  } = (0, _axiosJsDefault.default);

},{"./lib/axios.js":"63MyY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"63MyY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _axiosJs = require("./core/Axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
var _mergeConfigJs = require("./core/mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _indexJs = require("./defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("./helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
var _canceledErrorJs = require("./cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _cancelTokenJs = require("./cancel/CancelToken.js");
var _cancelTokenJsDefault = parcelHelpers.interopDefault(_cancelTokenJs);
var _isCancelJs = require("./cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _dataJs = require("./env/data.js");
var _toFormDataJs = require("./helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _axiosErrorJs = require("./core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _spreadJs = require("./helpers/spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _isAxiosErrorJs = require("./helpers/isAxiosError.js");
var _isAxiosErrorJsDefault = parcelHelpers.interopDefault(_isAxiosErrorJs);
var _axiosHeadersJs = require("./core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("./adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
var _httpStatusCodeJs = require("./helpers/HttpStatusCode.js");
var _httpStatusCodeJsDefault = parcelHelpers.interopDefault(_httpStatusCodeJs);
"use strict";
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    const context = new (0, _axiosJsDefault.default)(defaultConfig);
    const instance = (0, _bindJsDefault.default)((0, _axiosJsDefault.default).prototype.request, context);
    // Copy axios.prototype to instance
    (0, _utilsJsDefault.default).extend(instance, (0, _axiosJsDefault.default).prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    (0, _utilsJsDefault.default).extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance((0, _mergeConfigJsDefault.default)(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
const axios = createInstance((0, _indexJsDefault.default));
// Expose Axios class to allow class inheritance
axios.Axios = (0, _axiosJsDefault.default);
// Expose Cancel & CancelToken
axios.CanceledError = (0, _canceledErrorJsDefault.default);
axios.CancelToken = (0, _cancelTokenJsDefault.default);
axios.isCancel = (0, _isCancelJsDefault.default);
axios.VERSION = (0, _dataJs.VERSION);
axios.toFormData = (0, _toFormDataJsDefault.default);
// Expose AxiosError class
axios.AxiosError = (0, _axiosErrorJsDefault.default);
// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = (0, _spreadJsDefault.default);
// Expose isAxiosError
axios.isAxiosError = (0, _isAxiosErrorJsDefault.default);
// Expose mergeConfig
axios.mergeConfig = (0, _mergeConfigJsDefault.default);
axios.AxiosHeaders = (0, _axiosHeadersJsDefault.default);
axios.formToJSON = (thing)=>(0, _formDataToJSONJsDefault.default)((0, _utilsJsDefault.default).isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = (0, _adaptersJsDefault.default).getAdapter;
axios.HttpStatusCode = (0, _httpStatusCodeJsDefault.default);
axios.default = axios;
// this module should only have a default export
exports.default = axios;

},{"./utils.js":"5By4s","./helpers/bind.js":"haRQb","./core/Axios.js":"cpqD8","./core/mergeConfig.js":"b85oP","./defaults/index.js":"hXfHM","./helpers/formDataToJSON.js":"01RfH","./cancel/CanceledError.js":"9PwCG","./cancel/CancelToken.js":"45wzn","./cancel/isCancel.js":"a0VmF","./env/data.js":"h29L9","./helpers/toFormData.js":"ajoez","./core/AxiosError.js":"3u8Tl","./helpers/spread.js":"dyQ8N","./helpers/isAxiosError.js":"eyiLq","./core/AxiosHeaders.js":"cgSSx","./adapters/adapters.js":"d7JxI","./helpers/HttpStatusCode.js":"fdR61","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5By4s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var global = arguments[3];
"use strict";
// utils is a library of generic helper functions non-specific to axios
const { toString  } = Object.prototype;
const { getPrototypeOf  } = Object;
const kindOf = ((cache)=>(thing)=>{
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));
const kindOfTest = (type)=>{
    type = type.toLowerCase();
    return (thing)=>kindOf(thing) === type;
};
const typeOfTest = (type)=>(thing)=>typeof thing === type;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ const { isArray  } = Array;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ const isUndefined = typeOfTest("undefined");
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ const isArrayBuffer = kindOfTest("ArrayBuffer");
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ const isString = typeOfTest("string");
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ const isFunction = typeOfTest("function");
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ const isNumber = typeOfTest("number");
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ const isObject = (thing)=>thing !== null && typeof thing === "object";
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ const isBoolean = (thing)=>thing === true || thing === false;
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ const isPlainObject = (val)=>{
    if (kindOf(val) !== "object") return false;
    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ const isDate = kindOfTest("Date");
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFile = kindOfTest("File");
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ const isBlob = kindOfTest("Blob");
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFileList = kindOfTest("FileList");
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ const isStream = (val)=>isObject(val) && isFunction(val.pipe);
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ const isFormData = (thing)=>{
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ const isURLSearchParams = kindOfTest("URLSearchParams");
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function forEach(obj, fn, { allOwnKeys =false  } = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") return;
    let i;
    let l;
    // Force an array if not already something iterable
    if (typeof obj !== "object") /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) return _key;
    }
    return null;
}
const _global = (()=>{
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context)=>!isUndefined(context) && context !== _global;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function merge() {
    const { caseless  } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key)=>{
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) result[targetKey] = merge(result[targetKey], val);
        else if (isPlainObject(val)) result[targetKey] = merge({}, val);
        else if (isArray(val)) result[targetKey] = val.slice();
        else result[targetKey] = val;
    };
    for(let i = 0, l = arguments.length; i < l; i++)arguments[i] && forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ const extend = (a, b, thisArg, { allOwnKeys  } = {})=>{
    forEach(b, (val, key)=>{
        if (thisArg && isFunction(val)) a[key] = (0, _bindJsDefault.default)(val, thisArg);
        else a[key] = val;
    }, {
        allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ const stripBOM = (content)=>{
    if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ const inherits = (constructor, superConstructor, props, descriptors)=>{
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ const endsWith = (str, searchString, position)=>{
    str = String(str);
    if (position === undefined || position > str.length) position = str.length;
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ const toArray = (thing)=>{
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while(i-- > 0)arr[i] = thing[i];
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
const isTypedArray = ((TypedArray)=>{
    // eslint-disable-next-line func-names
    return (thing)=>{
        return TypedArray && thing instanceof TypedArray;
    };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ const forEachEntry = (obj, fn)=>{
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while((result = iterator.next()) && !result.done){
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ const matchAll = (regExp, str)=>{
    let matches;
    const arr = [];
    while((matches = regExp.exec(str)) !== null)arr.push(matches);
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str)=>{
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ const hasOwnProperty = (({ hasOwnProperty  })=>(obj, prop)=>hasOwnProperty.call(obj, prop))(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer)=>{
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors, (descriptor, name)=>{
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ const freezeMethods = (obj)=>{
    reduceDescriptors(obj, (descriptor, name)=>{
        // skip restricted props in strict mode
        if (isFunction(obj) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(name) !== -1) return false;
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) descriptor.set = ()=>{
            throw Error("Can not rewrite read-only method '" + name + "'");
        };
    });
};
const toObjectSet = (arrayOrString, delimiter)=>{
    const obj = {};
    const define = (arr)=>{
        arr.forEach((value)=>{
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
const noop = ()=>{};
const toFiniteNumber = (value, defaultValue)=>{
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT)=>{
    let str = "";
    const { length  } = alphabet;
    while(size--)str += alphabet[Math.random() * length | 0];
    return str;
};
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj)=>{
    const stack = new Array(10);
    const visit = (source, i)=>{
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) return;
            if (!("toJSON" in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {};
                forEach(source, (value, key)=>{
                    const reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing)=>thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
exports.default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
};

},{"./helpers/bind.js":"haRQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"haRQb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}
exports.default = bind;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpqD8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _buildURLJs = require("../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _interceptorManagerJs = require("./InterceptorManager.js");
var _interceptorManagerJsDefault = parcelHelpers.interopDefault(_interceptorManagerJs);
var _dispatchRequestJs = require("./dispatchRequest.js");
var _dispatchRequestJsDefault = parcelHelpers.interopDefault(_dispatchRequestJs);
var _mergeConfigJs = require("./mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _buildFullPathJs = require("./buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _validatorJs = require("../helpers/validator.js");
var _validatorJsDefault = parcelHelpers.interopDefault(_validatorJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const validators = (0, _validatorJsDefault.default).validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ class Axios {
    constructor(instanceConfig){
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new (0, _interceptorManagerJsDefault.default)(),
            response: new (0, _interceptorManagerJsDefault.default)()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ async request(configOrUrl, config) {
        try {
            return await this._request(configOrUrl, config);
        } catch (err) {
            if (err instanceof Error) {
                let dummy;
                Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
                // slice off the Error: ... line
                const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
                if (!err.stack) err.stack = stack;
                else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) err.stack += "\n" + stack;
            }
            throw err;
        }
    }
    _request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
        } else config = configOrUrl || {};
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const { transitional , paramsSerializer , headers  } = config;
        if (transitional !== undefined) (0, _validatorJsDefault.default).assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
        if (paramsSerializer != null) {
            if ((0, _utilsJsDefault.default).isFunction(paramsSerializer)) config.paramsSerializer = {
                serialize: paramsSerializer
            };
            else (0, _validatorJsDefault.default).assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
            }, true);
        }
        // Set config.method
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        // Flatten headers
        let contextHeaders = headers && (0, _utilsJsDefault.default).merge(headers.common, headers[config.method]);
        headers && (0, _utilsJsDefault.default).forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (method)=>{
            delete headers[method];
        });
        config.headers = (0, _axiosHeadersJsDefault.default).concat(contextHeaders, headers);
        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
            const chain = [
                (0, _dispatchRequestJsDefault.default).bind(this),
                undefined
            ];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while(i < len)promise = promise.then(chain[i++], chain[i++]);
            return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while(i < len){
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
                newConfig = onFulfilled(newConfig);
            } catch (error) {
                onRejected.call(this, error);
                break;
            }
        }
        try {
            promise = (0, _dispatchRequestJsDefault.default).call(this, newConfig);
        } catch (error) {
            return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while(i < len)promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        return promise;
    }
    getUri(config) {
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        return (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer);
    }
}
// Provide aliases for supported request methods
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
            method,
            url,
            data: (config || {}).data
        }));
    };
});
(0, _utilsJsDefault.default).forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
                method,
                headers: isForm ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url,
                data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
exports.default = Axios;

},{"./../utils.js":"5By4s","../helpers/buildURL.js":"3bwC2","./InterceptorManager.js":"1VRIM","./dispatchRequest.js":"6sjJ6","./mergeConfig.js":"b85oP","./buildFullPath.js":"1I5TW","../helpers/validator.js":"9vgkY","./AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bwC2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosURLSearchParamsJs = require("../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) serializedParams = serializeFn(params, options);
    else serializedParams = (0, _utilsJsDefault.default).isURLSearchParams(params) ? params.toString() : new (0, _axiosURLSearchParamsJsDefault.default)(params, options).toString(_encode);
    if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
}
exports.default = buildURL;

},{"../utils.js":"5By4s","../helpers/AxiosURLSearchParams.js":"hz84m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hz84m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
"use strict";
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function encode(str) {
    const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && (0, _toFormDataJsDefault.default)(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
};
exports.default = AxiosURLSearchParams;

},{"./toFormData.js":"ajoez","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ajoez":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
var _formDataJs = require("../platform/node/classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var Buffer = require("5bb67effada977f6").Buffer;
"use strict";
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function isVisitable(thing) {
    return (0, _utilsJsDefault.default).isPlainObject(thing) || (0, _utilsJsDefault.default).isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function removeBrackets(key) {
    return (0, _utilsJsDefault.default).endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function isFlatArray(arr) {
    return (0, _utilsJsDefault.default).isArray(arr) && !arr.some(isVisitable);
}
const predicates = (0, _utilsJsDefault.default).toFlatObject((0, _utilsJsDefault.default), {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function toFormData(obj, formData, options) {
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("target must be an object");
    // eslint-disable-next-line no-param-reassign
    formData = formData || new ((0, _formDataJsDefault.default) || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = (0, _utilsJsDefault.default).toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !(0, _utilsJsDefault.default).isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && (0, _utilsJsDefault.default).isSpecCompliantForm(formData);
    if (!(0, _utilsJsDefault.default).isFunction(visitor)) throw new TypeError("visitor must be a function");
    function convertValue(value) {
        if (value === null) return "";
        if ((0, _utilsJsDefault.default).isDate(value)) return value.toISOString();
        if (!useBlob && (0, _utilsJsDefault.default).isBlob(value)) throw new (0, _axiosErrorJsDefault.default)("Blob is not supported. Use a Buffer instead.");
        if ((0, _utilsJsDefault.default).isArrayBuffer(value) || (0, _utilsJsDefault.default).isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([
            value
        ]) : Buffer.from(value);
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
            if ((0, _utilsJsDefault.default).endsWith(key, "{}")) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if ((0, _utilsJsDefault.default).isArray(value) && isFlatArray(value) || ((0, _utilsJsDefault.default).isFileList(value) || (0, _utilsJsDefault.default).endsWith(key, "[]")) && (arr = (0, _utilsJsDefault.default).toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) return true;
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
    });
    function build(value, path) {
        if ((0, _utilsJsDefault.default).isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path.join("."));
        stack.push(value);
        (0, _utilsJsDefault.default).forEach(value, function each(el, key) {
            const result = !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && visitor.call(formData, el, (0, _utilsJsDefault.default).isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) build(el, path ? path.concat(key) : [
                key
            ]);
        });
        stack.pop();
    }
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("data must be an object");
    build(obj);
    return formData;
}
exports.default = toFormData;

},{"5bb67effada977f6":"fCgem","../utils.js":"5By4s","../core/AxiosError.js":"3u8Tl","../platform/node/classes/FormData.js":"aFlee","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
var base64 = require("767eb5fa78affaaf");
var ieee754 = require("8d3c317e2149151d");
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"767eb5fa78affaaf":"eIiSV","8d3c317e2149151d":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"3u8Tl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = new Error().stack;
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
}
(0, _utilsJsDefault.default).inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: (0, _utilsJsDefault.default).toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    }
});
const prototype = AxiosError.prototype;
const descriptors = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((code)=>{
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", {
    value: true
});
// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps)=>{
    const axiosError = Object.create(prototype);
    (0, _utilsJsDefault.default).toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, (prop)=>{
        return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
exports.default = AxiosError;

},{"../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFlee":[function(require,module,exports) {
// eslint-disable-next-line strict
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VRIM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
class InterceptorManager {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(fulfilled, rejected, options) {
        this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(id) {
        if (this.handlers[id]) this.handlers[id] = null;
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        if (this.handlers) this.handlers = [];
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(fn) {
        (0, _utilsJsDefault.default).forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) fn(h);
        });
    }
}
exports.default = InterceptorManager;

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6sjJ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _transformDataJs = require("./transformData.js");
var _transformDataJsDefault = parcelHelpers.interopDefault(_transformDataJs);
var _isCancelJs = require("../cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("../adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
"use strict";
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new (0, _canceledErrorJsDefault.default)(null, config);
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = (0, _axiosHeadersJsDefault.default).from(config.headers);
    // Transform request data
    config.data = (0, _transformDataJsDefault.default).call(config, config.transformRequest);
    if ([
        "post",
        "put",
        "patch"
    ].indexOf(config.method) !== -1) config.headers.setContentType("application/x-www-form-urlencoded", false);
    const adapter = (0, _adaptersJsDefault.default).getAdapter(config.adapter || (0, _indexJsDefault.default).adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, response);
        response.headers = (0, _axiosHeadersJsDefault.default).from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!(0, _isCancelJsDefault.default)(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, reason.response);
                reason.response.headers = (0, _axiosHeadersJsDefault.default).from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}
exports.default = dispatchRequest;

},{"./transformData.js":"eRqJY","../cancel/isCancel.js":"a0VmF","../defaults/index.js":"hXfHM","../cancel/CanceledError.js":"9PwCG","../core/AxiosHeaders.js":"cgSSx","../adapters/adapters.js":"d7JxI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eRqJY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
function transformData(fns, response) {
    const config = this || (0, _indexJsDefault.default);
    const context = response || config;
    const headers = (0, _axiosHeadersJsDefault.default).from(context.headers);
    let data = context.data;
    (0, _utilsJsDefault.default).forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}
exports.default = transformData;

},{"./../utils.js":"5By4s","../defaults/index.js":"hXfHM","../core/AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hXfHM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _transitionalJs = require("./transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _toFormDataJs = require("../helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _toURLEncodedFormJs = require("../helpers/toURLEncodedForm.js");
var _toURLEncodedFormJsDefault = parcelHelpers.interopDefault(_toURLEncodedFormJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("../helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
"use strict";
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function stringifySafely(rawValue, parser, encoder) {
    if ((0, _utilsJsDefault.default).isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return (0, _utilsJsDefault.default).trim(rawValue);
    } catch (e) {
        if (e.name !== "SyntaxError") throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
    transitional: (0, _transitionalJsDefault.default),
    adapter: [
        "xhr",
        "http"
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            const contentType = headers.getContentType() || "";
            const hasJSONContentType = contentType.indexOf("application/json") > -1;
            const isObjectPayload = (0, _utilsJsDefault.default).isObject(data);
            if (isObjectPayload && (0, _utilsJsDefault.default).isHTMLForm(data)) data = new FormData(data);
            const isFormData = (0, _utilsJsDefault.default).isFormData(data);
            if (isFormData) return hasJSONContentType ? JSON.stringify((0, _formDataToJSONJsDefault.default)(data)) : data;
            if ((0, _utilsJsDefault.default).isArrayBuffer(data) || (0, _utilsJsDefault.default).isBuffer(data) || (0, _utilsJsDefault.default).isStream(data) || (0, _utilsJsDefault.default).isFile(data) || (0, _utilsJsDefault.default).isBlob(data)) return data;
            if ((0, _utilsJsDefault.default).isArrayBufferView(data)) return data.buffer;
            if ((0, _utilsJsDefault.default).isURLSearchParams(data)) {
                headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                return data.toString();
            }
            let isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf("application/x-www-form-urlencoded") > -1) return (0, _toURLEncodedFormJsDefault.default)(data, this.formSerializer).toString();
                if ((isFileList = (0, _utilsJsDefault.default).isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                    const _FormData = this.env && this.env.FormData;
                    return (0, _toFormDataJsDefault.default)(isFileList ? {
                        "files[]": data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            const transitional = this.transitional || defaults.transitional;
            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            const JSONRequested = this.responseType === "json";
            if (data && (0, _utilsJsDefault.default).isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                const silentJSONParsing = transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") throw (0, _axiosErrorJsDefault.default).from(e, (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE, this, null, this.response);
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: (0, _indexJsDefault.default).classes.FormData,
        Blob: (0, _indexJsDefault.default).classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": undefined
        }
    }
};
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (method)=>{
    defaults.headers[method] = {};
});
exports.default = defaults;

},{"../utils.js":"5By4s","../core/AxiosError.js":"3u8Tl","./transitional.js":"lM32f","../helpers/toFormData.js":"ajoez","../helpers/toURLEncodedForm.js":"9hjry","../platform/index.js":"7tDev","../helpers/formDataToJSON.js":"01RfH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lM32f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hjry":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
function toURLEncodedForm(data, options) {
    return (0, _toFormDataJsDefault.default)(data, new (0, _indexJsDefault.default).classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
            if ((0, _indexJsDefault.default).isNode && (0, _utilsJsDefault.default).isBuffer(value)) {
                this.append(key, value.toString("base64"));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}
exports.default = toURLEncodedForm;

},{"../utils.js":"5By4s","./toFormData.js":"ajoez","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7tDev":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./node/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _utilsJs = require("./common/utils.js");
exports.default = {
    ..._utilsJs,
    ...(0, _indexJsDefault.default)
};

},{"./node/index.js":"cVeqE","./common/utils.js":"iIwkL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cVeqE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _urlsearchParamsJs = require("./classes/URLSearchParams.js");
var _urlsearchParamsJsDefault = parcelHelpers.interopDefault(_urlsearchParamsJs);
var _formDataJs = require("./classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var _blobJs = require("./classes/Blob.js");
var _blobJsDefault = parcelHelpers.interopDefault(_blobJs);
exports.default = {
    isBrowser: true,
    classes: {
        URLSearchParams: (0, _urlsearchParamsJsDefault.default),
        FormData: (0, _formDataJsDefault.default),
        Blob: (0, _blobJsDefault.default)
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
};

},{"./classes/URLSearchParams.js":"5cIHE","./classes/FormData.js":"7i1jd","./classes/Blob.js":"8chF6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cIHE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosURLSearchParamsJs = require("../../../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
exports.default = typeof URLSearchParams !== "undefined" ? URLSearchParams : (0, _axiosURLSearchParamsJsDefault.default);

},{"../../../helpers/AxiosURLSearchParams.js":"hz84m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7i1jd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof FormData !== "undefined" ? FormData : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8chF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof Blob !== "undefined" ? Blob : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iIwkL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasBrowserEnv", ()=>hasBrowserEnv);
parcelHelpers.export(exports, "hasStandardBrowserWebWorkerEnv", ()=>hasStandardBrowserWebWorkerEnv);
parcelHelpers.export(exports, "hasStandardBrowserEnv", ()=>hasStandardBrowserEnv);
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ const hasStandardBrowserEnv = ((product)=>{
    return hasBrowserEnv && [
        "ReactNative",
        "NativeScript",
        "NS"
    ].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ const hasStandardBrowserWebWorkerEnv = (()=>{
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01RfH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return (0, _utilsJsDefault.default).matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
        return match[0] === "[]" ? "" : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && (0, _utilsJsDefault.default).isArray(target) ? target.length : name;
        if (isLast) {
            if ((0, _utilsJsDefault.default).hasOwnProp(target, name)) target[name] = [
                target[name],
                value
            ];
            else target[name] = value;
            return !isNumericKey;
        }
        if (!target[name] || !(0, _utilsJsDefault.default).isObject(target[name])) target[name] = [];
        const result = buildPath(path, value, target[name], index);
        if (result && (0, _utilsJsDefault.default).isArray(target[name])) target[name] = arrayToObject(target[name]);
        return !isNumericKey;
    }
    if ((0, _utilsJsDefault.default).isFormData(formData) && (0, _utilsJsDefault.default).isFunction(formData.entries)) {
        const obj = {};
        (0, _utilsJsDefault.default).forEachEntry(formData, (name, value)=>{
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
exports.default = formDataToJSON;

},{"../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgSSx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _parseHeadersJs = require("../helpers/parseHeaders.js");
var _parseHeadersJsDefault = parcelHelpers.interopDefault(_parseHeadersJs);
"use strict";
const $internals = Symbol("internals");
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) return value;
    return (0, _utilsJsDefault.default).isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while(match = tokensRE.exec(str))tokens[match[1]] = match[2];
    return tokens;
}
const isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if ((0, _utilsJsDefault.default).isFunction(filter)) return filter.call(this, value, header);
    if (isHeaderNameFilter) value = header;
    if (!(0, _utilsJsDefault.default).isString(value)) return;
    if ((0, _utilsJsDefault.default).isString(filter)) return value.indexOf(filter) !== -1;
    if ((0, _utilsJsDefault.default).isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str)=>{
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    const accessorName = (0, _utilsJsDefault.default).toCamelCase(" " + header);
    [
        "get",
        "set",
        "has"
    ].forEach((methodName)=>{
        Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
class AxiosHeaders {
    constructor(headers){
        headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
        const self = this;
        function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) throw new Error("header name must be a non-empty string");
            const key = (0, _utilsJsDefault.default).findKey(self, lHeader);
            if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) self[key || _header] = normalizeValue(_value);
        }
        const setHeaders = (headers, _rewrite)=>(0, _utilsJsDefault.default).forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));
        if ((0, _utilsJsDefault.default).isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
        else if ((0, _utilsJsDefault.default).isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders((0, _parseHeadersJsDefault.default)(header), valueOrRewrite);
        else header != null && setHeader(valueOrRewrite, header, rewrite);
        return this;
    }
    get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            if (key) {
                const value = this[key];
                if (!parser) return value;
                if (parser === true) return parseTokens(value);
                if ((0, _utilsJsDefault.default).isFunction(parser)) return parser.call(this, value, key);
                if ((0, _utilsJsDefault.default).isRegExp(parser)) return parser.exec(value);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
    }
    delete(header, matcher) {
        const self = this;
        let deleted = false;
        function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
                const key = (0, _utilsJsDefault.default).findKey(self, _header);
                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                    delete self[key];
                    deleted = true;
                }
            }
        }
        if ((0, _utilsJsDefault.default).isArray(header)) header.forEach(deleteHeader);
        else deleteHeader(header);
        return deleted;
    }
    clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while(i--){
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                delete this[key];
                deleted = true;
            }
        }
        return deleted;
    }
    normalize(format) {
        const self = this;
        const headers = {};
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            const key = (0, _utilsJsDefault.default).findKey(headers, header);
            if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) delete self[header];
            self[normalized] = normalizeValue(value);
            headers[normalized] = true;
        });
        return this;
    }
    concat(...targets) {
        return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
        const obj = Object.create(null);
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            value != null && value !== false && (obj[header] = asStrings && (0, _utilsJsDefault.default).isArray(value) ? value.join(", ") : value);
        });
        return obj;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([header, value])=>header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(thing) {
        return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target)=>computed.set(target));
        return computed;
    }
    static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
            accessors: {}
        };
        const accessors = internals.accessors;
        const prototype = this.prototype;
        function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
            }
        }
        (0, _utilsJsDefault.default).isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
    }
}
AxiosHeaders.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
// reserved names hotfix
(0, _utilsJsDefault.default).reduceDescriptors(AxiosHeaders.prototype, ({ value  }, key)=>{
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
        get: ()=>value,
        set (headerValue) {
            this[mapped] = headerValue;
        }
    };
});
(0, _utilsJsDefault.default).freezeMethods(AxiosHeaders);
exports.default = AxiosHeaders;

},{"../utils.js":"5By4s","../helpers/parseHeaders.js":"kqDd5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqDd5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = (0, _utilsJsDefault.default).toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]);
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */ exports.default = (rawHeaders)=>{
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
        if (key === "set-cookie") {
            if (parsed[key]) parsed[key].push(val);
            else parsed[key] = [
                val
            ];
        } else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    });
    return parsed;
};

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0VmF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}
exports.default = isCancel;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9PwCG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    (0, _axiosErrorJsDefault.default).call(this, message == null ? "canceled" : message, (0, _axiosErrorJsDefault.default).ERR_CANCELED, config, request);
    this.name = "CanceledError";
}
(0, _utilsJsDefault.default).inherits(CanceledError, (0, _axiosErrorJsDefault.default), {
    __CANCEL__: true
});
exports.default = CanceledError;

},{"../core/AxiosError.js":"3u8Tl","../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7JxI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _httpJs = require("./http.js");
var _httpJsDefault = parcelHelpers.interopDefault(_httpJs);
var _xhrJs = require("./xhr.js");
var _xhrJsDefault = parcelHelpers.interopDefault(_xhrJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
const knownAdapters = {
    http: (0, _httpJsDefault.default),
    xhr: (0, _xhrJsDefault.default)
};
(0, _utilsJsDefault.default).forEach(knownAdapters, (fn, value)=>{
    if (fn) {
        try {
            Object.defineProperty(fn, "name", {
                value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, "adapterName", {
            value
        });
    }
});
const renderReason = (reason)=>`- ${reason}`;
const isResolvedHandle = (adapter)=>(0, _utilsJsDefault.default).isFunction(adapter) || adapter === null || adapter === false;
exports.default = {
    getAdapter: (adapters)=>{
        adapters = (0, _utilsJsDefault.default).isArray(adapters) ? adapters : [
            adapters
        ];
        const { length  } = adapters;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for(let i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === undefined) throw new (0, _axiosErrorJsDefault.default)(`Unknown adapter '${id}'`);
            }
            if (adapter) break;
            rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(([id, state])=>`adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new (0, _axiosErrorJsDefault.default)(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
        }
        return adapter;
    },
    adapters: knownAdapters
};

},{"../utils.js":"5By4s","./http.js":"aFlee","./xhr.js":"ldm57","../core/AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ldm57":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _settleJs = require("./../core/settle.js");
var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
var _cookiesJs = require("./../helpers/cookies.js");
var _cookiesJsDefault = parcelHelpers.interopDefault(_cookiesJs);
var _buildURLJs = require("./../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _buildFullPathJs = require("../core/buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _isURLSameOriginJs = require("./../helpers/isURLSameOrigin.js");
var _isURLSameOriginJsDefault = parcelHelpers.interopDefault(_isURLSameOriginJs);
var _transitionalJs = require("../defaults/transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _parseProtocolJs = require("../helpers/parseProtocol.js");
var _parseProtocolJsDefault = parcelHelpers.interopDefault(_parseProtocolJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _speedometerJs = require("../helpers/speedometer.js");
var _speedometerJsDefault = parcelHelpers.interopDefault(_speedometerJs);
"use strict";
function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = (0, _speedometerJsDefault.default)(50, 250);
    return (e)=>{
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
            loaded,
            total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
    };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
exports.default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = (0, _axiosHeadersJsDefault.default).from(config.headers).normalize();
        let { responseType , withXSRFToken  } = config;
        let onCanceled;
        function done() {
            if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
            if (config.signal) config.signal.removeEventListener("abort", onCanceled);
        }
        let contentType;
        if ((0, _utilsJsDefault.default).isFormData(requestData)) {
            if ((0, _indexJsDefault.default).hasStandardBrowserEnv || (0, _indexJsDefault.default).hasStandardBrowserWebWorkerEnv) requestHeaders.setContentType(false); // Let the browser set it
            else if ((contentType = requestHeaders.getContentType()) !== false) {
                // fix semicolon duplication issue for ReactNative FormData implementation
                const [type, ...tokens] = contentType ? contentType.split(";").map((token)=>token.trim()).filter(Boolean) : [];
                requestHeaders.setContentType([
                    type || "multipart/form-data",
                    ...tokens
                ].join("; "));
            }
        }
        let request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            const responseHeaders = (0, _axiosHeadersJsDefault.default).from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
            };
            (0, _settleJsDefault.default)(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(new (0, _axiosErrorJsDefault.default)("Request aborted", (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new (0, _axiosErrorJsDefault.default)("Network Error", (0, _axiosErrorJsDefault.default).ERR_NETWORK, config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || (0, _transitionalJsDefault.default);
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(new (0, _axiosErrorJsDefault.default)(timeoutErrorMessage, transitional.clarifyTimeoutError ? (0, _axiosErrorJsDefault.default).ETIMEDOUT : (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if ((0, _indexJsDefault.default).hasStandardBrowserEnv) {
            withXSRFToken && (0, _utilsJsDefault.default).isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
            if (withXSRFToken || withXSRFToken !== false && (0, _isURLSameOriginJsDefault.default)(fullPath)) {
                // Add xsrf header
                const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && (0, _cookiesJsDefault.default).read(config.xsrfCookieName);
                if (xsrfValue) requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
        }
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ("setRequestHeader" in request) (0, _utilsJsDefault.default).forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!(0, _utilsJsDefault.default).isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== "json") request.responseType = config.responseType;
        // Handle progress if needed
        if (typeof config.onDownloadProgress === "function") request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === "function" && request.upload) request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = (cancel)=>{
                if (!request) return;
                reject(!cancel || cancel.type ? new (0, _canceledErrorJsDefault.default)(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
        const protocol = (0, _parseProtocolJsDefault.default)(fullPath);
        if (protocol && (0, _indexJsDefault.default).protocols.indexOf(protocol) === -1) {
            reject(new (0, _axiosErrorJsDefault.default)("Unsupported protocol " + protocol + ":", (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};

},{"./../utils.js":"5By4s","./../core/settle.js":"dD9aC","./../helpers/cookies.js":"4WJjt","./../helpers/buildURL.js":"3bwC2","../core/buildFullPath.js":"1I5TW","./../helpers/isURLSameOrigin.js":"lxXtv","../defaults/transitional.js":"lM32f","../core/AxiosError.js":"3u8Tl","../cancel/CanceledError.js":"9PwCG","../helpers/parseProtocol.js":"7NfWU","../platform/index.js":"7tDev","../core/AxiosHeaders.js":"cgSSx","../helpers/speedometer.js":"gQeo1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dD9aC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("./AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(new (0, _axiosErrorJsDefault.default)("Request failed with status code " + response.status, [
        (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST,
        (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE
    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}
exports.default = settle;

},{"./AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4WJjt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write (name, value, expires, path, domain, secure) {
        const cookie = [
            name + "=" + encodeURIComponent(value)
        ];
        (0, _utilsJsDefault.default).isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        (0, _utilsJsDefault.default).isString(path) && cookie.push("path=" + path);
        (0, _utilsJsDefault.default).isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
    },
    read (name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
    },
    remove (name) {
        this.write(name, "", Date.now() - 86400000);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write () {},
    read () {
        return null;
    },
    remove () {}
};

},{"./../utils.js":"5By4s","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1I5TW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isAbsoluteURLJs = require("../helpers/isAbsoluteURL.js");
var _isAbsoluteURLJsDefault = parcelHelpers.interopDefault(_isAbsoluteURLJs);
var _combineURLsJs = require("../helpers/combineURLs.js");
var _combineURLsJsDefault = parcelHelpers.interopDefault(_combineURLsJs);
"use strict";
function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !(0, _isAbsoluteURLJsDefault.default)(requestedURL)) return (0, _combineURLsJsDefault.default)(baseURL, requestedURL);
    return requestedURL;
}
exports.default = buildFullPath;

},{"../helpers/isAbsoluteURL.js":"jD6NM","../helpers/combineURLs.js":"brOWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jD6NM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
exports.default = isAbsoluteURL;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"brOWK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
exports.default = combineURLs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lxXtv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
exports.default = (0, _indexJsDefault.default).hasStandardBrowserEnv ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        let href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        const parsed = (0, _utilsJsDefault.default).isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();

},{"./../utils.js":"5By4s","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7NfWU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
}
exports.default = parseProtocol;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQeo1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) firstSampleTS = now;
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) tail = (tail + 1) % samplesCount;
        if (now - firstSampleTS < min) return;
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
exports.default = speedometer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b85oP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const headersToObject = (thing)=>thing instanceof (0, _axiosHeadersJsDefault.default) ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
        if ((0, _utilsJsDefault.default).isPlainObject(target) && (0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge.call({
            caseless
        }, target, source);
        else if ((0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge({}, source);
        else if ((0, _utilsJsDefault.default).isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(a, b, caseless);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a, caseless);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) return getMergedValue(a, b);
        else if (prop in config1) return getMergedValue(undefined, a);
    }
    const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b)=>mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };
    (0, _utilsJsDefault.default).forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (0, _utilsJsDefault.default).isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}
exports.default = mergeConfig;

},{"../utils.js":"5By4s","./AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vgkY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("../env/data.js");
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
const validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((type, i)=>{
    validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
const deprecatedWarnings = {};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + (0, _dataJs.VERSION) + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return (value, opt, opts)=>{
        if (validator === false) throw new (0, _axiosErrorJsDefault.default)(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), (0, _axiosErrorJsDefault.default).ERR_DEPRECATED);
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") throw new (0, _axiosErrorJsDefault.default)("options must be an object", (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
    const keys = Object.keys(options);
    let i = keys.length;
    while(i-- > 0){
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
            const value = options[opt];
            const result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new (0, _axiosErrorJsDefault.default)("option " + opt + " must be " + result, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (allowUnknown !== true) throw new (0, _axiosErrorJsDefault.default)("Unknown option " + opt, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION);
    }
}
exports.default = {
    assertOptions,
    validators
};

},{"../env/data.js":"h29L9","../core/AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h29L9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
const VERSION = "1.6.7";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"45wzn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _canceledErrorJs = require("./CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
"use strict";
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ class CancelToken {
    constructor(executor){
        if (typeof executor !== "function") throw new TypeError("executor must be a function.");
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        const token = this;
        // eslint-disable-next-line func-names
        this.promise.then((cancel)=>{
            if (!token._listeners) return;
            let i = token._listeners.length;
            while(i-- > 0)token._listeners[i](cancel);
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = (onfulfilled)=>{
            let _resolve;
            // eslint-disable-next-line func-names
            const promise = new Promise((resolve)=>{
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) // Cancellation has already been requested
            return;
            token.reason = new (0, _canceledErrorJsDefault.default)(message, config, request);
            resolvePromise(token.reason);
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(listener) {
        if (this.reason) {
            listener(this.reason);
            return;
        }
        if (this._listeners) this._listeners.push(listener);
        else this._listeners = [
            listener
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(listener) {
        if (!this._listeners) return;
        const index = this._listeners.indexOf(listener);
        if (index !== -1) this._listeners.splice(index, 1);
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
            cancel = c;
        });
        return {
            token,
            cancel
        };
    }
}
exports.default = CancelToken;

},{"./CanceledError.js":"9PwCG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyQ8N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}
exports.default = spread;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyiLq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
function isAxiosError(payload) {
    return (0, _utilsJsDefault.default).isObject(payload) && payload.isAxiosError === true;
}
exports.default = isAxiosError;

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fdR61":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value])=>{
    HttpStatusCode[value] = key;
});
exports.default = HttpStatusCode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqVCg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "PromiseQueue", ()=>PromiseQueue);
var _logger = require("./logger");
const log = new (0, _logger.Logger)("packages/common/src/promise.ts");
class PromiseQueue {
    id = Math.random().toString().slice(2);
    queue = [];
    running = false;
    push = (promise)=>new Promise((r, f)=>{
            this.queue.push({
                promise,
                done: r,
                failed: f
            });
            if (!this.running) this.run().catch((e)=>{
                log.error("push", e);
            });
        });
    async run() {
        const task = this.queue.shift();
        if (task) {
            this.running = true;
            // log.debug('[start] task', { id: this.id, task });
            try {
                const res = await task.promise();
                task.done(res);
            } catch (error) {
                task.failed(error);
            }
            // log.debug('[end] task', { id: this.id, task });
            await this.run();
        } else this.running = false;
    }
}

},{"./logger":"3kwcm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bE3nE":[function(require,module,exports) {
/**@internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BackOff", ()=>BackOff);
parcelHelpers.export(exports, "deepCopy", ()=>deepCopy);
class BackOff {
    count = 0;
    times = 8;
    /**ms */ interval = 100;
    /**ms */ jitter = 0;
    /**20.4 sec {var sum=0;for(i=0;i<=8;i++){sum +=i ** 2 * 100}} */ constructor(props = {}){
        Object.assign(this, props);
    }
    /**if need wait return true */ async wait() {
        if (this.exceeded) return false;
        const timeout = this.timeout;
        this.count++;
        await new Promise((r)=>setTimeout(r, timeout));
        return true;
    }
    get timeout() {
        const timeout = this.count ** 2 * this.interval + this.count ** 2 * this.jitter * Math.random();
        return timeout;
    }
    get exceeded() {
        return this.count >= this.times;
    }
    reset() {
        this.count = 0;
    }
}
const deepCopy = (o)=>JSON.parse(JSON.stringify(o));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDbIj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errors", ()=>errors);
const errors = {
    internal: {
        name: "internal",
        detail: "",
        solution: ""
    },
    timeout: {
        name: "timeout",
        detail: "",
        solution: ""
    },
    missingProperty: {
        name: "missingProperty",
        detail: "",
        solution: ""
    },
    notFound: {
        name: "notFound",
        detail: "",
        solution: ""
    },
    invalidParameter: {
        name: "invalidParameter",
        detail: "",
        solution: ""
    },
    invalidArgumentValue: {
        name: "invalidArgumentValue",
        detail: "引数の値が不正です",
        solution: "正しい値を引数に渡してください"
    },
    invalidContentType: {
        name: "invalidContentType",
        detail: "contentTypeが正しくありません",
        solution: "ContentTypeを確認してください"
    },
    localPersonNotJoinedChannel: {
        name: "localPersonNotJoinedChannel",
        detail: "操作しようとしたPersonがChannelに居ないので、操作できません The person who tried to operate is not in the channel, so the operation is not possible",
        solution: "Channelに居ないPersonを操作している可能性があるので確認してください Please check as you may be operating a person which is not in the channel"
    },
    alreadyLocalPersonExist: {
        name: "alreadyLocalPersonExist",
        detail: "ChannelにすでにLocalPersonが存在します。一つのChannelインスタンスにはLocalPersonが一つしかJoinできません",
        solution: "複数のLocalPersonを用意したい場合は個別にChannelインスタンスを用意してください。"
    },
    alreadySameNameMemberExist: {
        name: "alreadySameNameMemberExist",
        detail: "Channelにすでに同じNameのMemberが存在します",
        solution: "別のNameを使用してください"
    },
    alreadyPublishedStream: {
        name: "alreadyPublishedStream",
        detail: "すでにPublishしたStreamを再度Publishすることはできません You cannot re-publish a stream that has already been published",
        solution: "そのStreamをPublishしたPublicationをUnpublishするか、別の新しいStreamを作ってPublishしてください Unpublish the publication that published that stream, or create another new stream and publish it"
    },
    alreadySubscribedPublication: {
        name: "alreadySubscribedPublication",
        detail: "すでにSubscribeしたPublicationをSubscribeすることはできません",
        solution: "ありません"
    },
    invalidTrackKind: {
        name: "invalidTrackKind",
        detail: "Streamの種類とMediaStreamTrackの種類が一致しません",
        solution: "Streamの種類と同じMediaStreamTrackを利用してください"
    },
    cantMoveSameIdChannel: {
        name: "cantMoveSameIdChannel",
        detail: "moveChannelで同じidのChannelに移動することは出来ません",
        solution: "移動先のChannelが正しいか確かめてください"
    },
    alreadyChannelClosed: {
        name: "alreadyChannelClosed",
        detail: "ChannelがすでにCloseされています",
        solution: "ありません"
    },
    disabledDataStream: {
        name: "disabledDataStream",
        detail: "関連するPublicationがDisableなDataStreamには書き込みできません",
        solution: "関連するPublicationをEnableしてから書き込んでください"
    },
    publicationNotExist: {
        name: "publicationNotExist",
        detail: "channelに該当するPublicationが存在しません",
        solution: "publicationIdが正しいか確かめてください"
    },
    subscriptionNotExist: {
        name: "subscriptionNotExist",
        detail: "channelに該当するSubscriptionが存在しません",
        solution: "subscriptionIdが正しいか確かめてください"
    },
    unknownMemberType: {
        name: "unknownMemberType",
        detail: "対象のMemberのSubtypeのプラグインが登録されていません",
        solution: "対象のMemberのSubtypeのプラグイン(SfuBotなど)をSkyWayContextに登録してください"
    },
    streamNotExistInSubscription: {
        name: "streamNotExistInSubscription",
        detail: "SubscriptionにStreamがありません。RemoteMemberのSubscriptionのStreamにはアクセスできません",
        solution: "参照しているSubscriptionが目的のものか確かめてください。"
    },
    streamNotExistInPublication: {
        name: "streamNotExistInPublication",
        detail: "PublicationにStreamがありません。RemoteMemberのPublicationのStreamにはアクセスできません",
        solution: "参照しているPublicationが目的のものか確かめてください。"
    },
    dataStreamNotSupportEncoding: {
        name: "dataStreamNotSupportEncoding",
        detail: "dataStreamはEncode設定の変更に対応していません",
        solution: "ありません"
    },
    correspondingEncodeNotExistForId: {
        name: "correspondingEncodeNotExistForId",
        detail: "指定されたIDに対応するEncode設定が存在しません",
        solution: "正しいEncodingIDを指定してください"
    },
    updateIceParamsFailed: {
        name: "updateIceParamsFailed",
        detail: "iceParamsの更新に失敗しました",
        solution: "ありません"
    },
    invalidElement: {
        name: "invalidElement",
        detail: "渡されたHTML Elementが正しくありません",
        solution: "要求された正しいElementを渡してください"
    },
    connectRtcApiFailed: {
        name: "connectRtcApiFailed",
        detail: "RtcAPIへの接続に失敗しました",
        solution: "インターネットへの接続できているか、もしくはTokenのパラメータが正しいかを確かめてください"
    },
    rtcApiFatalError: {
        name: "rtcApiFatalError",
        detail: "RtcAPIの回復不能なエラーです。サーバー側の問題の可能性があります",
        solution: "インターネットへの接続が出来ているかを確かめてください"
    },
    invalidExpireTokenValue: {
        name: "invalidExpireTokenValue",
        detail: "tokenのExpire時刻が不正です",
        solution: "正しい時刻を指定してください"
    },
    invalidRemindExpireTokenValue: {
        name: "invalidRemindExpireTokenValue",
        detail: "tokenのExpireをリマインドする時間の値が不正です",
        solution: "正しい時間を指定してください"
    },
    invalidTokenAppId: {
        name: "invalidTokenAppId",
        detail: "tokenのappIdが正しくありません",
        solution: "正しいappIdを含むTokenを使用してください"
    },
    mediaDevicesNotFound: {
        name: "mediaDevicesNotFound",
        detail: "navigator.mediaDevicesがみつかりません",
        solution: "アプリケーションをhttps,localhost,127.0.0.1のいずれかの環境で動作させてください"
    },
    canNotUseReplaceStream: {
        name: "canNotUseReplaceStream",
        detail: "remoteのPublicationからreplaceStreamできません",
        solution: "対象のPublicationがLocalのものか確認してください"
    },
    canNotEnableRemotePublication: {
        name: "canNotEnableRemotePublication",
        detail: "remoteのPublicationをenableすることはできません",
        solution: "対象のPublicationがLocalのものか確認してください"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dbPdD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "LocalPersonImpl", ()=>LocalPersonImpl);
var _common = require("@skyway-sdk/common");
var _errors = require("../../errors");
var _member = require("../../member");
var _member1 = require("../../plugin/internal/unknown/member");
var _publication = require("../../publication");
var _util = require("../../util");
var _remoteMember = require("../remoteMember");
var _agent = require("./agent");
var _adapter = require("./adapter");
parcelHelpers.exportAll(_adapter, exports);
var _factory = require("./factory");
parcelHelpers.exportAll(_factory, exports);
const log = new (0, _common.Logger)("packages/core/src/member/localPerson/index.ts");
class LocalPersonImpl extends (0, _member.MemberImpl) {
    static async Create(...args) {
        const person = new LocalPersonImpl(...args);
        await person._setupTtlTimer();
        return person;
    }
    /**@private */ constructor(args){
        super(args);
        this.args = args;
        this.type = "person";
        this.subtype = "person";
        this.side = "local";
        this.keepaliveIntervalSec = this.args.keepaliveIntervalSec;
        this.keepaliveIntervalGapSec = this.args.keepaliveIntervalGapSec;
        this.disableSignaling = this.args.disableSignaling;
        this.disableAnalytics = this.args.disableAnalytics;
        this.config = this.context.config;
        this.onStreamPublished = this._events.make();
        this.onStreamUnpublished = this._events.make();
        this.onPublicationListChanged = this._events.make();
        this.onPublicationSubscribed = this._events.make();
        this.onPublicationUnsubscribed = this._events.make();
        this.onSubscriptionListChanged = this._events.make();
        this.onFatalError = this._events.make();
        this._onStreamSubscribeFailed = this._events.make();
        this._onDisposed = this._events.make();
        this._disposer = new (0, _common.EventDisposer)();
        this._subscribing = {};
        this._requestQueue = new (0, _common.PromiseQueue)();
        this.iceManager = this.args.iceManager;
        this./**@private */ _disposed = false;
        this._publishingAgent = new (0, _agent.PublishingAgent)(this);
        this._subscribingAgent = new (0, _agent.SubscribingAgent)(this);
        this._signaling = args.signaling;
        this._analytics = args.analytics;
        this._listenChannelEvent();
        this._listenBeforeUnload();
    }
    _listenChannelEvent() {
        this.channel.onPublicationSubscribed.add(async ({ subscription  })=>{
            await this._handleOnPublicationSubscribe(subscription).catch((e)=>log.error("_handleOnStreamSubscribe", e));
        }).disposer(this._disposer);
        this.channel.onPublicationUnsubscribed.add(async ({ subscription  })=>{
            await this._handleOnPublicationUnsubscribe(subscription).catch((e)=>log.error("_handleOnStreamUnsubscribe", e));
        }).disposer(this._disposer);
        this.channel._onDisposed.once(()=>{
            this.dispose();
        });
        this.onLeft.once(()=>{
            this.dispose();
        });
    }
    /**@throws {@SkyWayError} */ async _setupTtlTimer() {
        const { keepaliveIntervalSec , keepaliveIntervalGapSec  } = this;
        if (keepaliveIntervalSec == null) return;
        log.debug("_setupTtlTimer", this.toJSON(), {
            keepaliveIntervalSec,
            keepaliveIntervalGapSec
        });
        if (keepaliveIntervalSec === -1) return;
        const updateTtl = async ()=>{
            if (this._disposed) return;
            const now = await this.context._api.getServerUnixtimeInSec();
            this.ttlSec = Math.floor(now + keepaliveIntervalSec + (keepaliveIntervalGapSec ?? 0));
            try {
                await this.channel._updateMemberTtl(this.id, this.ttlSec);
                log.debug("updateTtl", this.toJSON(), {
                    now,
                    ttlSec: this.ttlSec,
                    keepaliveIntervalSec: keepaliveIntervalSec ?? 0,
                    keepaliveIntervalGapSec: keepaliveIntervalGapSec ?? 0,
                    diff: this.ttlSec - now
                });
            } catch (error) {
                if (this._disposed) return;
                throw error;
            }
        };
        await updateTtl();
        this.ttlInterval = setInterval(async ()=>{
            await updateTtl().catch((error)=>{
                if (!this._disposed) {
                    this.onFatalError.emit((0, _util.createError)({
                        operationName: "localPerson._setupTtlTimer",
                        path: log.prefix,
                        info: {
                            ...(0, _errors.errors).internal,
                            detail: "updateMemberTtl failed"
                        },
                        channel: this.channel,
                        context: this.context,
                        error
                    }));
                    this.dispose();
                }
            });
        }, keepaliveIntervalSec * 1000);
    }
    _listenBeforeUnload() {
        if (window) {
            const leave = async ()=>{
                window.removeEventListener("beforeunload", leave);
                if (this.state !== "joined") return;
                log.debug("leave by beforeunload", this.toJSON());
                await this.leave();
            };
            window.addEventListener("beforeunload", leave);
        }
    }
    /**@throws {@link SkyWayError} */ async _handleOnPublicationSubscribe(subscription) {
        if (subscription.subscriber.id === this.id) try {
            const timestamp = log.info("[start] startSubscribing", await (0, _util.createLogPayload)({
                operationName: "onPublicationSubscribed",
                channel: this.channel
            }), {
                subscription
            });
            const options = this._subscribing[subscription.publication.id]?.options;
            if (options) subscription.preferredEncoding = options.preferredEncodingId;
            await this._subscribingAgent.startSubscribing(subscription);
            this.onPublicationSubscribed.emit({
                subscription,
                stream: subscription.stream
            });
            this.onSubscriptionListChanged.emit();
            log.elapsed(timestamp, "[end] startSubscribing", await (0, _util.createLogPayload)({
                operationName: "onPublicationSubscribed",
                channel: this.channel
            }), {
                subscription
            });
        } catch (error) {
            this._onStreamSubscribeFailed.emit({
                error,
                subscription
            });
            throw error;
        }
        if (subscription.publication.publisher.id === this.id) {
            if (subscription.subscriber.id === this.id) throw (0, _util.createError)({
                operationName: "localPerson._handleOnStreamSubscribe",
                path: log.prefix,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "can not subscribe own Publication"
                },
                channel: this.channel,
                context: this.context
            });
            const timestamp = log.info("[start] startPublishing", await (0, _util.createLogPayload)({
                operationName: "onPublicationSubscribed",
                channel: this.channel
            }), {
                subscription
            });
            await this._publishingAgent.startPublishing(subscription).catch((e)=>{
                log.error("[failed] startPublishing", e, {
                    subscription
                });
                throw e;
            });
            log.elapsed(timestamp, "[end] startPublishing", await (0, _util.createLogPayload)({
                operationName: "onPublicationSubscribed",
                channel: this.channel
            }), {
                subscription
            });
        }
    }
    /**@throws {@link SkyWayError} */ async _handleOnPublicationUnsubscribe(subscription) {
        if (subscription.publication.publisher.id === this.id) {
            const timestamp = log.info("[start] stopPublishing", await (0, _util.createLogPayload)({
                operationName: "onPublicationUnsubscribed",
                channel: this.channel
            }), {
                subscription
            });
            await this._publishingAgent.stopPublishing(subscription.publication, subscription.subscriber).catch((e)=>{
                log.error("[failed] stopPublishing", e, {
                    subscription
                });
                throw e;
            });
            log.elapsed(timestamp, "[end] stopPublishing", await (0, _util.createLogPayload)({
                operationName: "onPublicationUnsubscribed",
                channel: this.channel
            }), {
                subscription
            });
        }
        if (subscription.subscriber.id === this.id) {
            const timestamp = log.info("[start] stopSubscribing", await (0, _util.createLogPayload)({
                operationName: "onPublicationUnsubscribed",
                channel: this.channel
            }), {
                subscription
            });
            await this._subscribingAgent.stopSubscribing(subscription).catch((e)=>{
                log.error("[failed] stopSubscribing", {
                    subscription
                }, e);
                throw e;
            });
            this.onPublicationUnsubscribed.emit({
                subscription
            });
            this.onSubscriptionListChanged.emit();
            log.elapsed(timestamp, "[end] stopSubscribing", await (0, _util.createLogPayload)({
                operationName: "onPublicationUnsubscribed",
                channel: this.channel
            }), {
                subscription
            });
        }
    }
    /**@throws {@link SkyWayError} */ async publish(stream, options = {}) {
        const timestamp = log.info("[start] publish", await (0, _util.createLogPayload)({
            operationName: "localPerson.publish",
            channel: this.channel
        }), {
            options
        });
        if (this.state !== "joined") throw (0, _util.createError)({
            operationName: "localPerson.publish",
            info: (0, _errors.errors).localPersonNotJoinedChannel,
            path: log.prefix,
            channel: this.channel,
            context: this.context
        });
        if (stream.published) throw (0, _util.createError)({
            operationName: "localPerson.publish",
            channel: this.channel,
            context: this.context,
            info: (0, _errors.errors).alreadyPublishedStream,
            path: log.prefix
        });
        stream.published = true;
        if (options.codecCapabilities) options.codecCapabilities = options.codecCapabilities.filter((c)=>c != undefined);
        const init = {
            metadata: options.metadata,
            publisher: this.id,
            channel: this.channel.id,
            contentType: stream.contentType,
            codecCapabilities: options.codecCapabilities ?? [],
            isEnabled: options.isEnabled
        };
        if (stream.contentType === "video" && init.codecCapabilities.length === 0) init.codecCapabilities = [
            {
                mimeType: "video/vp8"
            }
        ];
        if (options.encodings && options.encodings.length > 0) init.encodings = (0, _publication.normalizeEncodings)((0, _publication.sortEncodingParameters)(options.encodings));
        const published = await this._requestQueue.push(()=>this.channel._publish(init).catch((e)=>{
                throw (0, _util.createError)({
                    operationName: "localPerson.publish",
                    context: this.context,
                    channel: this.channel,
                    info: e.info,
                    path: log.prefix,
                    error: e
                });
            }));
        // publication作成時にpublication.state=isEnabledとなり、その後isEnabledに合わせてpublicationのenableStream/disableStreamを呼び出してもsetIsEnabled/setEnabledが実行されない。
        // そのままではpublication.stateとstreamで状態の乖離が発生する場合があるため、ここで直接実行し一致させておく。
        if (stream.contentType === "data") stream.setIsEnabled(published.isEnabled);
        else await stream.setEnabled(published.isEnabled);
        const publication = this.channel._addPublication(published);
        publication._setStream(stream);
        if (init.codecCapabilities?.length) publication.setCodecCapabilities(init.codecCapabilities);
        if (init.encodings?.length) publication.setEncodings(init.encodings);
        await this._handleOnStreamPublish(publication);
        log.elapsed(timestamp, "[end] publish", await (0, _util.createLogPayload)({
            operationName: "localPerson.publish",
            channel: this.channel
        }), {
            publication
        });
        // dataの場合はMediaDeviceがないので送信処理をしない
        if ([
            "video",
            "audio"
        ].includes(publication.contentType) && this._analytics && !this._analytics.isClosed()) {
            this._analytics.client.sendMediaDeviceReport({
                publicationId: publication.id,
                mediaDeviceName: publication.deviceName,
                mediaDeviceTrigger: "publish",
                updatedAt: Date.now()
            });
            const encodings = init.encodings ?? [];
            this._analytics.client.sendPublicationUpdateEncodingsReport({
                publicationId: publication.id,
                encodings: encodings,
                updatedAt: Date.now()
            });
        }
        return publication;
    }
    async _handleOnStreamPublish(publication) {
        log.info("onStreamPublished", await (0, _util.createLogPayload)({
            operationName: "onStreamPublished",
            channel: this.channel
        }));
        this.onStreamPublished.emit({
            publication
        });
        this.onPublicationListChanged.emit();
    }
    /**@throws {@link SkyWayError} */ async unpublish(target) {
        const timestamp = log.info("[start] unpublish", await (0, _util.createLogPayload)({
            operationName: "localPerson.unpublish",
            channel: this.channel
        }));
        const publicationId = typeof target === "string" ? target : target.id;
        if (this.state !== "joined") throw (0, _util.createError)({
            operationName: "localPerson.unpublish",
            info: (0, _errors.errors).localPersonNotJoinedChannel,
            path: log.prefix,
            context: this.context,
            channel: this.channel
        });
        const publication = this.channel._getPublication(publicationId);
        if (!publication) throw (0, _util.createError)({
            operationName: "localPerson.unpublish",
            info: (0, _errors.errors).publicationNotExist,
            path: log.prefix,
            context: this.context,
            channel: this.channel,
            payload: {
                publicationId
            }
        });
        if (publication.stream) publication.stream._unpublished();
        await this._requestQueue.push(()=>this.channel._unpublish(publicationId));
        publication.subscriptions.map((s)=>s.subscriber).forEach((s)=>{
            if ((0, _remoteMember.isRemoteMember)(s)) this._publishingAgent.stopPublishing(publication, s).catch((e)=>{
                log.error("[failed] stopPublishing", e, {
                    publication
                });
            });
        });
        await this._handleOnStreamUnpublished(publication);
        log.elapsed(timestamp, "[end] unpublish", await (0, _util.createLogPayload)({
            operationName: "localPerson.unpublish",
            channel: this.channel
        }), {
            publication
        });
    }
    async _handleOnStreamUnpublished(publication) {
        log.info("onStreamUnpublished", await (0, _util.createLogPayload)({
            operationName: "onStreamUnpublished",
            channel: this.channel
        }));
        this.onStreamUnpublished.emit({
            publication
        });
        this.onPublicationListChanged.emit();
    }
    /**@throws {@link SkyWayError} */ async subscribe(target, options = {}) {
        const timestamp = log.info("[start] subscribe", await (0, _util.createLogPayload)({
            operationName: "localPerson.subscribe",
            channel: this.channel
        }), {
            target
        });
        const publicationId = typeof target === "string" ? target : target.id;
        if (this.state !== "joined") throw (0, _util.createError)({
            operationName: "localPerson.subscribe",
            info: (0, _errors.errors).localPersonNotJoinedChannel,
            path: log.prefix,
            context: this.context,
            channel: this.channel,
            payload: {
                target
            }
        });
        const publication = this.channel._getPublication(publicationId);
        if (publication == undefined) throw (0, _util.createError)({
            operationName: "localPerson.subscribe",
            info: (0, _errors.errors).publicationNotExist,
            path: log.prefix,
            context: this.context,
            channel: this.channel,
            payload: publication
        });
        this._validatePublicationForSubscribe(publication);
        this._subscribing[publication.id] = {
            options,
            processing: true
        };
        const subscribing = this._subscribing[publication.id];
        try {
            const subscriptionDto = await this._requestQueue.push(()=>this.channel._subscribe(this.id, publicationId));
            log.elapsed(timestamp, "[elapsed] subscribe / subscriptionDto received", {
                subscriptionDto
            });
            const subscription = this.channel._addSubscription(subscriptionDto);
            if (!subscription.stream) await Promise.race([
                new Promise((r, f)=>{
                    this.onPublicationSubscribed.watch(({ subscription  })=>subscription.publication.id === publicationId, this.context.config.rtcApi.timeout).then(r).catch(async (e)=>{
                        if (subscribing.processing) f((0, _util.createError)({
                            operationName: "localPerson.subscribe",
                            info: {
                                ...(0, _errors.errors).timeout,
                                detail: "failed to subscribe publication. maybe publisher already left room"
                            },
                            path: log.prefix,
                            context: this.context,
                            channel: this.channel,
                            payload: {
                                subscription,
                                publication
                            },
                            error: e
                        }));
                    });
                }),
                new Promise((r, f)=>{
                    this.channel.onMemberLeft.watch((e)=>e.member.id === publication.publisher.id, this.context.config.rtcApi.timeout + 1000).then(()=>{
                        if (subscribing.processing) f((0, _util.createError)({
                            operationName: "localPerson.subscribe",
                            info: {
                                ...(0, _errors.errors).internal,
                                detail: "failed to subscribe publication. publisher already left room"
                            },
                            path: log.prefix,
                            context: this.context,
                            channel: this.channel,
                            payload: {
                                subscription,
                                publication
                            }
                        }));
                    }).catch(r);
                }),
                new Promise((r, f)=>{
                    this._onStreamSubscribeFailed.watch((e)=>e.subscription.publication.id === publication.id, this.context.config.rtcApi.timeout + 1000).then((e)=>{
                        if (subscribing.processing) {
                            const info = e?.error?.info ?? {
                                ...(0, _errors.errors).internal,
                                detail: "subscribe _onStreamSubscribeFailed"
                            };
                            f((0, _util.createError)({
                                operationName: "localPerson.subscribe",
                                info,
                                path: log.prefix,
                                context: this.context,
                                channel: this.channel,
                                error: e.error,
                                payload: {
                                    subscription,
                                    publication
                                }
                            }));
                        }
                    }).catch(r);
                })
            ]);
            subscribing.processing = false;
            log.elapsed(timestamp, "[end] subscribe", await (0, _util.createLogPayload)({
                operationName: "localPerson.subscribe",
                channel: this.channel
            }), {
                subscription,
                publication
            });
            return {
                subscription: subscription,
                stream: subscription.stream
            };
        } catch (error) {
            subscribing.processing = false;
            // 対象のPublicationがすでにUnPublishされている時に失敗しうる
            log.warn("[failed] subscribe", error, {
                publication
            });
            throw error;
        }
    }
    /**@throws {@link SkyWayError} */ _validatePublicationForSubscribe(publication) {
        if (publication.publisher.id === this.id) throw (0, _util.createError)({
            operationName: "localPerson._validatePublicationForSubscribe",
            info: (0, _errors.errors).publicationNotExist,
            path: log.prefix,
            context: this.context,
            channel: this.channel,
            payload: {
                publication
            }
        });
        if (publication.publisher instanceof (0, _member1.UnknownMemberImpl)) throw (0, _util.createError)({
            operationName: "localPerson._validatePublicationForSubscribe",
            info: (0, _errors.errors).unknownMemberType,
            path: log.prefix,
            context: this.context,
            channel: this.channel,
            payload: {
                publication
            }
        });
        if (this.subscriptions.find((s)=>s.publication.id === publication.id)) throw (0, _util.createError)({
            operationName: "localPerson._validatePublicationForSubscribe",
            info: (0, _errors.errors).alreadySubscribedPublication,
            path: log.prefix,
            context: this.context,
            channel: this.channel,
            payload: {
                publication
            }
        });
    }
    /**@throws {@link SkyWayError} */ async unsubscribe(target) {
        const timestamp = log.info("[start] unsubscribe", await (0, _util.createLogPayload)({
            operationName: "localPerson.unsubscribe",
            channel: this.channel
        }));
        const subscriptionId = typeof target === "string" ? target : target.id;
        if (this.state !== "joined") throw (0, _util.createError)({
            operationName: "localPerson.unsubscribe",
            info: (0, _errors.errors).localPersonNotJoinedChannel,
            path: log.prefix,
            context: this.context,
            channel: this.channel
        });
        const subscription = this.subscriptions.find((s)=>s.id === subscriptionId);
        if (!subscription) throw (0, _util.createError)({
            operationName: "localPerson.unsubscribe",
            info: (0, _errors.errors).subscriptionNotExist,
            path: log.prefix,
            context: this.context,
            channel: this.channel,
            payload: {
                subscriptionId
            }
        });
        delete this._subscribing[subscription.publication.id];
        await this._requestQueue.push(()=>this.channel._unsubscribe(subscriptionId));
        log.elapsed(timestamp, "[end] unsubscribe", await (0, _util.createLogPayload)({
            operationName: "localPerson.unsubscribe",
            channel: this.channel
        }), {
            subscription
        });
    }
    _getConnections() {
        const connections = this.channel.members.map((m)=>m._getConnection(this.id));
        const active = connections.filter((c)=>c?.closed === false);
        return active;
    }
    /**
   * リソース解放
   * - メッセージサービスとのセッション
   * - メディア通信
   * - イベントリスナー
   * - TTL更新
   */ dispose() {
        if (this._disposed) return;
        this._disposed = true;
        log.debug("disposed", this.toJSON());
        clearInterval(this.ttlInterval);
        if (this._signaling) this._signaling.close();
        if (this._analytics) this._analytics.close();
        this._getConnections().forEach((c)=>c.close({
                reason: "localPerson disposed"
            }));
        this._onDisposed.emit();
        this._events.dispose();
        this._disposer.dispose();
    }
}

},{"@skyway-sdk/common":"3hyrG","../../errors":"gDbIj","../../member":"dkuHe","../../plugin/internal/unknown/member":"4dKvO","../../publication":"3aobm","../../util":"ey5Lv","../remoteMember":"hAw7O","./agent":"ifPzB","./adapter":"9IpNZ","./factory":"4jCnb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dkuHe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "MemberImpl", ()=>MemberImpl);
var _common = require("@skyway-sdk/common");
var _errors = require("../errors");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/core/src/member/index.ts");
class MemberImpl {
    _state = "joined";
    /**@internal */ _events = new (0, _common.Events)();
    onLeft = this._events.make();
    onMetadataUpdated = this._events.make();
    constructor(args){
        this.channel = args.channel;
        this.id = args.id;
        this.name = args.name;
        this._metadata = args.metadata;
        this.context = args.context;
    }
    get metadata() {
        return this._metadata;
    }
    get state() {
        return this._state;
    }
    get publications() {
        return this.channel.publications.filter((p)=>p.publisher.id === this.id);
    }
    get subscriptions() {
        return this.channel.subscriptions.filter((p)=>p.subscriber.id === this.id);
    }
    /**@internal */ toJSON() {
        return {
            id: this.id,
            name: this.name,
            type: this.type,
            subtype: this.subtype,
            metadata: this.metadata
        };
    }
    /** @private*/ _left() {
        this._state = "left";
        this.onLeft.emit();
        this._events.dispose();
    }
    /** @private*/ _metadataUpdated(metadata) {
        this._metadata = metadata;
        this.onMetadataUpdated.emit(metadata);
    }
    async updateMetadata(metadata) {
        await this.channel._updateMemberMetadata(this.id, metadata);
    }
    /**@throws {@link SkyWayError} */ async leave() {
        const timestamp = log.info("[start] leave", await (0, _util.createLogPayload)({
            operationName: "localPerson.leave",
            channel: this.channel
        }));
        if (this.state === "left") throw (0, _util.createError)({
            operationName: "localPerson.leave",
            info: (0, _errors.errors).localPersonNotJoinedChannel,
            path: log.prefix,
            context: this.context,
            channel: this.channel
        });
        await this.channel.leave(this);
        log.elapsed(timestamp, "[end] leave");
    }
}

},{"@skyway-sdk/common":"3hyrG","../errors":"gDbIj","../util":"ey5Lv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ey5Lv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "getBitrateFromPeerConnection", ()=>getBitrateFromPeerConnection);
/**@internal */ parcelHelpers.export(exports, "statsToArray", ()=>statsToArray);
/**@internal */ parcelHelpers.export(exports, "createLogPayload", ()=>createLogPayload);
/**@internal */ parcelHelpers.export(exports, "createWarnPayload", ()=>createWarnPayload);
/**@internal */ parcelHelpers.export(exports, "createError", ()=>createError);
parcelHelpers.export(exports, "waitForLocalStats", ()=>waitForLocalStats);
/**@internal */ parcelHelpers.export(exports, "getRtcRtpCapabilities", ()=>getRtcRtpCapabilities);
parcelHelpers.export(exports, "getParameters", ()=>getParameters);
parcelHelpers.export(exports, "fmtpConfigParser", ()=>fmtpConfigParser);
/**@internal */ parcelHelpers.export(exports, "createTestVideoTrack", ()=>createTestVideoTrack);
parcelHelpers.export(exports, "getRuntimeInfo", ()=>getRuntimeInfo);
/**
 * @internal
 * @description from mediasoup-client
 */ parcelHelpers.export(exports, "detectDevice", ()=>detectDevice);
var _common = require("@skyway-sdk/common");
var _bowser = require("bowser");
var _bowserDefault = parcelHelpers.interopDefault(_bowser);
var _sdpTransform = require("sdp-transform");
var _sdpTransformDefault = parcelHelpers.interopDefault(_sdpTransform);
var _uaParserJs = require("ua-parser-js");
var _errors = require("./errors");
const log = new (0, _common.Logger)("packages/core/src/util.ts");
function getBitrateFromPeerConnection(stream, direction, cb, selector) {
    let preBytes = 0;
    const id = setInterval(async ()=>{
        const stats = await stream.getStats(selector);
        const stat = stats.find((v)=>{
            if (direction === "inbound") return v?.id.includes("InboundRTPVideo") || v?.type.includes("inbound-rtp");
            return v?.id.includes("OutboundRTPVideo") || v?.type.includes("outbound-rtp");
        });
        if (!stat) return;
        const totalBytes = direction === "inbound" ? stat.bytesReceived : stat.bytesSent;
        const bitrate = (totalBytes - preBytes) * 8;
        cb(bitrate);
        preBytes = totalBytes;
    }, 1000);
    return ()=>clearInterval(id);
}
function statsToArray(stats) {
    const arr = [];
    stats.forEach((stat)=>{
        arr.push(stat);
    });
    return arr;
}
async function createLogPayload({ operationName , channel  }) {
    const payload = {
        operationName,
        appId: channel.appId,
        channelId: channel.id
    };
    if (channel.localPerson) {
        const member = channel.localPerson;
        const publishing = await Promise.all(member.publications.map(async (p)=>{
            const publication = {
                id: p.id,
                contentType: p.contentType,
                state: p.state,
                stats: {},
                connectionStats: {}
            };
            if (p.stream) for (const { memberId , stats  } of (await p.stream._getStatsAll())){
                const localCandidate = stats.find((s)=>s.type.includes("local-candidate"));
                publication.stats[memberId] = {
                    transportType: localCandidate?.protocol ?? "none",
                    relayProtocol: localCandidate?.relayProtocol ?? "none",
                    callType: p.subscriptions.find((s)=>s.subscriber.id === memberId)?.subscriber.subtype,
                    outbound: stats.find((s)=>s.type.includes("outbound-rtp")),
                    localCandidate
                };
            }
            if (p.stream) for (const { memberId , connectionState  } of p.stream._getConnectionStateAll())publication.connectionStats[memberId] = connectionState;
            return publication;
        }));
        payload["publishing"] = publishing;
        const subscribing = await Promise.all(member.subscriptions.map(async (s)=>{
            const subscription = {
                id: s.id,
                contentType: s.contentType,
                stats: {}
            };
            subscription["callType"] = s.publication.publisher.subtype;
            if (s.stream) {
                const stats = await s.stream.getStats();
                subscription.stats = stats.find((s)=>s.type.includes("inbound-rtp"));
                const iceCandidate = stats.find((s)=>s.type.includes("local-candidate"));
                subscription["transportType"] = iceCandidate?.protocol;
                subscription["relayProtocol"] = iceCandidate?.relayProtocol;
            }
            if (s.stream) subscription["connectionState"] = s.stream.getConnectionState();
            return subscription;
        }));
        payload["subscribing"] = subscribing;
    }
    return payload;
}
function createWarnPayload({ member , detail , channel , operationName , payload  }) {
    const warn = {
        operationName,
        payload,
        detail
    };
    if (member) {
        warn["appId"] = member.channel.appId;
        warn["channelId"] = member.channel.id;
        warn["memberId"] = member.id;
    }
    if (channel) {
        warn["appId"] = channel.appId;
        warn["channelId"] = channel.id;
    }
    return warn;
}
function createError({ operationName , context , info , error , path , payload , channel  }) {
    const errPayload = {
        operationName,
        payload
    };
    if (channel) {
        errPayload["appId"] = channel.appId;
        errPayload["channelId"] = channel.id;
        if (channel.localPerson) errPayload["memberId"] = channel.localPerson.id;
    }
    if (context) {
        errPayload["info"] = context.info;
        errPayload["plugins"] = context.plugins.map((p)=>p.subtype);
    }
    return new (0, _common.SkyWayError)({
        error,
        info,
        payload: errPayload,
        path
    });
}
const waitForLocalStats = async ({ stream , remoteMember , end , interval , timeout  })=>new Promise(async (r, f)=>{
        interval ??= 100;
        timeout ??= 10000;
        for(let elapsed = 0;; elapsed += interval){
            if (elapsed >= timeout) {
                f(createError({
                    operationName: "Peer.waitForStats",
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "waitForStats timeout"
                    },
                    path: log.prefix
                }));
                break;
            }
            const stats = await stream._getStats(remoteMember);
            if (end(stats)) {
                r(stats);
                break;
            }
            await new Promise((r)=>setTimeout(r, interval));
        }
    });
async function getRtcRtpCapabilities() {
    const pc = new RTCPeerConnection();
    pc.addTransceiver("audio");
    pc.addTransceiver("video");
    const offer = await pc.createOffer();
    try {
        pc.close();
    } catch (error) {}
    const sdpObject = (0, _sdpTransformDefault.default).parse(offer.sdp);
    const [audio, video] = sdpObject.media;
    return {
        audio: audio.rtp.map((r)=>({
                ...r,
                payload: r.payload,
                mimeType: "audio/" + r.codec,
                parameters: getParameters(audio.fmtp, r.payload)
            })),
        video: video.rtp.filter((r)=>![
                "red",
                "rtx",
                "ulpfec"
            ].includes(r.codec)).map((r)=>({
                ...r,
                payload: r.payload,
                mimeType: "video/" + r.codec,
                parameters: getParameters(video.fmtp, r.payload)
            }))
    };
}
const getParameters = (fmtp, payload)=>fmtpConfigParser(fmtp.find((f)=>f.payload === payload)?.config ?? "");
const fmtpConfigParser = (config)=>{
    const parameters = config.split(";").reduce((acc, cur)=>{
        const [k, v] = cur.split("=");
        if (k) {
            acc[k] = Number(v);
            if (k === "profile-level-id") acc[k] = v;
        }
        return acc;
    }, {});
    return parameters;
};
function createTestVideoTrack(width, height) {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    const drawAnimation = ()=>{
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "rgb(200, 200, 200)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const date = new Date();
        ctx.font = "45px Monaco,Consolas";
        ctx.textAlign = "center";
        ctx.fillStyle = "red";
        const hours = ("0" + date.getHours()).slice(-2);
        const minutes = ("0" + date.getMinutes()).slice(-2);
        const seconds = ("0" + date.getSeconds()).slice(-2);
        const milliseconds = ("00" + date.getMilliseconds()).slice(-3);
        ctx.fillText(`${hours}:${minutes}:${seconds}.${milliseconds}`, canvas.width / 2, canvas.height / 2);
        requestAnimationFrame(drawAnimation);
    };
    setTimeout(()=>drawAnimation(), 0);
    const [track] = canvas.captureStream().getVideoTracks();
    return track;
}
const getRuntimeInfo = ({ isNotBrowser  } = {})=>{
    if (isNotBrowser) return isNotBrowser;
    const browser = (0, _bowserDefault.default).getParser(window.navigator.userAgent);
    const osName = browser.getOSName();
    const osVersion = browser.getOSVersion();
    const browserName = browser.getBrowserName();
    const browserVersion = browser.getBrowserVersion();
    return {
        browserName,
        browserVersion,
        osName,
        osVersion
    };
};
function detectDevice() {
    // React-Native.
    // NOTE: react-native-webrtc >= 1.75.0 is required.
    // NOTE: react-native-webrtc with Unified Plan requires version >= 106.0.0.
    if (typeof navigator === "object" && navigator.product === "ReactNative") {
        if (typeof RTCPeerConnection === "undefined") return undefined;
        if (typeof RTCRtpTransceiver !== "undefined") return "ReactNativeUnifiedPlan";
        else return "ReactNative";
    } else if (typeof navigator === "object" && typeof navigator.userAgent === "string") {
        const ua = navigator.userAgent;
        const uaParser = new (0, _uaParserJs.UAParser)(ua);
        const browser = uaParser.getBrowser();
        const browserName = browser.name?.toLowerCase() ?? "";
        const browserVersion = parseInt(browser.major ?? "0");
        const engine = uaParser.getEngine();
        const engineName = engine.name?.toLowerCase() ?? "";
        const os = uaParser.getOS();
        const osName = os.name?.toLowerCase() ?? "";
        const osVersion = parseFloat(os.version ?? "0");
        const isIOS = osName === "ios";
        const isChrome = [
            "chrome",
            "chromium",
            "mobile chrome",
            "chrome webview",
            "chrome headless"
        ].includes(browserName);
        const isFirefox = [
            "firefox",
            "mobile firefox",
            "mobile focus"
        ].includes(browserName);
        const isSafari = [
            "safari",
            "mobile safari"
        ].includes(browserName);
        const isEdge = [
            "edge"
        ].includes(browserName);
        // Chrome, Chromium, and Edge.
        if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) return "Chrome111";
        else if (isChrome && !isIOS && browserVersion >= 74 || isEdge && !isIOS && browserVersion >= 88) return "Chrome74";
        else if (isChrome && !isIOS && browserVersion >= 70) return "Chrome70";
        else if (isChrome && !isIOS && browserVersion >= 67) return "Chrome67";
        else if (isChrome && !isIOS && browserVersion >= 55) return "Chrome55";
        else if (isFirefox && !isIOS && browserVersion >= 60) return "Firefox60";
        else if (isFirefox && isIOS && osVersion >= 14.3) return "Safari12";
        else if (isSafari && browserVersion >= 12 && typeof RTCRtpTransceiver !== "undefined" && // eslint-disable-next-line no-prototype-builtins
        RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) return "Safari12";
        else if (isSafari && browserVersion >= 11) return "Safari11";
        else if (isEdge && !isIOS && browserVersion >= 11 && browserVersion <= 18) return "Edge11";
        else if (engineName === "webkit" && isIOS && osVersion >= 14.3 && typeof RTCRtpTransceiver !== "undefined" && // eslint-disable-next-line no-prototype-builtins
        RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) return "Safari12";
        else if (engineName === "blink") {
            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
                const version = Number(match[1]);
                if (version >= 111) return "Chrome111";
                else if (version >= 74) return "Chrome74";
                else if (version >= 70) return "Chrome70";
                else if (version >= 67) return "Chrome67";
                else return "Chrome55";
            } else return "Chrome111";
        } else return undefined;
    } else return undefined;
}

},{"@skyway-sdk/common":"3hyrG","bowser":"5jYCf","sdp-transform":"8vPQN","ua-parser-js":"llbZF","./errors":"gDbIj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5jYCf":[function(require,module,exports) {
!function(e, t) {
    module.exports = t();
}(this, function() {
    return function(e) {
        var t = {};
        function r(n) {
            if (t[n]) return t[n].exports;
            var i = t[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;
        }
        return r.m = e, r.c = t, r.d = function(e, t, n) {
            r.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: n
            });
        }, r.r = function(e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            });
        }, r.t = function(e, t) {
            if (1 & t && (e = r(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var n = Object.create(null);
            if (r.r(n), Object.defineProperty(n, "default", {
                enumerable: !0,
                value: e
            }), 2 & t && "string" != typeof e) for(var i in e)r.d(n, i, (function(t) {
                return e[t];
            }).bind(null, i));
            return n;
        }, r.n = function(e) {
            var t = e && e.__esModule ? function() {
                return e.default;
            } : function() {
                return e;
            };
            return r.d(t, "a", t), t;
        }, r.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
        }, r.p = "", r(r.s = 90);
    }({
        17: function(e, t, r) {
            "use strict";
            t.__esModule = !0, t.default = void 0;
            var n = r(18), i = function() {
                function e() {}
                return e.getFirstMatch = function(e, t) {
                    var r = t.match(e);
                    return r && r.length > 0 && r[1] || "";
                }, e.getSecondMatch = function(e, t) {
                    var r = t.match(e);
                    return r && r.length > 1 && r[2] || "";
                }, e.matchAndReturnConst = function(e, t, r) {
                    if (e.test(t)) return r;
                }, e.getWindowsVersionName = function(e) {
                    switch(e){
                        case "NT":
                            return "NT";
                        case "XP":
                            return "XP";
                        case "NT 5.0":
                            return "2000";
                        case "NT 5.1":
                            return "XP";
                        case "NT 5.2":
                            return "2003";
                        case "NT 6.0":
                            return "Vista";
                        case "NT 6.1":
                            return "7";
                        case "NT 6.2":
                            return "8";
                        case "NT 6.3":
                            return "8.1";
                        case "NT 10.0":
                            return "10";
                        default:
                            return;
                    }
                }, e.getMacOSVersionName = function(e) {
                    var t = e.split(".").splice(0, 2).map(function(e) {
                        return parseInt(e, 10) || 0;
                    });
                    if (t.push(0), 10 === t[0]) switch(t[1]){
                        case 5:
                            return "Leopard";
                        case 6:
                            return "Snow Leopard";
                        case 7:
                            return "Lion";
                        case 8:
                            return "Mountain Lion";
                        case 9:
                            return "Mavericks";
                        case 10:
                            return "Yosemite";
                        case 11:
                            return "El Capitan";
                        case 12:
                            return "Sierra";
                        case 13:
                            return "High Sierra";
                        case 14:
                            return "Mojave";
                        case 15:
                            return "Catalina";
                        default:
                            return;
                    }
                }, e.getAndroidVersionName = function(e) {
                    var t = e.split(".").splice(0, 2).map(function(e) {
                        return parseInt(e, 10) || 0;
                    });
                    if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0;
                }, e.getVersionPrecision = function(e) {
                    return e.split(".").length;
                }, e.compareVersions = function(t, r, n) {
                    void 0 === n && (n = !1);
                    var i = e.getVersionPrecision(t), s = e.getVersionPrecision(r), a = Math.max(i, s), o = 0, u = e.map([
                        t,
                        r
                    ], function(t) {
                        var r = a - e.getVersionPrecision(t), n = t + new Array(r + 1).join(".0");
                        return e.map(n.split("."), function(e) {
                            return new Array(20 - e.length).join("0") + e;
                        }).reverse();
                    });
                    for(n && (o = a - Math.min(i, s)), a -= 1; a >= o;){
                        if (u[0][a] > u[1][a]) return 1;
                        if (u[0][a] === u[1][a]) {
                            if (a === o) return 0;
                            a -= 1;
                        } else if (u[0][a] < u[1][a]) return -1;
                    }
                }, e.map = function(e, t) {
                    var r, n = [];
                    if (Array.prototype.map) return Array.prototype.map.call(e, t);
                    for(r = 0; r < e.length; r += 1)n.push(t(e[r]));
                    return n;
                }, e.find = function(e, t) {
                    var r, n;
                    if (Array.prototype.find) return Array.prototype.find.call(e, t);
                    for(r = 0, n = e.length; r < n; r += 1){
                        var i = e[r];
                        if (t(i, r)) return i;
                    }
                }, e.assign = function(e) {
                    for(var t, r, n = e, i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)s[a - 1] = arguments[a];
                    if (Object.assign) return Object.assign.apply(Object, [
                        e
                    ].concat(s));
                    var o = function() {
                        var e = s[t];
                        "object" == typeof e && null !== e && Object.keys(e).forEach(function(t) {
                            n[t] = e[t];
                        });
                    };
                    for(t = 0, r = s.length; t < r; t += 1)o();
                    return e;
                }, e.getBrowserAlias = function(e) {
                    return n.BROWSER_ALIASES_MAP[e];
                }, e.getBrowserTypeByAlias = function(e) {
                    return n.BROWSER_MAP[e] || "";
                }, e;
            }();
            t.default = i, e.exports = t.default;
        },
        18: function(e, t, r) {
            "use strict";
            t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0;
            t.BROWSER_ALIASES_MAP = {
                "Amazon Silk": "amazon_silk",
                "Android Browser": "android",
                Bada: "bada",
                BlackBerry: "blackberry",
                Chrome: "chrome",
                Chromium: "chromium",
                Electron: "electron",
                Epiphany: "epiphany",
                Firefox: "firefox",
                Focus: "focus",
                Generic: "generic",
                "Google Search": "google_search",
                Googlebot: "googlebot",
                "Internet Explorer": "ie",
                "K-Meleon": "k_meleon",
                Maxthon: "maxthon",
                "Microsoft Edge": "edge",
                "MZ Browser": "mz",
                "NAVER Whale Browser": "naver",
                Opera: "opera",
                "Opera Coast": "opera_coast",
                PhantomJS: "phantomjs",
                Puffin: "puffin",
                QupZilla: "qupzilla",
                QQ: "qq",
                QQLite: "qqlite",
                Safari: "safari",
                Sailfish: "sailfish",
                "Samsung Internet for Android": "samsung_internet",
                SeaMonkey: "seamonkey",
                Sleipnir: "sleipnir",
                Swing: "swing",
                Tizen: "tizen",
                "UC Browser": "uc",
                Vivaldi: "vivaldi",
                "WebOS Browser": "webos",
                WeChat: "wechat",
                "Yandex Browser": "yandex",
                Roku: "roku"
            };
            t.BROWSER_MAP = {
                amazon_silk: "Amazon Silk",
                android: "Android Browser",
                bada: "Bada",
                blackberry: "BlackBerry",
                chrome: "Chrome",
                chromium: "Chromium",
                electron: "Electron",
                epiphany: "Epiphany",
                firefox: "Firefox",
                focus: "Focus",
                generic: "Generic",
                googlebot: "Googlebot",
                google_search: "Google Search",
                ie: "Internet Explorer",
                k_meleon: "K-Meleon",
                maxthon: "Maxthon",
                edge: "Microsoft Edge",
                mz: "MZ Browser",
                naver: "NAVER Whale Browser",
                opera: "Opera",
                opera_coast: "Opera Coast",
                phantomjs: "PhantomJS",
                puffin: "Puffin",
                qupzilla: "QupZilla",
                qq: "QQ Browser",
                qqlite: "QQ Browser Lite",
                safari: "Safari",
                sailfish: "Sailfish",
                samsung_internet: "Samsung Internet for Android",
                seamonkey: "SeaMonkey",
                sleipnir: "Sleipnir",
                swing: "Swing",
                tizen: "Tizen",
                uc: "UC Browser",
                vivaldi: "Vivaldi",
                webos: "WebOS Browser",
                wechat: "WeChat",
                yandex: "Yandex Browser"
            };
            t.PLATFORMS_MAP = {
                tablet: "tablet",
                mobile: "mobile",
                desktop: "desktop",
                tv: "tv"
            };
            t.OS_MAP = {
                WindowsPhone: "Windows Phone",
                Windows: "Windows",
                MacOS: "macOS",
                iOS: "iOS",
                Android: "Android",
                WebOS: "WebOS",
                BlackBerry: "BlackBerry",
                Bada: "Bada",
                Tizen: "Tizen",
                Linux: "Linux",
                ChromeOS: "Chrome OS",
                PlayStation4: "PlayStation 4",
                Roku: "Roku"
            };
            t.ENGINE_MAP = {
                EdgeHTML: "EdgeHTML",
                Blink: "Blink",
                Trident: "Trident",
                Presto: "Presto",
                Gecko: "Gecko",
                WebKit: "WebKit"
            };
        },
        90: function(e, t, r) {
            "use strict";
            t.__esModule = !0, t.default = void 0;
            var n, i = (n = r(91)) && n.__esModule ? n : {
                default: n
            }, s = r(18);
            function a(e, t) {
                for(var r = 0; r < t.length; r++){
                    var n = t[r];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
                }
            }
            var o = function() {
                function e() {}
                var t, r, n;
                return e.getParser = function(e, t) {
                    if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
                    return new i.default(e, t);
                }, e.parse = function(e) {
                    return new i.default(e).getResult();
                }, t = e, n = [
                    {
                        key: "BROWSER_MAP",
                        get: function() {
                            return s.BROWSER_MAP;
                        }
                    },
                    {
                        key: "ENGINE_MAP",
                        get: function() {
                            return s.ENGINE_MAP;
                        }
                    },
                    {
                        key: "OS_MAP",
                        get: function() {
                            return s.OS_MAP;
                        }
                    },
                    {
                        key: "PLATFORMS_MAP",
                        get: function() {
                            return s.PLATFORMS_MAP;
                        }
                    }
                ], r = null, n && a(t, n), e;
            }();
            t.default = o, e.exports = t.default;
        },
        91: function(e, t, r) {
            "use strict";
            t.__esModule = !0, t.default = void 0;
            var n = u(r(92)), i = u(r(93)), s = u(r(94)), a = u(r(95)), o = u(r(17));
            function u(e) {
                return e && e.__esModule ? e : {
                    default: e
                };
            }
            var d = function() {
                function e(e, t) {
                    if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
                    this._ua = e, this.parsedResult = {}, !0 !== t && this.parse();
                }
                var t = e.prototype;
                return t.getUA = function() {
                    return this._ua;
                }, t.test = function(e) {
                    return e.test(this._ua);
                }, t.parseBrowser = function() {
                    var e = this;
                    this.parsedResult.browser = {};
                    var t = o.default.find(n.default, function(t) {
                        if ("function" == typeof t.test) return t.test(e);
                        if (t.test instanceof Array) return t.test.some(function(t) {
                            return e.test(t);
                        });
                        throw new Error("Browser's test function is not valid");
                    });
                    return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
                }, t.getBrowser = function() {
                    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
                }, t.getBrowserName = function(e) {
                    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
                }, t.getBrowserVersion = function() {
                    return this.getBrowser().version;
                }, t.getOS = function() {
                    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
                }, t.parseOS = function() {
                    var e = this;
                    this.parsedResult.os = {};
                    var t = o.default.find(i.default, function(t) {
                        if ("function" == typeof t.test) return t.test(e);
                        if (t.test instanceof Array) return t.test.some(function(t) {
                            return e.test(t);
                        });
                        throw new Error("Browser's test function is not valid");
                    });
                    return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
                }, t.getOSName = function(e) {
                    var t = this.getOS().name;
                    return e ? String(t).toLowerCase() || "" : t || "";
                }, t.getOSVersion = function() {
                    return this.getOS().version;
                }, t.getPlatform = function() {
                    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
                }, t.getPlatformType = function(e) {
                    void 0 === e && (e = !1);
                    var t = this.getPlatform().type;
                    return e ? String(t).toLowerCase() || "" : t || "";
                }, t.parsePlatform = function() {
                    var e = this;
                    this.parsedResult.platform = {};
                    var t = o.default.find(s.default, function(t) {
                        if ("function" == typeof t.test) return t.test(e);
                        if (t.test instanceof Array) return t.test.some(function(t) {
                            return e.test(t);
                        });
                        throw new Error("Browser's test function is not valid");
                    });
                    return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
                }, t.getEngine = function() {
                    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
                }, t.getEngineName = function(e) {
                    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
                }, t.parseEngine = function() {
                    var e = this;
                    this.parsedResult.engine = {};
                    var t = o.default.find(a.default, function(t) {
                        if ("function" == typeof t.test) return t.test(e);
                        if (t.test instanceof Array) return t.test.some(function(t) {
                            return e.test(t);
                        });
                        throw new Error("Browser's test function is not valid");
                    });
                    return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
                }, t.parse = function() {
                    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
                }, t.getResult = function() {
                    return o.default.assign({}, this.parsedResult);
                }, t.satisfies = function(e) {
                    var t = this, r = {}, n = 0, i = {}, s = 0;
                    if (Object.keys(e).forEach(function(t) {
                        var a = e[t];
                        "string" == typeof a ? (i[t] = a, s += 1) : "object" == typeof a && (r[t] = a, n += 1);
                    }), n > 0) {
                        var a = Object.keys(r), u = o.default.find(a, function(e) {
                            return t.isOS(e);
                        });
                        if (u) {
                            var d = this.satisfies(r[u]);
                            if (void 0 !== d) return d;
                        }
                        var c = o.default.find(a, function(e) {
                            return t.isPlatform(e);
                        });
                        if (c) {
                            var f = this.satisfies(r[c]);
                            if (void 0 !== f) return f;
                        }
                    }
                    if (s > 0) {
                        var l = Object.keys(i), h = o.default.find(l, function(e) {
                            return t.isBrowser(e, !0);
                        });
                        if (void 0 !== h) return this.compareVersion(i[h]);
                    }
                }, t.isBrowser = function(e, t) {
                    void 0 === t && (t = !1);
                    var r = this.getBrowserName().toLowerCase(), n = e.toLowerCase(), i = o.default.getBrowserTypeByAlias(n);
                    return t && i && (n = i.toLowerCase()), n === r;
                }, t.compareVersion = function(e) {
                    var t = [
                        0
                    ], r = e, n = !1, i = this.getBrowserVersion();
                    if ("string" == typeof i) return ">" === e[0] || "<" === e[0] ? (r = e.substr(1), "=" === e[1] ? (n = !0, r = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? r = e.substr(1) : "~" === e[0] && (n = !0, r = e.substr(1)), t.indexOf(o.default.compareVersions(i, r, n)) > -1;
                }, t.isOS = function(e) {
                    return this.getOSName(!0) === String(e).toLowerCase();
                }, t.isPlatform = function(e) {
                    return this.getPlatformType(!0) === String(e).toLowerCase();
                }, t.isEngine = function(e) {
                    return this.getEngineName(!0) === String(e).toLowerCase();
                }, t.is = function(e, t) {
                    return void 0 === t && (t = !1), this.isBrowser(e, t) || this.isOS(e) || this.isPlatform(e);
                }, t.some = function(e) {
                    var t = this;
                    return void 0 === e && (e = []), e.some(function(e) {
                        return t.is(e);
                    });
                }, e;
            }();
            t.default = d, e.exports = t.default;
        },
        92: function(e, t, r) {
            "use strict";
            t.__esModule = !0, t.default = void 0;
            var n, i = (n = r(17)) && n.__esModule ? n : {
                default: n
            };
            var s = /version\/(\d+(\.?_?\d+)+)/i, a = [
                {
                    test: [
                        /googlebot/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Googlebot"
                        }, r = i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /opera/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Opera"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /opr\/|opios/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Opera"
                        }, r = i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /SamsungBrowser/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Samsung Internet for Android"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /Whale/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "NAVER Whale Browser"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /MZBrowser/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "MZ Browser"
                        }, r = i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /focus/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Focus"
                        }, r = i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /swing/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Swing"
                        }, r = i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /coast/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Opera Coast"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /opt\/\d+(?:.?_?\d+)+/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Opera Touch"
                        }, r = i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /yabrowser/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Yandex Browser"
                        }, r = i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /ucbrowser/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "UC Browser"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /Maxthon|mxios/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Maxthon"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /epiphany/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Epiphany"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /puffin/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Puffin"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /sleipnir/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Sleipnir"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /k-meleon/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "K-Meleon"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /micromessenger/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "WeChat"
                        }, r = i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /qqbrowser/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
                        }, r = i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /msie|trident/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Internet Explorer"
                        }, r = i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /\sedg\//i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Microsoft Edge"
                        }, r = i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /edg([ea]|ios)/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Microsoft Edge"
                        }, r = i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /vivaldi/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Vivaldi"
                        }, r = i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /seamonkey/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "SeaMonkey"
                        }, r = i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /sailfish/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Sailfish"
                        }, r = i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /silk/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Amazon Silk"
                        }, r = i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /phantom/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "PhantomJS"
                        }, r = i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /slimerjs/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "SlimerJS"
                        }, r = i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /blackberry|\bbb\d+/i,
                        /rim\stablet/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "BlackBerry"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /(web|hpw)[o0]s/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "WebOS Browser"
                        }, r = i.default.getFirstMatch(s, e) || i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /bada/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Bada"
                        }, r = i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /tizen/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Tizen"
                        }, r = i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /qupzilla/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "QupZilla"
                        }, r = i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /firefox|iceweasel|fxios/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Firefox"
                        }, r = i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /electron/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Electron"
                        }, r = i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /MiuiBrowser/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Miui"
                        }, r = i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /chromium/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Chromium"
                        }, r = i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /chrome|crios|crmo/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Chrome"
                        }, r = i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /GSA/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Google Search"
                        }, r = i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: function(e) {
                        var t = !e.test(/like android/i), r = e.test(/android/i);
                        return t && r;
                    },
                    describe: function(e) {
                        var t = {
                            name: "Android Browser"
                        }, r = i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /playstation 4/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "PlayStation 4"
                        }, r = i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /safari|applewebkit/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: "Safari"
                        }, r = i.default.getFirstMatch(s, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /.*/i
                    ],
                    describe: function(e) {
                        var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
                        return {
                            name: i.default.getFirstMatch(t, e),
                            version: i.default.getSecondMatch(t, e)
                        };
                    }
                }
            ];
            t.default = a, e.exports = t.default;
        },
        93: function(e, t, r) {
            "use strict";
            t.__esModule = !0, t.default = void 0;
            var n, i = (n = r(17)) && n.__esModule ? n : {
                default: n
            }, s = r(18);
            var a = [
                {
                    test: [
                        /Roku\/DVP/
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
                        return {
                            name: s.OS_MAP.Roku,
                            version: t
                        };
                    }
                },
                {
                    test: [
                        /windows phone/i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
                        return {
                            name: s.OS_MAP.WindowsPhone,
                            version: t
                        };
                    }
                },
                {
                    test: [
                        /windows /i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e), r = i.default.getWindowsVersionName(t);
                        return {
                            name: s.OS_MAP.Windows,
                            version: t,
                            versionName: r
                        };
                    }
                },
                {
                    test: [
                        /Macintosh(.*?) FxiOS(.*?)\//
                    ],
                    describe: function(e) {
                        var t = {
                            name: s.OS_MAP.iOS
                        }, r = i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /macintosh/i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."), r = i.default.getMacOSVersionName(t), n = {
                            name: s.OS_MAP.MacOS,
                            version: t
                        };
                        return r && (n.versionName = r), n;
                    }
                },
                {
                    test: [
                        /(ipod|iphone|ipad)/i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
                        return {
                            name: s.OS_MAP.iOS,
                            version: t
                        };
                    }
                },
                {
                    test: function(e) {
                        var t = !e.test(/like android/i), r = e.test(/android/i);
                        return t && r;
                    },
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e), r = i.default.getAndroidVersionName(t), n = {
                            name: s.OS_MAP.Android,
                            version: t
                        };
                        return r && (n.versionName = r), n;
                    }
                },
                {
                    test: [
                        /(web|hpw)[o0]s/i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e), r = {
                            name: s.OS_MAP.WebOS
                        };
                        return t && t.length && (r.version = t), r;
                    }
                },
                {
                    test: [
                        /blackberry|\bbb\d+/i,
                        /rim\stablet/i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || i.default.getFirstMatch(/\bbb(\d+)/i, e);
                        return {
                            name: s.OS_MAP.BlackBerry,
                            version: t
                        };
                    }
                },
                {
                    test: [
                        /bada/i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
                        return {
                            name: s.OS_MAP.Bada,
                            version: t
                        };
                    }
                },
                {
                    test: [
                        /tizen/i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
                        return {
                            name: s.OS_MAP.Tizen,
                            version: t
                        };
                    }
                },
                {
                    test: [
                        /linux/i
                    ],
                    describe: function() {
                        return {
                            name: s.OS_MAP.Linux
                        };
                    }
                },
                {
                    test: [
                        /CrOS/
                    ],
                    describe: function() {
                        return {
                            name: s.OS_MAP.ChromeOS
                        };
                    }
                },
                {
                    test: [
                        /PlayStation 4/
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
                        return {
                            name: s.OS_MAP.PlayStation4,
                            version: t
                        };
                    }
                }
            ];
            t.default = a, e.exports = t.default;
        },
        94: function(e, t, r) {
            "use strict";
            t.__esModule = !0, t.default = void 0;
            var n, i = (n = r(17)) && n.__esModule ? n : {
                default: n
            }, s = r(18);
            var a = [
                {
                    test: [
                        /googlebot/i
                    ],
                    describe: function() {
                        return {
                            type: "bot",
                            vendor: "Google"
                        };
                    }
                },
                {
                    test: [
                        /huawei/i
                    ],
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/(can-l01)/i, e) && "Nova", r = {
                            type: s.PLATFORMS_MAP.mobile,
                            vendor: "Huawei"
                        };
                        return t && (r.model = t), r;
                    }
                },
                {
                    test: [
                        /nexus\s*(?:7|8|9|10).*/i
                    ],
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tablet,
                            vendor: "Nexus"
                        };
                    }
                },
                {
                    test: [
                        /ipad/i
                    ],
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tablet,
                            vendor: "Apple",
                            model: "iPad"
                        };
                    }
                },
                {
                    test: [
                        /Macintosh(.*?) FxiOS(.*?)\//
                    ],
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tablet,
                            vendor: "Apple",
                            model: "iPad"
                        };
                    }
                },
                {
                    test: [
                        /kftt build/i
                    ],
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tablet,
                            vendor: "Amazon",
                            model: "Kindle Fire HD 7"
                        };
                    }
                },
                {
                    test: [
                        /silk/i
                    ],
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tablet,
                            vendor: "Amazon"
                        };
                    }
                },
                {
                    test: [
                        /tablet(?! pc)/i
                    ],
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tablet
                        };
                    }
                },
                {
                    test: function(e) {
                        var t = e.test(/ipod|iphone/i), r = e.test(/like (ipod|iphone)/i);
                        return t && !r;
                    },
                    describe: function(e) {
                        var t = i.default.getFirstMatch(/(ipod|iphone)/i, e);
                        return {
                            type: s.PLATFORMS_MAP.mobile,
                            vendor: "Apple",
                            model: t
                        };
                    }
                },
                {
                    test: [
                        /nexus\s*[0-6].*/i,
                        /galaxy nexus/i
                    ],
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.mobile,
                            vendor: "Nexus"
                        };
                    }
                },
                {
                    test: [
                        /[^-]mobi/i
                    ],
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.mobile
                        };
                    }
                },
                {
                    test: function(e) {
                        return "blackberry" === e.getBrowserName(!0);
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.mobile,
                            vendor: "BlackBerry"
                        };
                    }
                },
                {
                    test: function(e) {
                        return "bada" === e.getBrowserName(!0);
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.mobile
                        };
                    }
                },
                {
                    test: function(e) {
                        return "windows phone" === e.getBrowserName();
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.mobile,
                            vendor: "Microsoft"
                        };
                    }
                },
                {
                    test: function(e) {
                        var t = Number(String(e.getOSVersion()).split(".")[0]);
                        return "android" === e.getOSName(!0) && t >= 3;
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tablet
                        };
                    }
                },
                {
                    test: function(e) {
                        return "android" === e.getOSName(!0);
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.mobile
                        };
                    }
                },
                {
                    test: function(e) {
                        return "macos" === e.getOSName(!0);
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.desktop,
                            vendor: "Apple"
                        };
                    }
                },
                {
                    test: function(e) {
                        return "windows" === e.getOSName(!0);
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.desktop
                        };
                    }
                },
                {
                    test: function(e) {
                        return "linux" === e.getOSName(!0);
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.desktop
                        };
                    }
                },
                {
                    test: function(e) {
                        return "playstation 4" === e.getOSName(!0);
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tv
                        };
                    }
                },
                {
                    test: function(e) {
                        return "roku" === e.getOSName(!0);
                    },
                    describe: function() {
                        return {
                            type: s.PLATFORMS_MAP.tv
                        };
                    }
                }
            ];
            t.default = a, e.exports = t.default;
        },
        95: function(e, t, r) {
            "use strict";
            t.__esModule = !0, t.default = void 0;
            var n, i = (n = r(17)) && n.__esModule ? n : {
                default: n
            }, s = r(18);
            var a = [
                {
                    test: function(e) {
                        return "microsoft edge" === e.getBrowserName(!0);
                    },
                    describe: function(e) {
                        if (/\sedg\//i.test(e)) return {
                            name: s.ENGINE_MAP.Blink
                        };
                        var t = i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
                        return {
                            name: s.ENGINE_MAP.EdgeHTML,
                            version: t
                        };
                    }
                },
                {
                    test: [
                        /trident/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: s.ENGINE_MAP.Trident
                        }, r = i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: function(e) {
                        return e.test(/presto/i);
                    },
                    describe: function(e) {
                        var t = {
                            name: s.ENGINE_MAP.Presto
                        }, r = i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: function(e) {
                        var t = e.test(/gecko/i), r = e.test(/like gecko/i);
                        return t && !r;
                    },
                    describe: function(e) {
                        var t = {
                            name: s.ENGINE_MAP.Gecko
                        }, r = i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                },
                {
                    test: [
                        /(apple)?webkit\/537\.36/i
                    ],
                    describe: function() {
                        return {
                            name: s.ENGINE_MAP.Blink
                        };
                    }
                },
                {
                    test: [
                        /(apple)?webkit/i
                    ],
                    describe: function(e) {
                        var t = {
                            name: s.ENGINE_MAP.WebKit
                        }, r = i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
                        return r && (t.version = r), t;
                    }
                }
            ];
            t.default = a, e.exports = t.default;
        }
    });
});

},{}],"8vPQN":[function(require,module,exports) {
var parser = require("896dd138d0728d9d");
var writer = require("a2c956b9b6568c84");
exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;

},{"896dd138d0728d9d":"8uyst","a2c956b9b6568c84":"bGmrK"}],"8uyst":[function(require,module,exports) {
var toIntIfInt = function(v) {
    return String(Number(v)) === v ? Number(v) : v;
};
var attachProperties = function(match, location, names, rawName) {
    if (rawName && !names) location[rawName] = toIntIfInt(match[1]);
    else {
        for(var i = 0; i < names.length; i += 1)if (match[i + 1] != null) location[names[i]] = toIntIfInt(match[i + 1]);
    }
};
var parseReg = function(obj, location, content) {
    var needsBlank = obj.name && obj.names;
    if (obj.push && !location[obj.push]) location[obj.push] = [];
    else if (needsBlank && !location[obj.name]) location[obj.name] = {};
    var keyLocation = obj.push ? {} : needsBlank ? location[obj.name] : location; // otherwise, named location or root
    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
    if (obj.push) location[obj.push].push(keyLocation);
};
var grammar = require("5d6ddecb2cc64117");
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
exports.parse = function(sdp) {
    var session = {}, media = [], location = session; // points at where properties go under (one of the above)
    // parse lines we understand
    sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
        var type = l[0];
        var content = l.slice(2);
        if (type === "m") {
            media.push({
                rtp: [],
                fmtp: []
            });
            location = media[media.length - 1]; // point at latest media line
        }
        for(var j = 0; j < (grammar[type] || []).length; j += 1){
            var obj = grammar[type][j];
            if (obj.reg.test(content)) return parseReg(obj, location, content);
        }
    });
    session.media = media; // link it up
    return session;
};
var paramReducer = function(acc, expr) {
    var s = expr.split(/=(.+)/, 2);
    if (s.length === 2) acc[s[0]] = toIntIfInt(s[1]);
    else if (s.length === 1 && expr.length > 1) acc[s[0]] = undefined;
    return acc;
};
exports.parseParams = function(str) {
    return str.split(/;\s?/).reduce(paramReducer, {});
};
// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;
exports.parsePayloads = function(str) {
    return str.toString().split(" ").map(Number);
};
exports.parseRemoteCandidates = function(str) {
    var candidates = [];
    var parts = str.split(" ").map(toIntIfInt);
    for(var i = 0; i < parts.length; i += 3)candidates.push({
        component: parts[i],
        ip: parts[i + 1],
        port: parts[i + 2]
    });
    return candidates;
};
exports.parseImageAttributes = function(str) {
    return str.split(" ").map(function(item) {
        return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
    });
};
exports.parseSimulcastStreamList = function(str) {
    return str.split(";").map(function(stream) {
        return stream.split(",").map(function(format) {
            var scid, paused = false;
            if (format[0] !== "~") scid = toIntIfInt(format);
            else {
                scid = toIntIfInt(format.substring(1, format.length));
                paused = true;
            }
            return {
                scid: scid,
                paused: paused
            };
        });
    });
};

},{"5d6ddecb2cc64117":"jnvad"}],"jnvad":[function(require,module,exports) {
var grammar = module.exports = {
    v: [
        {
            name: "version",
            reg: /^(\d*)$/
        }
    ],
    o: [
        {
            // o=- 20518 0 IN IP4 203.0.113.1
            // NB: sessionId will be a String in most cases because it is huge
            name: "origin",
            reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
            names: [
                "username",
                "sessionId",
                "sessionVersion",
                "netType",
                "ipVer",
                "address"
            ],
            format: "%s %s %d %s IP%d %s"
        }
    ],
    // default parsing of these only (though some of these feel outdated)
    s: [
        {
            name: "name"
        }
    ],
    i: [
        {
            name: "description"
        }
    ],
    u: [
        {
            name: "uri"
        }
    ],
    e: [
        {
            name: "email"
        }
    ],
    p: [
        {
            name: "phone"
        }
    ],
    z: [
        {
            name: "timezones"
        }
    ],
    r: [
        {
            name: "repeats"
        }
    ],
    // k: [{}], // outdated thing ignored
    t: [
        {
            // t=0 0
            name: "timing",
            reg: /^(\d*) (\d*)/,
            names: [
                "start",
                "stop"
            ],
            format: "%d %d"
        }
    ],
    c: [
        {
            // c=IN IP4 10.47.197.26
            name: "connection",
            reg: /^IN IP(\d) (\S*)/,
            names: [
                "version",
                "ip"
            ],
            format: "IN IP%d %s"
        }
    ],
    b: [
        {
            // b=AS:4000
            push: "bandwidth",
            reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
            names: [
                "type",
                "limit"
            ],
            format: "%s:%s"
        }
    ],
    m: [
        {
            // m=video 51744 RTP/AVP 126 97 98 34 31
            // NB: special - pushes to session
            // TODO: rtp/fmtp should be filtered by the payloads found here?
            reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
            names: [
                "type",
                "port",
                "protocol",
                "payloads"
            ],
            format: "%s %d %s %s"
        }
    ],
    a: [
        {
            // a=rtpmap:110 opus/48000/2
            push: "rtp",
            reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
            names: [
                "payload",
                "codec",
                "rate",
                "encoding"
            ],
            format: function(o) {
                return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
            }
        },
        {
            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
            // a=fmtp:111 minptime=10; useinbandfec=1
            push: "fmtp",
            reg: /^fmtp:(\d*) ([\S| ]*)/,
            names: [
                "payload",
                "config"
            ],
            format: "fmtp:%d %s"
        },
        {
            // a=control:streamid=0
            name: "control",
            reg: /^control:(.*)/,
            format: "control:%s"
        },
        {
            // a=rtcp:65179 IN IP4 193.84.77.194
            name: "rtcp",
            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
            names: [
                "port",
                "netType",
                "ipVer",
                "address"
            ],
            format: function(o) {
                return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
            }
        },
        {
            // a=rtcp-fb:98 trr-int 100
            push: "rtcpFbTrrInt",
            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
            names: [
                "payload",
                "value"
            ],
            format: "rtcp-fb:%s trr-int %d"
        },
        {
            // a=rtcp-fb:98 nack rpsi
            push: "rtcpFb",
            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
            names: [
                "payload",
                "type",
                "subtype"
            ],
            format: function(o) {
                return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
            }
        },
        {
            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
            // a=extmap:1/recvonly URI-gps-string
            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
            push: "ext",
            reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
            names: [
                "value",
                "direction",
                "encrypt-uri",
                "uri",
                "config"
            ],
            format: function(o) {
                return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
            }
        },
        {
            // a=extmap-allow-mixed
            name: "extmapAllowMixed",
            reg: /^(extmap-allow-mixed)/
        },
        {
            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
            push: "crypto",
            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
            names: [
                "id",
                "suite",
                "config",
                "sessionConfig"
            ],
            format: function(o) {
                return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
            }
        },
        {
            // a=setup:actpass
            name: "setup",
            reg: /^setup:(\w*)/,
            format: "setup:%s"
        },
        {
            // a=connection:new
            name: "connectionType",
            reg: /^connection:(new|existing)/,
            format: "connection:%s"
        },
        {
            // a=mid:1
            name: "mid",
            reg: /^mid:([^\s]*)/,
            format: "mid:%s"
        },
        {
            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
            name: "msid",
            reg: /^msid:(.*)/,
            format: "msid:%s"
        },
        {
            // a=ptime:20
            name: "ptime",
            reg: /^ptime:(\d*(?:\.\d*)*)/,
            format: "ptime:%d"
        },
        {
            // a=maxptime:60
            name: "maxptime",
            reg: /^maxptime:(\d*(?:\.\d*)*)/,
            format: "maxptime:%d"
        },
        {
            // a=sendrecv
            name: "direction",
            reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
            // a=ice-lite
            name: "icelite",
            reg: /^(ice-lite)/
        },
        {
            // a=ice-ufrag:F7gI
            name: "iceUfrag",
            reg: /^ice-ufrag:(\S*)/,
            format: "ice-ufrag:%s"
        },
        {
            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
            name: "icePwd",
            reg: /^ice-pwd:(\S*)/,
            format: "ice-pwd:%s"
        },
        {
            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
            name: "fingerprint",
            reg: /^fingerprint:(\S*) (\S*)/,
            names: [
                "type",
                "hash"
            ],
            format: "fingerprint:%s %s"
        },
        {
            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
            push: "candidates",
            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
            names: [
                "foundation",
                "component",
                "transport",
                "priority",
                "ip",
                "port",
                "type",
                "raddr",
                "rport",
                "tcptype",
                "generation",
                "network-id",
                "network-cost"
            ],
            format: function(o) {
                var str = "candidate:%s %d %s %d %s %d typ %s";
                str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
                // NB: candidate has three optional chunks, so %void middles one if it's missing
                str += o.tcptype != null ? " tcptype %s" : "%v";
                if (o.generation != null) str += " generation %d";
                str += o["network-id"] != null ? " network-id %d" : "%v";
                str += o["network-cost"] != null ? " network-cost %d" : "%v";
                return str;
            }
        },
        {
            // a=end-of-candidates (keep after the candidates line for readability)
            name: "endOfCandidates",
            reg: /^(end-of-candidates)/
        },
        {
            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
            name: "remoteCandidates",
            reg: /^remote-candidates:(.*)/,
            format: "remote-candidates:%s"
        },
        {
            // a=ice-options:google-ice
            name: "iceOptions",
            reg: /^ice-options:(\S*)/,
            format: "ice-options:%s"
        },
        {
            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
            push: "ssrcs",
            reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
            names: [
                "id",
                "attribute",
                "value"
            ],
            format: function(o) {
                var str = "ssrc:%d";
                if (o.attribute != null) {
                    str += " %s";
                    if (o.value != null) str += ":%s";
                }
                return str;
            }
        },
        {
            // a=ssrc-group:FEC 1 2
            // a=ssrc-group:FEC-FR 3004364195 1080772241
            push: "ssrcGroups",
            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
            reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
            names: [
                "semantics",
                "ssrcs"
            ],
            format: "ssrc-group:%s %s"
        },
        {
            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
            name: "msidSemantic",
            reg: /^msid-semantic:\s?(\w*) (\S*)/,
            names: [
                "semantic",
                "token"
            ],
            format: "msid-semantic: %s %s" // space after ':' is not accidental
        },
        {
            // a=group:BUNDLE audio video
            push: "groups",
            reg: /^group:(\w*) (.*)/,
            names: [
                "type",
                "mids"
            ],
            format: "group:%s %s"
        },
        {
            // a=rtcp-mux
            name: "rtcpMux",
            reg: /^(rtcp-mux)/
        },
        {
            // a=rtcp-rsize
            name: "rtcpRsize",
            reg: /^(rtcp-rsize)/
        },
        {
            // a=sctpmap:5000 webrtc-datachannel 1024
            name: "sctpmap",
            reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
            names: [
                "sctpmapNumber",
                "app",
                "maxMessageSize"
            ],
            format: function(o) {
                return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
            }
        },
        {
            // a=x-google-flag:conference
            name: "xGoogleFlag",
            reg: /^x-google-flag:([^\s]*)/,
            format: "x-google-flag:%s"
        },
        {
            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
            push: "rids",
            reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
            names: [
                "id",
                "direction",
                "params"
            ],
            format: function(o) {
                return o.params ? "rid:%s %s %s" : "rid:%s %s";
            }
        },
        {
            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
            // a=imageattr:* send [x=800,y=640] recv *
            // a=imageattr:100 recv [x=320,y=240]
            push: "imageattrs",
            reg: new RegExp(// a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
            names: [
                "pt",
                "dir1",
                "attrs1",
                "dir2",
                "attrs2"
            ],
            format: function(o) {
                return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
            }
        },
        {
            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
            // a=simulcast:recv 1;4,5 send 6;7
            name: "simulcast",
            reg: new RegExp(// a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
            names: [
                "dir1",
                "list1",
                "dir2",
                "list2"
            ],
            format: function(o) {
                return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
            }
        },
        {
            // old simulcast draft 03 (implemented by Firefox)
            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
            // a=simulcast: recv pt=97;98 send pt=97
            // a=simulcast: send rid=5;6;7 paused=6,7
            name: "simulcast_03",
            reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
            names: [
                "value"
            ],
            format: "simulcast: %s"
        },
        {
            // a=framerate:25
            // a=framerate:29.97
            name: "framerate",
            reg: /^framerate:(\d+(?:$|\.\d+))/,
            format: "framerate:%s"
        },
        {
            // RFC4570
            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
            name: "sourceFilter",
            reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
            names: [
                "filterMode",
                "netType",
                "addressTypes",
                "destAddress",
                "srcList"
            ],
            format: "source-filter: %s %s %s %s %s"
        },
        {
            // a=bundle-only
            name: "bundleOnly",
            reg: /^(bundle-only)/
        },
        {
            // a=label:1
            name: "label",
            reg: /^label:(.+)/,
            format: "label:%s"
        },
        {
            // RFC version 26 for SCTP over DTLS
            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
            name: "sctpPort",
            reg: /^sctp-port:(\d+)$/,
            format: "sctp-port:%s"
        },
        {
            // RFC version 26 for SCTP over DTLS
            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
            name: "maxMessageSize",
            reg: /^max-message-size:(\d+)$/,
            format: "max-message-size:%s"
        },
        {
            // RFC7273
            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
            push: "tsRefClocks",
            reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
            names: [
                "clksrc",
                "clksrcExt"
            ],
            format: function(o) {
                return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
            }
        },
        {
            // RFC7273
            // a=mediaclk:direct=963214424
            name: "mediaClk",
            reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
            names: [
                "id",
                "mediaClockName",
                "mediaClockValue",
                "rateNumerator",
                "rateDenominator"
            ],
            format: function(o) {
                var str = "mediaclk:";
                str += o.id != null ? "id=%s %s" : "%v%s";
                str += o.mediaClockValue != null ? "=%s" : "";
                str += o.rateNumerator != null ? " rate=%s" : "";
                str += o.rateDenominator != null ? "/%s" : "";
                return str;
            }
        },
        {
            // a=keywds:keywords
            name: "keywords",
            reg: /^keywds:(.+)$/,
            format: "keywds:%s"
        },
        {
            // a=content:main
            name: "content",
            reg: /^content:(.+)/,
            format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
            // a=floorctrl:c-s
            name: "bfcpFloorCtrl",
            reg: /^floorctrl:(c-only|s-only|c-s)/,
            format: "floorctrl:%s"
        },
        {
            // a=confid:1
            name: "bfcpConfId",
            reg: /^confid:(\d+)/,
            format: "confid:%s"
        },
        {
            // a=userid:1
            name: "bfcpUserId",
            reg: /^userid:(\d+)/,
            format: "userid:%s"
        },
        {
            // a=floorid:1
            name: "bfcpFloorId",
            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
            names: [
                "id",
                "mStream"
            ],
            format: "floorid:%s mstrm:%s"
        },
        {
            // any a= that we don't understand is kept verbatim on media.invalid
            push: "invalid",
            names: [
                "value"
            ]
        }
    ]
};
// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function(key) {
    var objs = grammar[key];
    objs.forEach(function(obj) {
        if (!obj.reg) obj.reg = /(.*)/;
        if (!obj.format) obj.format = "%s";
    });
});

},{}],"bGmrK":[function(require,module,exports) {
var grammar = require("be5cdbc1181ea946");
// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function(formatStr) {
    var i = 1;
    var args = arguments;
    var len = args.length;
    return formatStr.replace(formatRegExp, function(x) {
        if (i >= len) return x; // missing argument
        var arg = args[i];
        i += 1;
        switch(x){
            case "%%":
                return "%";
            case "%s":
                return String(arg);
            case "%d":
                return Number(arg);
            case "%v":
                return "";
        }
    });
// NB: we discard excess arguments - they are typically undefined from makeLine
};
var makeLine = function(type, obj, location) {
    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
    var args = [
        type + "=" + str
    ];
    if (obj.names) for(var i = 0; i < obj.names.length; i += 1){
        var n = obj.names[i];
        if (obj.name) args.push(location[obj.name][n]);
        else args.push(location[obj.names[i]]);
    }
    else args.push(location[obj.name]);
    return format.apply(null, args);
};
// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
    "v",
    "o",
    "s",
    "i",
    "u",
    "e",
    "p",
    "c",
    "b",
    "t",
    "r",
    "z",
    "a"
];
var defaultInnerOrder = [
    "i",
    "c",
    "b",
    "a"
];
module.exports = function(session, opts) {
    opts = opts || {};
    // ensure certain properties exist
    if (session.version == null) session.version = 0; // 'v=0' must be there (only defined version atm)
    if (session.name == null) session.name = " "; // 's= ' must be there if no meaningful name set
    session.media.forEach(function(mLine) {
        if (mLine.payloads == null) mLine.payloads = "";
    });
    var outerOrder = opts.outerOrder || defaultOuterOrder;
    var innerOrder = opts.innerOrder || defaultInnerOrder;
    var sdp = [];
    // loop through outerOrder for matching properties on session
    outerOrder.forEach(function(type) {
        grammar[type].forEach(function(obj) {
            if (obj.name in session && session[obj.name] != null) sdp.push(makeLine(type, obj, session));
            else if (obj.push in session && session[obj.push] != null) session[obj.push].forEach(function(el) {
                sdp.push(makeLine(type, obj, el));
            });
        });
    });
    // then for each media line, follow the innerOrder
    session.media.forEach(function(mLine) {
        sdp.push(makeLine("m", grammar.m[0], mLine));
        innerOrder.forEach(function(type) {
            grammar[type].forEach(function(obj) {
                if (obj.name in mLine && mLine[obj.name] != null) sdp.push(makeLine(type, obj, mLine));
                else if (obj.push in mLine && mLine[obj.push] != null) mLine[obj.push].forEach(function(el) {
                    sdp.push(makeLine(type, obj, el));
                });
            });
        });
    });
    return sdp.join("\r\n") + "\r\n";
};

},{"be5cdbc1181ea946":"jnvad"}],"llbZF":[function(require,module,exports) {
/////////////////////////////////////////////////////////////////////////////////
/* UAParser.js v1.0.35
   Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
   MIT License */ /*
   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
   Supports browser & node.js environment. 
   Demo   : https://faisalman.github.io/ua-parser-js
   Source : https://github.com/faisalman/ua-parser-js */ /////////////////////////////////////////////////////////////////////////////////
(function(window1, undefined) {
    "use strict";
    //////////////
    // Constants
    /////////////
    var LIBVERSION = "1.0.35", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 350;
    var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", VIERA = "Viera", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS";
    ///////////
    // Helper
    //////////
    var extend = function(regexes, extensions) {
        var mergedRegexes = {};
        for(var i in regexes)if (extensions[i] && extensions[i].length % 2 === 0) mergedRegexes[i] = extensions[i].concat(regexes[i]);
        else mergedRegexes[i] = regexes[i];
        return mergedRegexes;
    }, enumerize = function(arr) {
        var enums = {};
        for(var i = 0; i < arr.length; i++)enums[arr[i].toUpperCase()] = arr[i];
        return enums;
    }, has = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
    }, lowerize = function(str) {
        return str.toLowerCase();
    }, majorize = function(version) {
        return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined;
    }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
            str = str.replace(/^\s\s*/, EMPTY);
            return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
    };
    ///////////////
    // Map helper
    //////////////
    var rgxMapper = function(ua, arrays) {
        var i = 0, j, k, p, q, matches, match;
        // loop through all regexes maps
        while(i < arrays.length && !matches){
            var regex = arrays[i], props = arrays[i + 1]; // odd sequence (1,3,5,..)
            j = k = 0;
            // try matching uastring with regexes
            while(j < regex.length && !matches){
                if (!regex[j]) break;
                matches = regex[j++].exec(ua);
                if (!!matches) for(p = 0; p < props.length; p++){
                    match = matches[++k];
                    q = props[p];
                    // check if given property is actually array
                    if (typeof q === OBJ_TYPE && q.length > 0) {
                        if (q.length === 2) {
                            if (typeof q[1] == FUNC_TYPE) // assign modified match
                            this[q[0]] = q[1].call(this, match);
                            else // assign given value, ignore regex match
                            this[q[0]] = q[1];
                        } else if (q.length === 3) {
                            // check whether function or regex
                            if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) // call function (usually string mapper)
                            this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                            else // sanitize match using given regex
                            this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                        } else if (q.length === 4) this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                    } else this[q] = match ? match : undefined;
                }
            }
            i += 2;
        }
    }, strMapper = function(str, map) {
        for(var i in map){
            // check if current value is array
            if (typeof map[i] === OBJ_TYPE && map[i].length > 0) for(var j = 0; j < map[i].length; j++){
                if (has(map[i][j], str)) return i === UNKNOWN ? undefined : i;
            }
            else if (has(map[i], str)) return i === UNKNOWN ? undefined : i;
        }
        return str;
    };
    ///////////////
    // String map
    //////////////
    // Safari < 3.0
    var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
    }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": [
            "NT 5.1",
            "NT 5.2"
        ],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": [
            "NT 6.4",
            "NT 10.0"
        ],
        "RT": "ARM"
    };
    //////////////
    // Regex map
    /////////////
    var regexes = {
        browser: [
            [
                /\b(?:crmo|crios)\/([\w\.]+)/i // Chrome for Android/iOS
            ],
            [
                VERSION,
                [
                    NAME,
                    "Chrome"
                ]
            ],
            [
                /edg(?:e|ios|a)?\/([\w\.]+)/i // Microsoft Edge
            ],
            [
                VERSION,
                [
                    NAME,
                    "Edge"
                ]
            ],
            [
                // Presto based
                /(opera mini)\/([-\w\.]+)/i,
                /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i // Opera
            ],
            [
                NAME,
                VERSION
            ],
            [
                /opios[\/ ]+([\w\.]+)/i // Opera mini on iphone >= 8.0
            ],
            [
                VERSION,
                [
                    NAME,
                    OPERA + " Mini"
                ]
            ],
            [
                /\bopr\/([\w\.]+)/i // Opera Webkit
            ],
            [
                VERSION,
                [
                    NAME,
                    OPERA
                ]
            ],
            [
                // Mixed
                /(kindle)\/([\w\.]+)/i,
                /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                // Trident based
                /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                /(?:ms|\()(ie) ([\w\.]+)/i,
                // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
                /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
                /(heytap|ovi)browser\/([\d\.]+)/i,
                /(weibo)__([\d\.]+)/i // Weibo
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i // UCBrowser
            ],
            [
                VERSION,
                [
                    NAME,
                    "UC" + BROWSER
                ]
            ],
            [
                /microm.+\bqbcore\/([\w\.]+)/i,
                /\bqbcore\/([\w\.]+).+microm/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "WeChat(Win) Desktop"
                ]
            ],
            [
                /micromessenger\/([\w\.]+)/i // WeChat
            ],
            [
                VERSION,
                [
                    NAME,
                    "WeChat"
                ]
            ],
            [
                /konqueror\/([\w\.]+)/i // Konqueror
            ],
            [
                VERSION,
                [
                    NAME,
                    "Konqueror"
                ]
            ],
            [
                /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i // IE11
            ],
            [
                VERSION,
                [
                    NAME,
                    "IE"
                ]
            ],
            [
                /ya(?:search)?browser\/([\w\.]+)/i // Yandex
            ],
            [
                VERSION,
                [
                    NAME,
                    "Yandex"
                ]
            ],
            [
                /(avast|avg)\/([\w\.]+)/i // Avast/AVG Secure Browser
            ],
            [
                [
                    NAME,
                    /(.+)/,
                    "$1 Secure " + BROWSER
                ],
                VERSION
            ],
            [
                /\bfocus\/([\w\.]+)/i // Firefox Focus
            ],
            [
                VERSION,
                [
                    NAME,
                    FIREFOX + " Focus"
                ]
            ],
            [
                /\bopt\/([\w\.]+)/i // Opera Touch
            ],
            [
                VERSION,
                [
                    NAME,
                    OPERA + " Touch"
                ]
            ],
            [
                /coc_coc\w+\/([\w\.]+)/i // Coc Coc Browser
            ],
            [
                VERSION,
                [
                    NAME,
                    "Coc Coc"
                ]
            ],
            [
                /dolfin\/([\w\.]+)/i // Dolphin
            ],
            [
                VERSION,
                [
                    NAME,
                    "Dolphin"
                ]
            ],
            [
                /coast\/([\w\.]+)/i // Opera Coast
            ],
            [
                VERSION,
                [
                    NAME,
                    OPERA + " Coast"
                ]
            ],
            [
                /miuibrowser\/([\w\.]+)/i // MIUI Browser
            ],
            [
                VERSION,
                [
                    NAME,
                    "MIUI " + BROWSER
                ]
            ],
            [
                /fxios\/([-\w\.]+)/i // Firefox for iOS
            ],
            [
                VERSION,
                [
                    NAME,
                    FIREFOX
                ]
            ],
            [
                /\bqihu|(qi?ho?o?|360)browser/i // 360
            ],
            [
                [
                    NAME,
                    "360 " + BROWSER
                ]
            ],
            [
                /(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i
            ],
            [
                [
                    NAME,
                    /(.+)/,
                    "$1 " + BROWSER
                ],
                VERSION
            ],
            [
                /(comodo_dragon)\/([\w\.]+)/i // Comodo Dragon
            ],
            [
                [
                    NAME,
                    /_/g,
                    " "
                ],
                VERSION
            ],
            [
                /(electron)\/([\w\.]+) safari/i,
                /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i // QQBrowser/Baidu App/2345 Browser
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(metasr)[\/ ]?([\w\.]+)/i,
                /(lbbrowser)/i,
                /\[(linkedin)app\]/i // LinkedIn App for iOS & Android
            ],
            [
                NAME
            ],
            [
                // WebView
                /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i // Facebook App for iOS & Android
            ],
            [
                [
                    NAME,
                    FACEBOOK
                ],
                VERSION
            ],
            [
                /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
                /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
                /safari (line)\/([\w\.]+)/i,
                /\b(line)\/([\w\.]+)\/iab/i,
                /(chromium|instagram)[\/ ]([-\w\.]+)/i // Chromium/Instagram
            ],
            [
                NAME,
                VERSION
            ],
            [
                /\bgsa\/([\w\.]+) .*safari\//i // Google Search Appliance on iOS
            ],
            [
                VERSION,
                [
                    NAME,
                    "GSA"
                ]
            ],
            [
                /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i // TikTok
            ],
            [
                VERSION,
                [
                    NAME,
                    "TikTok"
                ]
            ],
            [
                /headlesschrome(?:\/([\w\.]+)| )/i // Chrome Headless
            ],
            [
                VERSION,
                [
                    NAME,
                    CHROME + " Headless"
                ]
            ],
            [
                / wv\).+(chrome)\/([\w\.]+)/i // Chrome WebView
            ],
            [
                [
                    NAME,
                    CHROME + " WebView"
                ],
                VERSION
            ],
            [
                /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i // Android Browser
            ],
            [
                VERSION,
                [
                    NAME,
                    "Android " + BROWSER
                ]
            ],
            [
                /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i // Chrome/OmniWeb/Arora/Tizen/Nokia
            ],
            [
                NAME,
                VERSION
            ],
            [
                /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i // Mobile Safari
            ],
            [
                VERSION,
                [
                    NAME,
                    "Mobile Safari"
                ]
            ],
            [
                /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i // Safari & Safari Mobile
            ],
            [
                VERSION,
                NAME
            ],
            [
                /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i // Safari < 3.0
            ],
            [
                NAME,
                [
                    VERSION,
                    strMapper,
                    oldSafariMap
                ]
            ],
            [
                /(webkit|khtml)\/([\w\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                // Gecko based
                /(navigator|netscape\d?)\/([-\w\.]+)/i // Netscape
            ],
            [
                [
                    NAME,
                    "Netscape"
                ],
                VERSION
            ],
            [
                /mobile vr; rv:([\w\.]+)\).+firefox/i // Firefox Reality
            ],
            [
                VERSION,
                [
                    NAME,
                    FIREFOX + " Reality"
                ]
            ],
            [
                /ekiohf.+(flow)\/([\w\.]+)/i,
                /(swiftfox)/i,
                /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
                /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
                /(firefox)\/([\w\.]+)/i,
                /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                // Other
                /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
                /(links) \(([\w\.]+)/i,
                /panasonic;(viera)/i // Panasonic Viera
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(cobalt)\/([\w\.]+)/i // Cobalt
            ],
            [
                NAME,
                [
                    VERSION,
                    /master.|lts./,
                    ""
                ]
            ]
        ],
        cpu: [
            [
                /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i // AMD64 (x64)
            ],
            [
                [
                    ARCHITECTURE,
                    "amd64"
                ]
            ],
            [
                /(ia32(?=;))/i // IA32 (quicktime)
            ],
            [
                [
                    ARCHITECTURE,
                    lowerize
                ]
            ],
            [
                /((?:i[346]|x)86)[;\)]/i // IA32 (x86)
            ],
            [
                [
                    ARCHITECTURE,
                    "ia32"
                ]
            ],
            [
                /\b(aarch64|arm(v?8e?l?|_?64))\b/i // ARM64
            ],
            [
                [
                    ARCHITECTURE,
                    "arm64"
                ]
            ],
            [
                /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i // ARMHF
            ],
            [
                [
                    ARCHITECTURE,
                    "armhf"
                ]
            ],
            [
                // PocketPC mistakenly identified as PowerPC
                /windows (ce|mobile); ppc;/i
            ],
            [
                [
                    ARCHITECTURE,
                    "arm"
                ]
            ],
            [
                /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i // PowerPC
            ],
            [
                [
                    ARCHITECTURE,
                    /ower/,
                    EMPTY,
                    lowerize
                ]
            ],
            [
                /(sun4\w)[;\)]/i // SPARC
            ],
            [
                [
                    ARCHITECTURE,
                    "sparc"
                ]
            ],
            [
                /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            ],
            [
                [
                    ARCHITECTURE,
                    lowerize
                ]
            ]
        ],
        device: [
            [
                //////////////////////////
                // MOBILES & TABLETS
                /////////////////////////
                // Samsung
                /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SAMSUNG
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
                /samsung[- ]([-\w]+)/i,
                /sec-(sgh\w+)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SAMSUNG
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Apple
                /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i // iPod/iPhone
            ],
            [
                MODEL,
                [
                    VENDOR,
                    APPLE
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\((ipad);[-\w\),; ]+apple/i,
                /applecoremedia\/[\w\.]+ \((ipad)/i,
                /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    APPLE
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(macintosh);/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    APPLE
                ]
            ],
            [
                // Sharp
                /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SHARP
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Huawei
                /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    HUAWEI
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(?:huawei|honor)([-\w ]+)[;\)]/i,
                /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    HUAWEI
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Xiaomi
                /\b(poco[\w ]+)(?: bui|\))/i,
                /\b; (\w+) build\/hm\1/i,
                /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
            ],
            [
                [
                    MODEL,
                    /_/g,
                    " "
                ],
                [
                    VENDOR,
                    XIAOMI
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i // Mi Pad tablets
            ],
            [
                [
                    MODEL,
                    /_/g,
                    " "
                ],
                [
                    VENDOR,
                    XIAOMI
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                // OPPO
                /; (\w+) bui.+ oppo/i,
                /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "OPPO"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Vivo
                /vivo (\w+)(?: bui|\))/i,
                /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Vivo"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Realme
                /\b(rmx[12]\d{3})(?: bui|;|\))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Realme"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Motorola
                /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                /\bmot(?:orola)?[- ](\w*)/i,
                /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    MOTOROLA
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    MOTOROLA
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                // LG
                /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    LG
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                /\blg-?([\d\w]+) bui/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    LG
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Lenovo
                /(ideatab[-\w ]+)/i,
                /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Lenovo"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                // Nokia
                /(?:maemo|nokia).*(n900|lumia \d+)/i,
                /nokia[-_ ]?([-\w\.]*)/i
            ],
            [
                [
                    MODEL,
                    /_/g,
                    " "
                ],
                [
                    VENDOR,
                    "Nokia"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Google
                /(pixel c)\b/i // Google Pixel C
            ],
            [
                MODEL,
                [
                    VENDOR,
                    GOOGLE
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i // Google Pixel
            ],
            [
                MODEL,
                [
                    VENDOR,
                    GOOGLE
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Sony
                /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SONY
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /sony tablet [ps]/i,
                /\b(?:sony)?sgp\w+(?: bui|\))/i
            ],
            [
                [
                    MODEL,
                    "Xperia Tablet"
                ],
                [
                    VENDOR,
                    SONY
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                // OnePlus
                / (kb2005|in20[12]5|be20[12][59])\b/i,
                /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "OnePlus"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Amazon
                /(alexa)webm/i,
                /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
                /(kf[a-z]+)( bui|\)).+silk\//i // Kindle Fire HD
            ],
            [
                MODEL,
                [
                    VENDOR,
                    AMAZON
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i // Fire Phone
            ],
            [
                [
                    MODEL,
                    /(.+)/g,
                    "Fire Phone $1"
                ],
                [
                    VENDOR,
                    AMAZON
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // BlackBerry
                /(playbook);[-\w\),; ]+(rim)/i // BlackBerry PlayBook
            ],
            [
                MODEL,
                VENDOR,
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((?:bb[a-f]|st[hv])100-\d)/i,
                /\(bb10; (\w+)/i // BlackBerry 10
            ],
            [
                MODEL,
                [
                    VENDOR,
                    BLACKBERRY
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Asus
                /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ASUS
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ASUS
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // HTC
                /(nexus 9)/i // HTC Nexus 9
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "HTC"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                // ZTE
                /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ],
            [
                VENDOR,
                [
                    MODEL,
                    /_/g,
                    " "
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // Acer
                /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Acer"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                // Meizu
                /droid.+; (m[1-5] note) bui/i,
                /\bmz-([-\w]{2,})/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Meizu"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                // MIXED
                /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
                /(hp) ([\w ]+\w)/i,
                /(asus)-?(\w+)/i,
                /(microsoft); (lumia[\w ]+)/i,
                /(lenovo)[-_ ]?([-\w]+)/i,
                /(jolla)/i,
                /(oppo) ?([\w ]+) bui/i // OPPO
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(kobo)\s(ereader|touch)/i,
                /(archos) (gamepad2?)/i,
                /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                /(kindle)\/([\w\.]+)/i,
                /(nook)[\w ]+build\/(\w+)/i,
                /(dell) (strea[kpr\d ]*[\dko])/i,
                /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                /(trinity)[- ]*(t\d{3}) bui/i,
                /(gigaset)[- ]+(q\w{1,9}) bui/i,
                /(vodafone) ([\w ]+)(?:\)| bui)/i // Vodafone
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(surface duo)/i // Surface Duo
            ],
            [
                MODEL,
                [
                    VENDOR,
                    MICROSOFT
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /droid [\d\.]+; (fp\du?)(?: b|\))/i // Fairphone
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Fairphone"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(u304aa)/i // AT&T
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "AT&T"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\bsie-(\w*)/i // Siemens
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Siemens"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(rct\w+) b/i // RCA Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "RCA"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(venue[\d ]{2,7}) b/i // Dell Venue Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Dell"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(q(?:mv|ta)\w+) b/i // Verizon Tablet
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Verizon"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i // Barnes & Noble Tablet
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Barnes & Noble"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(tm\d{3}\w+) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "NuVision"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(k88) b/i // ZTE K Series Tablet
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "ZTE"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(nx\d{3}j) b/i // ZTE Nubia
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "ZTE"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(gen\d{3}) b.+49h/i // Swiss GEN Mobile
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Swiss"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(zur\d{3}) b/i // Swiss ZUR Tablet
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Swiss"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((zeki)?tb.*\b) b/i // Zeki Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Zeki"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b([yr]\d{2}) b/i,
                /\b(dragon[- ]+touch |dt)(\w{5}) b/i // Dragon Touch Tablet
            ],
            [
                [
                    VENDOR,
                    "Dragon Touch"
                ],
                MODEL,
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(ns-?\w{0,9}) b/i // Insignia Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Insignia"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((nxa|next)-?\w{0,9}) b/i // NextBook Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "NextBook"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i // Voice Xtreme Phones
            ],
            [
                [
                    VENDOR,
                    "Voice"
                ],
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(lvtel\-)?(v1[12]) b/i // LvTel Phones
            ],
            [
                [
                    VENDOR,
                    "LvTel"
                ],
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(ph-1) /i // Essential PH-1
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Essential"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(v(100md|700na|7011|917g).*\b) b/i // Envizen Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Envizen"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(trio[-\w\. ]+) b/i // MachSpeed Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "MachSpeed"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\btu_(1491) b/i // Rotor Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Rotor"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(shield[\w ]+) b/i // Nvidia Shield Tablets
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Nvidia"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(sprint) (\w+)/i // Sprint Phones
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(kin\.[onetw]{3})/i // Microsoft Kin
            ],
            [
                [
                    MODEL,
                    /\./g,
                    " "
                ],
                [
                    VENDOR,
                    MICROSOFT
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i // Zebra
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ZEBRA
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ZEBRA
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                ///////////////////
                // SMARTTVS
                ///////////////////
                /smart-tv.+(samsung)/i // Samsung
            ],
            [
                VENDOR,
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /hbbtv.+maple;(\d+)/i
            ],
            [
                [
                    MODEL,
                    /^/,
                    "SmartTV"
                ],
                [
                    VENDOR,
                    SAMSUNG
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i // LG SmartTV
            ],
            [
                [
                    VENDOR,
                    LG
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /(apple) ?tv/i // Apple TV
            ],
            [
                VENDOR,
                [
                    MODEL,
                    APPLE + " TV"
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /crkey/i // Google Chromecast
            ],
            [
                [
                    MODEL,
                    CHROME + "cast"
                ],
                [
                    VENDOR,
                    GOOGLE
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /droid.+aft(\w)( bui|\))/i // Fire TV
            ],
            [
                MODEL,
                [
                    VENDOR,
                    AMAZON
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /\(dtv[\);].+(aquos)/i,
                /(aquos-tv[\w ]+)\)/i // Sharp
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SHARP
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /(bravia[\w ]+)( bui|\))/i // Sony
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SONY
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /(mitv-\w{5}) bui/i // Xiaomi
            ],
            [
                MODEL,
                [
                    VENDOR,
                    XIAOMI
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /Hbbtv.*(technisat) (.*);/i // TechniSAT
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i // HbbTV devices
            ],
            [
                [
                    VENDOR,
                    trim
                ],
                [
                    MODEL,
                    trim
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i // SmartTV from Unidentified Vendors
            ],
            [
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                ///////////////////
                // CONSOLES
                ///////////////////
                /(ouya)/i,
                /(nintendo) ([wids3utch]+)/i // Nintendo
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    CONSOLE
                ]
            ],
            [
                /droid.+; (shield) bui/i // Nvidia
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Nvidia"
                ],
                [
                    TYPE,
                    CONSOLE
                ]
            ],
            [
                /(playstation [345portablevi]+)/i // Playstation
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SONY
                ],
                [
                    TYPE,
                    CONSOLE
                ]
            ],
            [
                /\b(xbox(?: one)?(?!; xbox))[\); ]/i // Microsoft Xbox
            ],
            [
                MODEL,
                [
                    VENDOR,
                    MICROSOFT
                ],
                [
                    TYPE,
                    CONSOLE
                ]
            ],
            [
                ///////////////////
                // WEARABLES
                ///////////////////
                /((pebble))app/i // Pebble
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i // Apple Watch
            ],
            [
                MODEL,
                [
                    VENDOR,
                    APPLE
                ],
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                /droid.+; (glass) \d/i // Google Glass
            ],
            [
                MODEL,
                [
                    VENDOR,
                    GOOGLE
                ],
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                /droid.+; (wt63?0{2,3})\)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ZEBRA
                ],
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                /(quest( 2| pro)?)/i // Oculus Quest
            ],
            [
                MODEL,
                [
                    VENDOR,
                    FACEBOOK
                ],
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                ///////////////////
                // EMBEDDED
                ///////////////////
                /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i // Tesla
            ],
            [
                VENDOR,
                [
                    TYPE,
                    EMBEDDED
                ]
            ],
            [
                /(aeobc)\b/i // Echo Dot
            ],
            [
                MODEL,
                [
                    VENDOR,
                    AMAZON
                ],
                [
                    TYPE,
                    EMBEDDED
                ]
            ],
            [
                ////////////////////
                // MIXED (GENERIC)
                ///////////////////
                /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i // Android Phones from Unidentified Vendors
            ],
            [
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i // Android Tablets from Unidentified Vendors
            ],
            [
                MODEL,
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i // Unidentifiable Tablet
            ],
            [
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i // Unidentifiable Mobile
            ],
            [
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(android[-\w\. ]{0,9});.+buil/i // Generic Android Device
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Generic"
                ]
            ]
        ],
        engine: [
            [
                /windows.+ edge\/([\w\.]+)/i // EdgeHTML
            ],
            [
                VERSION,
                [
                    NAME,
                    EDGE + "HTML"
                ]
            ],
            [
                /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i // Blink
            ],
            [
                VERSION,
                [
                    NAME,
                    "Blink"
                ]
            ],
            [
                /(presto)\/([\w\.]+)/i,
                /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                /ekioh(flow)\/([\w\.]+)/i,
                /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                /(icab)[\/ ]([23]\.[\d\.]+)/i,
                /\b(libweb)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /rv\:([\w\.]{1,9})\b.+(gecko)/i // Gecko
            ],
            [
                VERSION,
                NAME
            ]
        ],
        os: [
            [
                // Windows
                /microsoft (windows) (vista|xp)/i // Windows (iTunes)
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(windows) nt 6\.2; (arm)/i,
                /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
            ],
            [
                NAME,
                [
                    VERSION,
                    strMapper,
                    windowsVersionMap
                ]
            ],
            [
                /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ],
            [
                [
                    NAME,
                    "Windows"
                ],
                [
                    VERSION,
                    strMapper,
                    windowsVersionMap
                ]
            ],
            [
                // iOS/macOS
                /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                /ios;fbsv\/([\d\.]+)/i,
                /cfnetwork\/.+darwin/i
            ],
            [
                [
                    VERSION,
                    /_/g,
                    "."
                ],
                [
                    NAME,
                    "iOS"
                ]
            ],
            [
                /(mac os x) ?([\w\. ]*)/i,
                /(macintosh|mac_powerpc\b)(?!.+haiku)/i // Mac OS
            ],
            [
                [
                    NAME,
                    MAC_OS
                ],
                [
                    VERSION,
                    /_/g,
                    "."
                ]
            ],
            [
                // Mobile OSes
                /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i // Android-x86/HarmonyOS
            ],
            [
                VERSION,
                NAME
            ],
            [
                /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                /(blackberry)\w*\/([\w\.]*)/i,
                /(tizen|kaios)[\/ ]([\w\.]+)/i,
                /\((series40);/i // Series 40
            ],
            [
                NAME,
                VERSION
            ],
            [
                /\(bb(10);/i // BlackBerry 10
            ],
            [
                VERSION,
                [
                    NAME,
                    BLACKBERRY
                ]
            ],
            [
                /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i // Symbian
            ],
            [
                VERSION,
                [
                    NAME,
                    "Symbian"
                ]
            ],
            [
                /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
            ],
            [
                VERSION,
                [
                    NAME,
                    FIREFOX + " OS"
                ]
            ],
            [
                /web0s;.+rt(tv)/i,
                /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i // WebOS
            ],
            [
                VERSION,
                [
                    NAME,
                    "webOS"
                ]
            ],
            [
                /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i // watchOS
            ],
            [
                VERSION,
                [
                    NAME,
                    "watchOS"
                ]
            ],
            [
                // Google Chromecast
                /crkey\/([\d\.]+)/i // Google Chromecast
            ],
            [
                VERSION,
                [
                    NAME,
                    CHROME + "cast"
                ]
            ],
            [
                /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i // Chromium OS
            ],
            [
                [
                    NAME,
                    CHROMIUM_OS
                ],
                VERSION
            ],
            [
                // Smart TVs
                /panasonic;(viera)/i,
                /(netrange)mmh/i,
                /(nettv)\/(\d+\.[\w\.]+)/i,
                // Console
                /(nintendo|playstation) ([wids345portablevuch]+)/i,
                /(xbox); +xbox ([^\);]+)/i,
                // Other
                /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                /(mint)[\/\(\) ]?(\w*)/i,
                /(mageia|vectorlinux)[; ]/i,
                /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
                /(hurd|linux) ?([\w\.]*)/i,
                /(gnu) ?([\w\.]*)/i,
                /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                /(haiku) (\w+)/i // Haiku
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(sunos) ?([\w\.\d]*)/i // Solaris
            ],
            [
                [
                    NAME,
                    "Solaris"
                ],
                VERSION
            ],
            [
                /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
                /(unix) ?([\w\.]*)/i // UNIX
            ],
            [
                NAME,
                VERSION
            ]
        ]
    };
    /////////////////
    // Constructor
    ////////////////
    var UAParser = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined;
        }
        if (!(this instanceof UAParser)) return new UAParser(ua, extensions).getResult();
        var _navigator = typeof window1 !== UNDEF_TYPE && window1.navigator ? window1.navigator : undefined;
        var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
            var _browser = {};
            _browser[NAME] = undefined;
            _browser[VERSION] = undefined;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser[MAJOR] = majorize(_browser[VERSION]);
            // Brave-specific detection
            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) _browser[NAME] = "Brave";
            return _browser;
        };
        this.getCPU = function() {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
        };
        this.getDevice = function() {
            var _device = {};
            _device[VENDOR] = undefined;
            _device[MODEL] = undefined;
            _device[TYPE] = undefined;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) _device[TYPE] = MOBILE;
            // iPadOS-specific detection: identified as Mac, but has some iOS-only properties
            if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
                _device[MODEL] = "iPad";
                _device[TYPE] = TABLET;
            }
            return _device;
        };
        this.getEngine = function() {
            var _engine = {};
            _engine[NAME] = undefined;
            _engine[VERSION] = undefined;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
        };
        this.getOS = function() {
            var _os = {};
            _os[NAME] = undefined;
            _os[VERSION] = undefined;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform != "Unknown") _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS); // backward compatibility
            return _os;
        };
        this.getResult = function() {
            return {
                ua: this.getUA(),
                browser: this.getBrowser(),
                engine: this.getEngine(),
                os: this.getOS(),
                device: this.getDevice(),
                cpu: this.getCPU()
            };
        };
        this.getUA = function() {
            return _ua;
        };
        this.setUA = function(ua) {
            _ua = typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH ? trim(ua, UA_MAX_LENGTH) : ua;
            return this;
        };
        this.setUA(_ua);
        return this;
    };
    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = enumerize([
        NAME,
        VERSION,
        MAJOR
    ]);
    UAParser.CPU = enumerize([
        ARCHITECTURE
    ]);
    UAParser.DEVICE = enumerize([
        MODEL,
        VENDOR,
        TYPE,
        CONSOLE,
        MOBILE,
        SMARTTV,
        TABLET,
        WEARABLE,
        EMBEDDED
    ]);
    UAParser.ENGINE = UAParser.OS = enumerize([
        NAME,
        VERSION
    ]);
    ///////////
    // Export
    //////////
    // check js environment
    if (typeof exports !== UNDEF_TYPE) {
        // nodejs env
        if ("object" !== UNDEF_TYPE && module.exports) exports = module.exports = UAParser;
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if (typeof define === FUNC_TYPE && define.amd) define(function() {
            return UAParser;
        });
        else if (typeof window1 !== UNDEF_TYPE) // browser env
        window1.UAParser = UAParser;
    }
    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = typeof window1 !== UNDEF_TYPE && (window1.jQuery || window1.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function() {
            return parser.getUA();
        };
        $.ua.set = function(ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for(var prop in result)$.ua[prop] = result[prop];
        };
    }
})(typeof window === "object" ? window : this);

},{}],"4dKvO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnknownMemberImpl", ()=>UnknownMemberImpl);
var _member = require("../../../member");
var _connection = require("./connection");
class UnknownMemberImpl extends (0, _member.MemberImpl) {
    type = "bot";
    side = "remote";
    _connections = {};
    constructor(args){
        super(args);
        this.plugin = args.plugin;
        this.subtype = args.subtype;
    }
    /**@private */ _getConnection(localPersonId) {
        return this._connections[localPersonId];
    }
    /**@private */ _getOrCreateConnection(localPerson) {
        const connection = this._getConnection(localPerson.id) ?? this._createConnection(localPerson, this);
        return connection;
    }
    _createConnection(localPerson, endpointMember) {
        return new (0, _connection.UnknownConnection)(localPerson, endpointMember);
    }
    _dispose() {}
}

},{"../../../member":"dkuHe","./connection":"gtddZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gtddZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnknownConnection", ()=>UnknownConnection);
var _common = require("@skyway-sdk/common");
const log = new (0, _common.Logger)("packages/core/src/plugin/internal/unknown/connection.ts");
class UnknownConnection {
    constructor(localPerson, remoteMember){
        this.localPerson = localPerson;
        this.remoteMember = remoteMember;
        this.type = "unknown";
        this.onDisconnect = new (0, _common.Event)();
        this.onClose = new (0, _common.Event)();
        this.closed = false;
    }
    close() {
        this.closed = true;
        this.onClose.emit();
    }
    async startPublishing(publication) {
        log.debug(`this is unknown type connection. should install ${this.remoteMember.subtype} plugin`, {
            publication
        });
    }
    async stopPublishing(publication) {
        log.debug(`this is unknown type connection. should install ${this.remoteMember.subtype} plugin`, {
            publication
        });
    }
    async startSubscribing(subscription) {
        log.debug(`this is unknown type connection. should install ${this.remoteMember.subtype} plugin`, {
            subscription
        });
    }
    async stopSubscribing(subscription) {
        log.debug(`this is unknown type connection. should install ${this.remoteMember.subtype} plugin`, {
            subscription
        });
    }
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3aobm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "PublicationImpl", ()=>PublicationImpl);
parcelHelpers.export(exports, "normalizeEncodings", ()=>normalizeEncodings);
parcelHelpers.export(exports, "sortEncodingParameters", ()=>sortEncodingParameters);
var _common = require("@skyway-sdk/common");
var _errors = require("../errors");
var _data = require("../media/stream/local/data");
var _util = require("../util");
var _factory = require("./factory");
parcelHelpers.exportAll(_factory, exports);
const log = new (0, _common.Logger)("packages/core/src/publication/index.ts");
class PublicationImpl {
    _codecCapabilities = [];
    get codecCapabilities() {
        return this._codecCapabilities;
    }
    setCodecCapabilities(_codecCapabilities) {
        this._codecCapabilities = _codecCapabilities;
    }
    _encodings = [];
    get encodings() {
        return this._encodings;
    }
    setEncodings(_encodings) {
        this._encodings = _encodings;
    }
    get stream() {
        return this._stream;
    }
    /**@internal */ _setStream(stream) {
        this._stream = stream;
        if (stream) stream._onConnectionStateChanged.add((e)=>{
            log.debug("onConnectionStateChanged", this.id, e);
            this.onConnectionStateChanged.emit(e);
        }).disposer(this.streamEventDisposer);
        else this.streamEventDisposer.dispose();
    }
    get metadata() {
        return this._metadata;
    }
    _state = "enabled";
    get state() {
        return this._state;
    }
    get deviceName() {
        if (this.stream instanceof (0, _data.LocalDataStream)) return undefined;
        else {
            const withDeviceStream = this.stream;
            return withDeviceStream.track.label;
        }
    }
    _events = new (0, _common.Events)();
    onCanceled = this._events.make();
    onSubscribed = this._events.make();
    onUnsubscribed = this._events.make();
    onSubscriptionListChanged = this._events.make();
    onMetadataUpdated = this._events.make();
    onEnabled = this._events.make();
    onDisabled = this._events.make();
    onStateChanged = this._events.make();
    onConnectionStateChanged = new (0, _common.Event)();
    /**@private */ _onEncodingsChanged = this._events.make();
    /**@private */ _onReplaceStream = this._events.make();
    _onEnabled = this._events.make();
    streamEventDisposer = new (0, _common.EventDisposer)();
    constructor(args){
        this.id = args.id;
        this._channel = args.channel;
        this._context = this._channel._context;
        this.publisher = args.publisher;
        this.contentType = args.contentType;
        this._metadata = args.metadata;
        this.origin = args.origin;
        this.setCodecCapabilities(args.codecCapabilities ?? []);
        this.setEncodings(normalizeEncodings(args.encodings ?? []));
        this._state = args.isEnabled ? "enabled" : "disabled";
        if (args.stream) this._setStream(args.stream);
        this._analytics = this._channel.localPerson?._analytics;
        log.debug("publication spawned", this.toJSON());
    }
    get subscriptions() {
        return this._channel.subscriptions.filter((s)=>s.publication.id === this.id);
    }
    /**@private */ _updateMetadata(metadata) {
        this._metadata = metadata;
        this.onMetadataUpdated.emit({
            metadata
        });
    }
    /**@private */ async _disable() {
        await this._disableStream();
        this.onDisabled.emit();
        this.onStateChanged.emit();
    }
    /**@private */ _enable() {
        if (this.stream) this._onEnabled.emit();
        else {
            this._state = "enabled";
            this.onEnabled.emit();
            this.onStateChanged.emit();
        }
    }
    /**@private */ _unpublished() {
        this._state = "canceled";
        if (this.stream) this.stream._unpublished();
        this.onCanceled.emit();
        this.onStateChanged.emit();
        this._dispose();
    }
    /**@private */ _subscribed(subscription) {
        this.onSubscribed.emit({
            subscription
        });
        this.onSubscriptionListChanged.emit();
    }
    /**@private */ _unsubscribed(subscription) {
        this.onUnsubscribed.emit({
            subscription
        });
        this.onSubscriptionListChanged.emit();
    }
    cancel = ()=>new Promise((r, f)=>{
            let failed = false;
            this._channel._unpublish(this.id).catch((e)=>{
                failed = true;
                f(e);
            });
            this._setStream(undefined);
            this.onCanceled.asPromise(this._context.config.rtcApi.timeout).then(()=>r()).catch((e)=>{
                if (!failed) f(e);
            });
        });
    updateMetadata = (metadata)=>new Promise(async (r, f)=>{
            const timestamp = log.info("[start] updateMetadata", await (0, _util.createLogPayload)({
                operationName: "Publication.updateMetadata",
                channel: this._channel
            }), this);
            let failed = false;
            this._channel._updatePublicationMetadata(this.id, metadata).catch((e)=>{
                failed = true;
                f(e);
            });
            this.onMetadataUpdated.watch((e)=>e.metadata === metadata, this._context.config.rtcApi.timeout).then(async ()=>{
                r();
                log.elapsed(timestamp, "[end] updateMetadata", await (0, _util.createLogPayload)({
                    operationName: "Publication.updateMetadata",
                    channel: this._channel
                }), this);
            }).catch((error)=>{
                if (!failed) throw (0, _util.createError)({
                    operationName: "PublicationImpl.updateMetadata",
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "publication onMetadataUpdated"
                    },
                    path: log.prefix,
                    context: this._context,
                    channel: this._channel,
                    error
                });
            });
        });
    updateEncodings(encodings) {
        log.info("updateEncodings", {
            encodings
        }, this);
        this.setEncodings(normalizeEncodings(sortEncodingParameters(encodings)));
        this._onEncodingsChanged.emit(encodings);
        if (this._analytics && !this._analytics.isClosed()) this._analytics.client.sendPublicationUpdateEncodingsReport({
            publicationId: this.id,
            encodings: this.encodings,
            updatedAt: Date.now()
        });
    }
    disable = ()=>new Promise(async (r, f)=>{
            const timestamp = log.info("[start] disable", await (0, _util.createLogPayload)({
                operationName: "Publication.disable",
                channel: this._channel
            }), this);
            await this._disableStream();
            let failed = false;
            this._channel._disablePublication(this.id).catch((e)=>{
                failed = true;
                f(e);
            });
            this.onDisabled.asPromise(this._context.config.rtcApi.timeout).then(async ()=>{
                r();
                log.elapsed(timestamp, "[end] disable", await (0, _util.createLogPayload)({
                    operationName: "Publication.disable",
                    channel: this._channel
                }), this);
            }).catch((e)=>{
                if (!failed) f(e);
            });
        });
    async _disableStream() {
        if (this.state === "disabled") return;
        this._state = "disabled";
        if (!this.stream) return;
        if (this.stream.contentType === "data") this.stream.setIsEnabled(false);
        else await this.stream.setEnabled(false).catch((e)=>{
            log.warn((0, _util.createWarnPayload)({
                channel: this._channel,
                operationName: "Publication._disableStream",
                payload: e,
                detail: "setEnabled failed"
            }));
        });
        (0, _util.createLogPayload)({
            operationName: "Publication._disableStream",
            channel: this._channel
        }).then((p)=>log.info("publication _disableStream", p, {
                publication: this
            })).catch(()=>{});
    }
    enable = ()=>new Promise(async (r, f)=>{
            if (this.stream == undefined) {
                f((0, _util.createError)({
                    operationName: "Publication.enable",
                    context: this._context,
                    info: (0, _errors.errors).canNotEnableRemotePublication,
                    path: log.prefix
                }));
                return;
            }
            const timestamp = log.info("[start] enable", await (0, _util.createLogPayload)({
                operationName: "Publication.enable",
                channel: this._channel
            }), this);
            let failed = false;
            this._channel._enablePublication(this.id).catch((e)=>{
                failed = true;
                f(e);
            });
            this._onEnabled.asPromise(this._context.config.rtcApi.timeout).then(async ()=>{
                await this._enableStream();
                this.onEnabled.emit();
                this.onStateChanged.emit();
                log.elapsed(timestamp, "[end] enable", await (0, _util.createLogPayload)({
                    operationName: "Publication.enable",
                    channel: this._channel
                }), this);
                r();
            }).catch((e)=>{
                if (!failed) f(e);
            });
        });
    async _enableStream() {
        if (this.state === "enabled") return;
        this._state = "enabled";
        if (!this.stream) return;
        (0, _util.createLogPayload)({
            operationName: "Publication._enableStream",
            channel: this._channel
        }).then((p)=>log.info("publication _enableStream", p, {
                publication: this
            })).catch(()=>{});
        if (this.stream.contentType === "data") this.stream.setIsEnabled(true);
        else await this.stream.setEnabled(true).catch((e)=>{
            log.warn((0, _util.createWarnPayload)({
                channel: this._channel,
                operationName: "Publication._disableStream",
                payload: e,
                detail: "setEnabled failed"
            }));
        });
    }
    replaceStream(stream, options = {}) {
        log.info("replaceStream", {
            stream,
            options
        }, this);
        if (!this.stream) throw (0, _util.createError)({
            operationName: "PublicationImpl.replaceStream",
            context: this._context,
            info: (0, _errors.errors).canNotUseReplaceStream,
            path: log.prefix
        });
        if (stream.contentType !== this.contentType) throw (0, _util.createError)({
            operationName: "PublicationImpl.replaceStream",
            context: this._context,
            info: (0, _errors.errors).invalidContentType,
            path: log.prefix
        });
        if (options.releaseOldStream ?? true) {
            const old = this.stream;
            old.release();
        }
        (0, _util.createLogPayload)({
            operationName: "PublicationImpl.replaceStream",
            channel: this._channel
        }).then((res)=>log.debug(res, {
                old: this.stream,
                new: stream
            })).catch((e)=>e);
        stream.setEnabled(this.stream.isEnabled).catch((e)=>{
            log.error("replaceStream stream.setEnabled", e, this.toJSON());
        });
        const oldStream = this._stream;
        this._setStream(stream);
        this._onReplaceStream.emit({
            newStream: stream,
            oldStream
        });
        if (this._analytics && !this._analytics.isClosed()) this._analytics.client.sendMediaDeviceReport({
            publicationId: this.id,
            mediaDeviceName: this.deviceName,
            mediaDeviceTrigger: "replaceStream",
            updatedAt: Date.now()
        });
    }
    getStats(selector) {
        if (!this.stream) throw (0, _util.createError)({
            operationName: "PublicationImpl.getStats",
            context: this._context,
            info: (0, _errors.errors).streamNotExistInSubscription,
            path: log.prefix
        });
        return this.stream._getStats(selector);
    }
    getRTCPeerConnection(selector) {
        if (!this.stream) throw (0, _util.createError)({
            operationName: "PublicationImpl.getRTCPeerConnection",
            context: this._context,
            info: (0, _errors.errors).streamNotExistInSubscription,
            path: log.prefix
        });
        return this.stream._getRTCPeerConnection(selector);
    }
    getConnectionState(selector) {
        if (!this.stream) throw (0, _util.createError)({
            operationName: "PublicationImpl.getConnectionState",
            context: this._context,
            info: (0, _errors.errors).streamNotExistInSubscription,
            path: log.prefix
        });
        return this.stream._getConnectionState(selector);
    }
    /**@private */ toJSON() {
        return {
            id: this.id,
            channelId: this._channel.id,
            publisherId: this.publisher.id,
            origin: this.origin?.id,
            contentType: this.contentType,
            metadata: this.metadata,
            codecCapabilities: this.codecCapabilities,
            encodings: this.encodings,
            state: this.state,
            stream: this.stream
        };
    }
    _dispose() {
        this._events.dispose();
    }
}
const normalizeEncodings = (encodings)=>encodings.map((e, i)=>({
            ...e,
            id: e.id ?? i.toString()
        }));
const sortEncodingParameters = (encodings)=>{
    const [encode] = encodings;
    if (encode.maxBitrate) // 小から大
    return encodings.sort((a, b)=>a.maxBitrate - b.maxBitrate);
    else if (encode.scaleResolutionDownBy) //大から小
    return encodings.sort((a, b)=>b.scaleResolutionDownBy - a.scaleResolutionDownBy);
    else if (encode.maxFramerate) // 小から大
    return encodings.sort((a, b)=>a.maxFramerate - b.maxFramerate);
    return encodings;
};

},{"@skyway-sdk/common":"3hyrG","../errors":"gDbIj","../media/stream/local/data":"T39q0","../util":"ey5Lv","./factory":"kiBCx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"T39q0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalDataStream", ()=>LocalDataStream);
parcelHelpers.export(exports, "objectFlag", ()=>objectFlag);
var _common = require("@skyway-sdk/common");
var _errors = require("../../../errors");
var _util = require("../../../util");
var _ = require(".");
const log = new (0, _common.Logger)("packages/core/src/media/stream/local/data.ts");
class LocalDataStream extends (0, _.LocalStreamBase) {
    constructor(options = {}){
        super("data");
        this.options = options;
        this.contentType = "data";
        this._onWriteData = new (0, _common.Event)();
        this._isEnabled = true;
        this._setLabel("LocalDataStream");
    }
    get isEnabled() {
        return this._isEnabled;
    }
    /**@internal */ setIsEnabled(b) {
        this._isEnabled = b;
    }
    /**@description [japanese] データを送信する */ write(data) {
        if (!this._isEnabled) throw (0, _util.createError)({
            operationName: "LocalDataStream.write",
            path: log.prefix,
            info: (0, _errors.errors).disabledDataStream
        });
        if (!ArrayBuffer.isView(data) && !(typeof data === "string")) data = objectFlag + JSON.stringify(data);
        this._onWriteData.emit(data);
    }
}
const objectFlag = "skyway_object:";

},{"@skyway-sdk/common":"3hyrG","../../../errors":"gDbIj","../../../util":"ey5Lv",".":"gov7A","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gov7A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalAudioStream", ()=>(0, _audio.LocalAudioStream));
parcelHelpers.export(exports, "LocalCustomVideoStream", ()=>(0, _customVideo.LocalCustomVideoStream));
parcelHelpers.export(exports, "LocalDataStream", ()=>(0, _data.LocalDataStream));
parcelHelpers.export(exports, "LocalMediaStreamBase", ()=>(0, _media.LocalMediaStreamBase));
parcelHelpers.export(exports, "LocalMediaStreamOptions", ()=>(0, _media.LocalMediaStreamOptions));
parcelHelpers.export(exports, "LocalStreamBase", ()=>(0, _base.LocalStreamBase));
parcelHelpers.export(exports, "LocalVideoStream", ()=>(0, _video.LocalVideoStream));
var _audio = require("./audio");
var _base = require("./base");
var _customVideo = require("./customVideo");
var _data = require("./data");
var _media = require("./media");
var _video = require("./video");

},{"./audio":"bIWhI","./base":"8CsEC","./customVideo":"1Q3u4","./data":"T39q0","./media":"fGBzU","./video":"hcUYM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bIWhI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalAudioStream", ()=>LocalAudioStream);
var _common = require("@skyway-sdk/common");
var _errors = require("../../../errors");
var _util = require("../../../util");
var _media = require("./media");
const log = new (0, _common.Logger)("packages/core/src/media/stream/local/audio.ts");
class LocalAudioStream extends (0, _media.LocalMediaStreamBase) {
    contentType = "audio";
    _isEnabled = true;
    _promiseQueue = new (0, _common.PromiseQueue)();
    constructor(track, options = {}){
        super(track, "audio", options);
        if (track.kind !== "audio") throw (0, _util.createError)({
            operationName: "LocalAudioStream.constructor",
            path: log.prefix,
            info: (0, _errors.errors).invalidTrackKind,
            payload: {
                track
            }
        });
    }
    /**@internal */ async setEnabled(enabled) {
        await this._promiseQueue.push(async ()=>{
            // mute
            if (this._isEnabled === true && enabled === false) {
                this._isEnabled = enabled;
                this._disable("audio");
                log.debug("stopped");
            } else if (this._isEnabled === false && enabled === true) {
                this._isEnabled = enabled;
                if (this._options.stopTrackWhenDisabled) {
                    const track = this._options.isDisplayMedia === true ? await this.enableDisplay() : await this.enableMic();
                    this._updateTrack(track);
                    this._onEnableChanged.emit(track);
                } else if (this._oldTrack) {
                    this._updateTrack(this._oldTrack);
                    this._onEnableChanged.emit(this._oldTrack);
                }
                log.debug("resumed");
            }
        });
    }
    get isEnabled() {
        return this._isEnabled;
    }
    async enableMic() {
        const [track] = (await navigator.mediaDevices.getUserMedia({
            audio: this.trackConstraints
        })).getAudioTracks();
        return track;
    }
    async enableDisplay() {
        const [track] = (await navigator.mediaDevices.getDisplayMedia({
            audio: this.trackConstraints
        })).getAudioTracks();
        return track;
    }
}

},{"@skyway-sdk/common":"3hyrG","../../../errors":"gDbIj","../../../util":"ey5Lv","./media":"fGBzU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fGBzU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalMediaStreamBase", ()=>LocalMediaStreamBase);
parcelHelpers.export(exports, "emptyAudioTrack", ()=>emptyAudioTrack);
parcelHelpers.export(exports, "emptyVideoTrack", ()=>emptyVideoTrack);
var _common = require("@skyway-sdk/common");
var _base = require("../base");
var _base1 = require("./base");
const logger = new (0, _common.Logger)("packages/core/src/media/stream/local/media.ts");
class LocalMediaStreamBase extends (0, _base1.LocalStreamBase) {
    /**@description [japanese] PublicationのDisable/EnableなどでStreamのtrackが更新された時に発火するイベント */ onTrackUpdated = new (0, _common.Event)();
    /**
   * @description [japanese] streamが破棄された時に発火するイベント (例. 画面共有が終了したときなど)
   * @example [japanese] ハンドリング例
   *  const publication = await member.publish(audio);
      audio.onDestroyed.once(async () => {
        await member.unpublish(publication);
      });
   * */ onDestroyed = new (0, _common.Event)();
    _disposer = new (0, _common.EventDisposer)();
    _trackConstraints = {};
    /**@internal */ get trackConstraints() {
        return this._trackConstraints;
    }
    /**@internal */ _replacingTrack = false;
    /**@internal */ _onReplacingTrackDone = new (0, _common.Event)();
    /**@internal */ _onEnableChanged = new (0, _common.Event)();
    toJSON() {
        const base = super.toJSON();
        return {
            ...base,
            trackConstraints: this.trackConstraints,
            isEnabled: this.isEnabled,
            _options: this._options
        };
    }
    constructor(track, contentType, /**@internal */ options = {}){
        super(contentType);
        this._track = track;
        this._listenTrackEvent();
        this._options = options;
        // iOS safari 15はgetConstraintsがバグってるのでここで入れておく
        this._trackConstraints = {
            ...options
        };
    }
    get track() {
        return this._track;
    }
    /**
   * @description [english] Attach the stream to the element.
   * @description [japanese] streamをelementに適用する.
   */ attach(element) {
        this._element = element;
        (0, _base.attachElement)(element, this._track);
    }
    /**
   * @description [english] Detach the stream from the element.
   * @description [japanese] elementからstreamを取り除く.
   */ detach() {
        if (this._element) {
            (0, _base.detachElement)(this._element, this._track);
            this._element = undefined;
        }
    }
    /**@internal */ _disable(kind) {
        if (this._options.stopTrackWhenDisabled) {
            this._trackConstraints = {
                ...this.trackConstraints,
                ...this.track.getConstraints()
            };
            this.track.stop();
        } else this._oldTrack = this.track;
        const track = kind === "video" ? emptyVideoTrack : emptyAudioTrack;
        track.enabled = false;
        this._onEnableChanged.emit(track);
        this._updateTrack(track);
    }
    /**@internal */ _updateTrack(track) {
        this._track = track;
        if (this._element) this.attach(this._element);
        this.onTrackUpdated.emit(track);
        this._listenTrackEvent();
    }
    _listenTrackEvent() {
        const onended = ()=>{
            logger.info("onDestroyed", this.toJSON());
            this.onDestroyed.emit();
        };
        this._track.addEventListener("ended", onended);
        this._disposer.push(()=>this._track.removeEventListener("ended", onended));
    }
    /**
   * @description [japanese] Streamを解放します。
   * カメラやマイクなどのデバイスを解放するためにはそのデバイスに関連するすべてのStreamを解放する必要があります
   */ release() {
        this._disposer.dispose();
        this._track.stop();
    }
}
const createEmptyTrack = new RTCPeerConnection();
const emptyAudioTrack = createEmptyTrack.addTransceiver("audio").receiver.track;
const emptyVideoTrack = createEmptyTrack.addTransceiver("video").receiver.track;

},{"@skyway-sdk/common":"3hyrG","../base":"6o4hs","./base":"8CsEC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6o4hs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "attachElement", ()=>attachElement);
/**@internal */ parcelHelpers.export(exports, "detachElement", ()=>detachElement);
var _common = require("@skyway-sdk/common");
var _errors = require("../../errors");
var _util = require("../../util");
const log = new (0, _common.Logger)("packages/core/src/media/stream/base.ts");
function attachElement(element, track) {
    if ((element ?? {})?.srcObject === undefined) throw (0, _util.createError)({
        operationName: "attachElement",
        info: (0, _errors.errors).invalidElement,
        payload: {
            element
        },
        path: log.prefix
    });
    if (element.srcObject) {
        const stream = element.srcObject;
        const ended = stream.getTracks().find((t)=>t.readyState === "ended");
        if (ended) stream.removeTrack(ended);
        const duplicate = stream.getTracks().find((t)=>t.kind === track.kind);
        if (duplicate) stream.removeTrack(duplicate);
        stream.addTrack(track);
    } else element.srcObject = new MediaStream([
        track
    ]);
}
function detachElement(element, track) {
    if ((element ?? {})?.srcObject === undefined) throw (0, _util.createError)({
        operationName: "attachElement",
        info: (0, _errors.errors).invalidElement,
        payload: {
            element
        },
        path: log.prefix
    });
    const stream = element.srcObject;
    if (stream.getTracks().length > 0) stream.removeTrack(track);
    if (stream.getTracks().length === 0) element.srcObject = null;
}

},{"@skyway-sdk/common":"3hyrG","../../errors":"gDbIj","../../util":"ey5Lv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8CsEC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalStreamBase", ()=>LocalStreamBase);
var _common = require("@skyway-sdk/common");
var _token = require("@skyway-sdk/token");
class LocalStreamBase {
    /**@internal */ constructor(contentType){
        this.contentType = contentType;
        this.side = "local";
        this.onConnectionStateChanged = new (0, _common.Event)();
        this._onConnectionStateChanged = new (0, _common.Event)();
        this.id = (0, _token.uuidV4)();
        this./**@internal */ _label = "";
        this.published = false;
        this./**@private */ _getTransportCallbacks = {};
        this./**@private */ _getStatsCallbacks = {};
        this._connectionState = {};
        this._onConnectionStateChanged.pipe(this.onConnectionStateChanged);
    }
    /**@internal */ _setLabel(label) {
        this._label = label;
    }
    /**@internal */ _unpublished() {
        this.published = false;
        this._getTransportCallbacks = {};
        this._getStatsCallbacks = {};
    }
    /**@internal */ _getTransport(selector) {
        const id = typeof selector === "string" ? selector : selector.id;
        return this._getTransportCallbacks[id]?.();
    }
    /**@internal */ _setConnectionState(remoteMember, state) {
        if (this._connectionState[remoteMember.id] === state) return;
        this._connectionState[remoteMember.id] = state;
        this._onConnectionStateChanged.emit({
            remoteMember,
            state
        });
    }
    /**
   * @deprecated
   * @use Publication.getStats
   */ getStats(selector) {
        return this._getStats(selector);
    }
    /**@internal */ _getStats(selector) {
        const id = typeof selector === "string" ? selector : selector.id;
        return this._getStatsCallbacks[id]?.() ?? [];
    }
    /**@internal */ _getStatsAll() {
        return Promise.all(Object.entries(this._getStatsCallbacks).map(async ([key, cb])=>({
                memberId: key,
                stats: await cb().catch(()=>[])
            })));
    }
    /**
   * @deprecated
   * @use Publication.getRTCPeerConnection
   */ getRTCPeerConnection(selector) {
        return this._getRTCPeerConnection(selector);
    }
    /**@internal */ _getRTCPeerConnection(selector) {
        return this._getTransport(selector)?.rtcPeerConnection;
    }
    /**
   * @deprecated
   * @use Publication.getConnectionState
   */ getConnectionState(selector) {
        return this._getConnectionState(selector);
    }
    /**@internal */ _getConnectionState(selector) {
        const id = typeof selector === "string" ? selector : selector.id;
        return this._connectionState[id] ?? "new";
    }
    /**@internal */ _getConnectionStateAll() {
        return Object.keys(this._getTransportCallbacks).map((memberId)=>({
                memberId,
                connectionState: this._getConnectionState(memberId)
            }));
    }
    /**@internal */ toJSON() {
        return {
            label: this._label,
            contentType: this.contentType,
            id: this.id,
            side: this.side
        };
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/token":"1nlc7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1nlc7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uuidV4", ()=>uuidV4);
var _uuid = require("uuid");
var _encoder = require("./encoder");
parcelHelpers.exportAll(_encoder, exports);
var _app = require("./scope/app");
parcelHelpers.exportAll(_app, exports);
var _sfu = require("./scope/sfu");
parcelHelpers.exportAll(_sfu, exports);
var _token = require("./token");
parcelHelpers.exportAll(_token, exports);
var _errors = require("./errors");
parcelHelpers.exportAll(_errors, exports);
var _util = require("./util");
parcelHelpers.exportAll(_util, exports);
/**@internal */ const uuidV4 = (0, _uuid.v4);

},{"uuid":"1IPXO","./encoder":"9GRO4","./scope/app":"jXmGY","./scope/sfu":"3G1of","./token":"9fPcb","./errors":"eXUkm","./util":"nALhG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1IPXO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":false,"./v3.js":false,"./v4.js":"lTqhR","./v5.js":false,"./nil.js":false,"./version.js":false,"./validate.js":"8QFCQ","./stringify.js":"gqsvj","./parse.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lTqhR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeJs = require("./native.js");
var _nativeJsDefault = parcelHelpers.interopDefault(_nativeJs);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
function v4(options, buf, offset) {
    if ((0, _nativeJsDefault.default).randomUUID && !buf && !options) return (0, _nativeJsDefault.default).randomUUID();
    options = options || {};
    const rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJs.unsafeStringify)(rnds);
}
exports.default = v4;

},{"./native.js":"6E0P1","./rng.js":"jt2oY","./stringify.js":"gqsvj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6E0P1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports.default = {
    randomUUID
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jt2oY":[function(require,module,exports) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return getRandomValues(rnds8);
}
exports.default = rng;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gqsvj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeStringify", ()=>unsafeStringify);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"8QFCQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8QFCQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === "string" && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"bOZfq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bOZfq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9GRO4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SkyWayAuthToken", ()=>SkyWayAuthToken);
var _common = require("@skyway-sdk/common");
var _jsrsasign = require("jsrsasign");
var _jsrsasignDefault = parcelHelpers.interopDefault(_jsrsasign);
var _jwtDecode = require("jwt-decode");
var _jwtDecodeDefault = parcelHelpers.interopDefault(_jwtDecode);
var _ = require(".");
const log = new (0, _common.Logger)("packages/token/src/encoder.ts");
class SkyWayAuthToken {
    constructor(props){
        Object.assign(this, props);
    }
    static Decode(token) {
        try {
            const props = (0, _jwtDecodeDefault.default)(token);
            const authToken = new SkyWayAuthToken(props);
            authToken.tokenString = token;
            return authToken;
        } catch (error) {
            throw new (0, _common.SkyWayError)({
                path: log.prefix,
                info: (0, _.tokenErrors).invalidParameter,
                error
            });
        }
    }
    encode(secret) {
        const payload = {
            jti: this.jti,
            iat: this.iat,
            exp: this.exp,
            scope: this.scope,
            version: this.version
        };
        this.tokenString = (0, _jsrsasignDefault.default).KJUR.jws.JWS.sign("HS256", JSON.stringify({
            alg: "HS256",
            typ: "JWT"
        }), JSON.stringify(payload), secret);
        return this.tokenString;
    }
    /**@internal */ toJSON() {
        return {
            jti: this.jti,
            iat: this.iat,
            exp: this.exp,
            scope: this.scope,
            encoded: this.tokenString,
            version: this.version
        };
    }
}

},{"@skyway-sdk/common":"3hyrG","jsrsasign":"7nfoF","jwt-decode":"ljM1w",".":"1nlc7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7nfoF":[function(require,module,exports) {
var Buffer = require("c47b943a373324d0").Buffer;
var navigator = {};
navigator.userAgent = false;
var window = {};
/*
 * jsrsasign(all) 11.0.0 (2024-01-16) (c) 2010-2023 Kenji Urushima | kjur.github.io/jsrsasign/license
 */ var VERSION = "11.0.0";
var VERSION_FULL = "jsrsasign(all) 11.0.0 (2024-01-16) (c) 2010-2023 Kenji Urushima | kjur.github.io/jsrsasign/license";
/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */ var CryptoJS = CryptoJS || function(e, g) {
    var a = {};
    var b = a.lib = {};
    var j = b.Base = function() {
        function n() {}
        return {
            extend: function(p) {
                n.prototype = this;
                var o = new n();
                if (p) o.mixIn(p);
                if (!o.hasOwnProperty("init")) o.init = function() {
                    o.$super.init.apply(this, arguments);
                };
                o.init.prototype = o;
                o.$super = this;
                return o;
            },
            create: function() {
                var o = this.extend();
                o.init.apply(o, arguments);
                return o;
            },
            init: function() {},
            mixIn: function(p) {
                for(var o in p)if (p.hasOwnProperty(o)) this[o] = p[o];
                if (p.hasOwnProperty("toString")) this.toString = p.toString;
            },
            clone: function() {
                return this.init.prototype.extend(this);
            }
        };
    }();
    var l = b.WordArray = j.extend({
        init: function(o, n) {
            o = this.words = o || [];
            if (n != g) this.sigBytes = n;
            else this.sigBytes = o.length * 4;
        },
        toString: function(n) {
            return (n || h).stringify(this);
        },
        concat: function(t) {
            var q = this.words;
            var p = t.words;
            var n = this.sigBytes;
            var s = t.sigBytes;
            this.clamp();
            if (n % 4) for(var r = 0; r < s; r++){
                var o = p[r >>> 2] >>> 24 - r % 4 * 8 & 255;
                q[n + r >>> 2] |= o << 24 - (n + r) % 4 * 8;
            }
            else for(var r = 0; r < s; r += 4)q[n + r >>> 2] = p[r >>> 2];
            this.sigBytes += s;
            return this;
        },
        clamp: function() {
            var o = this.words;
            var n = this.sigBytes;
            o[n >>> 2] &= 4294967295 << 32 - n % 4 * 8;
            o.length = e.ceil(n / 4);
        },
        clone: function() {
            var n = j.clone.call(this);
            n.words = this.words.slice(0);
            return n;
        },
        random: function(p) {
            var o = [];
            for(var n = 0; n < p; n += 4)o.push(e.random() * 4294967296 | 0);
            return new l.init(o, p);
        }
    });
    var m = a.enc = {};
    var h = m.Hex = {
        stringify: function(p) {
            var r = p.words;
            var o = p.sigBytes;
            var q = [];
            for(var n = 0; n < o; n++){
                var s = r[n >>> 2] >>> 24 - n % 4 * 8 & 255;
                q.push((s >>> 4).toString(16));
                q.push((s & 15).toString(16));
            }
            return q.join("");
        },
        parse: function(p) {
            var n = p.length;
            var q = [];
            for(var o = 0; o < n; o += 2)q[o >>> 3] |= parseInt(p.substr(o, 2), 16) << 24 - o % 8 * 4;
            return new l.init(q, n / 2);
        }
    };
    var d = m.Latin1 = {
        stringify: function(q) {
            var r = q.words;
            var p = q.sigBytes;
            var n = [];
            for(var o = 0; o < p; o++){
                var s = r[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                n.push(String.fromCharCode(s));
            }
            return n.join("");
        },
        parse: function(p) {
            var n = p.length;
            var q = [];
            for(var o = 0; o < n; o++)q[o >>> 2] |= (p.charCodeAt(o) & 255) << 24 - o % 4 * 8;
            return new l.init(q, n);
        }
    };
    var c = m.Utf8 = {
        stringify: function(n) {
            try {
                return decodeURIComponent(escape(d.stringify(n)));
            } catch (o) {
                throw new Error("Malformed UTF-8 data");
            }
        },
        parse: function(n) {
            return d.parse(unescape(encodeURIComponent(n)));
        }
    };
    var i = b.BufferedBlockAlgorithm = j.extend({
        reset: function() {
            this._data = new l.init();
            this._nDataBytes = 0;
        },
        _append: function(n) {
            if (typeof n == "string") n = c.parse(n);
            this._data.concat(n);
            this._nDataBytes += n.sigBytes;
        },
        _process: function(w) {
            var q = this._data;
            var x = q.words;
            var n = q.sigBytes;
            var t = this.blockSize;
            var v = t * 4;
            var u = n / v;
            if (w) u = e.ceil(u);
            else u = e.max((u | 0) - this._minBufferSize, 0);
            var s = u * t;
            var r = e.min(s * 4, n);
            if (s) {
                for(var p = 0; p < s; p += t)this._doProcessBlock(x, p);
                var o = x.splice(0, s);
                q.sigBytes -= r;
            }
            return new l.init(o, r);
        },
        clone: function() {
            var n = j.clone.call(this);
            n._data = this._data.clone();
            return n;
        },
        _minBufferSize: 0
    });
    var f = b.Hasher = i.extend({
        cfg: j.extend(),
        init: function(n) {
            this.cfg = this.cfg.extend(n);
            this.reset();
        },
        reset: function() {
            i.reset.call(this);
            this._doReset();
        },
        update: function(n) {
            this._append(n);
            this._process();
            return this;
        },
        finalize: function(n) {
            if (n) this._append(n);
            var o = this._doFinalize();
            return o;
        },
        blockSize: 16,
        _createHelper: function(n) {
            return function(p, o) {
                return new n.init(o).finalize(p);
            };
        },
        _createHmacHelper: function(n) {
            return function(p, o) {
                return new k.HMAC.init(n, o).finalize(p);
            };
        }
    });
    var k = a.algo = {};
    return a;
}(Math);
/*
CryptoJS v3.1.2 x64-core-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function(g) {
    var a = CryptoJS, f = a.lib, e = f.Base, h = f.WordArray, a = a.x64 = {};
    a.Word = e.extend({
        init: function(b, c) {
            this.high = b;
            this.low = c;
        }
    });
    a.WordArray = e.extend({
        init: function(b, c) {
            b = this.words = b || [];
            this.sigBytes = c != g ? c : 8 * b.length;
        },
        toX32: function() {
            for(var b = this.words, c = b.length, a = [], d = 0; d < c; d++){
                var e = b[d];
                a.push(e.high);
                a.push(e.low);
            }
            return h.create(a, this.sigBytes);
        },
        clone: function() {
            for(var b = e.clone.call(this), c = b.words = this.words.slice(0), a = c.length, d = 0; d < a; d++)c[d] = c[d].clone();
            return b;
        }
    });
})();
/*
CryptoJS v3.1.2 cipher-core.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ CryptoJS.lib.Cipher || function(u) {
    var g = CryptoJS, f = g.lib, k = f.Base, l = f.WordArray, q = f.BufferedBlockAlgorithm, r = g.enc.Base64, v = g.algo.EvpKDF, n = f.Cipher = q.extend({
        cfg: k.extend(),
        createEncryptor: function(a, b) {
            return this.create(this._ENC_XFORM_MODE, a, b);
        },
        createDecryptor: function(a, b) {
            return this.create(this._DEC_XFORM_MODE, a, b);
        },
        init: function(a, b, c) {
            this.cfg = this.cfg.extend(c);
            this._xformMode = a;
            this._key = b;
            this.reset();
        },
        reset: function() {
            q.reset.call(this);
            this._doReset();
        },
        process: function(a) {
            this._append(a);
            return this._process();
        },
        finalize: function(a) {
            a && this._append(a);
            return this._doFinalize();
        },
        keySize: 4,
        ivSize: 4,
        _ENC_XFORM_MODE: 1,
        _DEC_XFORM_MODE: 2,
        _createHelper: function(a) {
            return {
                encrypt: function(b, c, d) {
                    return ("string" == typeof c ? s : j).encrypt(a, b, c, d);
                },
                decrypt: function(b, c, d) {
                    return ("string" == typeof c ? s : j).decrypt(a, b, c, d);
                }
            };
        }
    });
    f.StreamCipher = n.extend({
        _doFinalize: function() {
            return this._process(!0);
        },
        blockSize: 1
    });
    var m = g.mode = {}, t = function(a, b, c) {
        var d = this._iv;
        d ? this._iv = u : d = this._prevBlock;
        for(var e = 0; e < c; e++)a[b + e] ^= d[e];
    }, h = (f.BlockCipherMode = k.extend({
        createEncryptor: function(a, b) {
            return this.Encryptor.create(a, b);
        },
        createDecryptor: function(a, b) {
            return this.Decryptor.create(a, b);
        },
        init: function(a, b) {
            this._cipher = a;
            this._iv = b;
        }
    })).extend();
    h.Encryptor = h.extend({
        processBlock: function(a, b) {
            var c = this._cipher, d = c.blockSize;
            t.call(this, a, b, d);
            c.encryptBlock(a, b);
            this._prevBlock = a.slice(b, b + d);
        }
    });
    h.Decryptor = h.extend({
        processBlock: function(a, b) {
            var c = this._cipher, d = c.blockSize, e = a.slice(b, b + d);
            c.decryptBlock(a, b);
            t.call(this, a, b, d);
            this._prevBlock = e;
        }
    });
    m = m.CBC = h;
    h = (g.pad = {}).Pkcs7 = {
        pad: function(a, b) {
            for(var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, e = [], f = 0; f < c; f += 4)e.push(d);
            c = l.create(e, c);
            a.concat(c);
        },
        unpad: function(a) {
            a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255;
        }
    };
    f.BlockCipher = n.extend({
        cfg: n.cfg.extend({
            mode: m,
            padding: h
        }),
        reset: function() {
            n.reset.call(this);
            var a = this.cfg, b = a.iv, a = a.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;
            else c = a.createDecryptor, this._minBufferSize = 1;
            this._mode = c.call(a, this, b && b.words);
        },
        _doProcessBlock: function(a, b) {
            this._mode.processBlock(a, b);
        },
        _doFinalize: function() {
            var a = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
                a.pad(this._data, this.blockSize);
                var b = this._process(!0);
            } else b = this._process(!0), a.unpad(b);
            return b;
        },
        blockSize: 4
    });
    var p = f.CipherParams = k.extend({
        init: function(a) {
            this.mixIn(a);
        },
        toString: function(a) {
            return (a || this.formatter).stringify(this);
        }
    }), m = (g.format = {}).OpenSSL = {
        stringify: function(a) {
            var b = a.ciphertext;
            a = a.salt;
            return (a ? l.create([
                1398893684,
                1701076831
            ]).concat(a).concat(b) : b).toString(r);
        },
        parse: function(a) {
            a = r.parse(a);
            var b = a.words;
            if (1398893684 == b[0] && 1701076831 == b[1]) {
                var c = l.create(b.slice(2, 4));
                b.splice(0, 4);
                a.sigBytes -= 16;
            }
            return p.create({
                ciphertext: a,
                salt: c
            });
        }
    }, j = f.SerializableCipher = k.extend({
        cfg: k.extend({
            format: m
        }),
        encrypt: function(a, b, c, d) {
            d = this.cfg.extend(d);
            var e = a.createEncryptor(c, d);
            b = e.finalize(b);
            e = e.cfg;
            return p.create({
                ciphertext: b,
                key: c,
                iv: e.iv,
                algorithm: a,
                mode: e.mode,
                padding: e.padding,
                blockSize: a.blockSize,
                formatter: d.format
            });
        },
        decrypt: function(a, b, c, d) {
            d = this.cfg.extend(d);
            b = this._parse(b, d.format);
            return a.createDecryptor(c, d).finalize(b.ciphertext);
        },
        _parse: function(a, b) {
            return "string" == typeof a ? b.parse(a, this) : a;
        }
    }), g = (g.kdf = {}).OpenSSL = {
        execute: function(a, b, c, d) {
            d || (d = l.random(8));
            a = v.create({
                keySize: b + c
            }).compute(a, d);
            c = l.create(a.words.slice(b), 4 * c);
            a.sigBytes = 4 * b;
            return p.create({
                key: a,
                iv: c,
                salt: d
            });
        }
    }, s = f.PasswordBasedCipher = j.extend({
        cfg: j.cfg.extend({
            kdf: g
        }),
        encrypt: function(a, b, c, d) {
            d = this.cfg.extend(d);
            c = d.kdf.execute(c, a.keySize, a.ivSize);
            d.iv = c.iv;
            a = j.encrypt.call(this, a, b, c.key, d);
            a.mixIn(c);
            return a;
        },
        decrypt: function(a, b, c, d) {
            d = this.cfg.extend(d);
            b = this._parse(b, d.format);
            c = d.kdf.execute(c, a.keySize, a.ivSize, b.salt);
            d.iv = c.iv;
            return j.decrypt.call(this, a, b, c.key, d);
        }
    });
}();
/*
CryptoJS v3.1.2 aes.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    for(var q = CryptoJS, x = q.lib.BlockCipher, r = q.algo, j = [], y = [], z = [], A = [], B = [], C = [], s = [], u = [], v = [], w = [], g = [], k = 0; 256 > k; k++)g[k] = 128 > k ? k << 1 : k << 1 ^ 283;
    for(var n = 0, l = 0, k = 0; 256 > k; k++){
        var f = l ^ l << 1 ^ l << 2 ^ l << 3 ^ l << 4, f = f >>> 8 ^ f & 255 ^ 99;
        j[n] = f;
        y[f] = n;
        var t = g[n], D = g[t], E = g[D], b = 257 * g[f] ^ 16843008 * f;
        z[n] = b << 24 | b >>> 8;
        A[n] = b << 16 | b >>> 16;
        B[n] = b << 8 | b >>> 24;
        C[n] = b;
        b = 16843009 * E ^ 65537 * D ^ 257 * t ^ 16843008 * n;
        s[f] = b << 24 | b >>> 8;
        u[f] = b << 16 | b >>> 16;
        v[f] = b << 8 | b >>> 24;
        w[f] = b;
        n ? (n = t ^ g[g[g[E ^ t]]], l ^= g[g[l]]) : n = l = 1;
    }
    var F = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
    ], r = r.AES = x.extend({
        _doReset: function() {
            for(var c = this._key, e = c.words, a = c.sigBytes / 4, c = 4 * ((this._nRounds = a + 6) + 1), b = this._keySchedule = [], h = 0; h < c; h++)if (h < a) b[h] = e[h];
            else {
                var d = b[h - 1];
                h % a ? 6 < a && 4 == h % a && (d = j[d >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[d & 255]) : (d = d << 8 | d >>> 24, d = j[d >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[d & 255], d ^= F[h / a | 0] << 24);
                b[h] = b[h - a] ^ d;
            }
            e = this._invKeySchedule = [];
            for(a = 0; a < c; a++)h = c - a, d = a % 4 ? b[h] : b[h - 4], e[a] = 4 > a || 4 >= h ? d : s[j[d >>> 24]] ^ u[j[d >>> 16 & 255]] ^ v[j[d >>> 8 & 255]] ^ w[j[d & 255]];
        },
        encryptBlock: function(c, e) {
            this._doCryptBlock(c, e, this._keySchedule, z, A, B, C, j);
        },
        decryptBlock: function(c, e) {
            var a = c[e + 1];
            c[e + 1] = c[e + 3];
            c[e + 3] = a;
            this._doCryptBlock(c, e, this._invKeySchedule, s, u, v, w, y);
            a = c[e + 1];
            c[e + 1] = c[e + 3];
            c[e + 3] = a;
        },
        _doCryptBlock: function(c, e, a, b, h, d, j, m) {
            for(var n = this._nRounds, f = c[e] ^ a[0], g = c[e + 1] ^ a[1], k = c[e + 2] ^ a[2], p = c[e + 3] ^ a[3], l = 4, t = 1; t < n; t++)var q = b[f >>> 24] ^ h[g >>> 16 & 255] ^ d[k >>> 8 & 255] ^ j[p & 255] ^ a[l++], r = b[g >>> 24] ^ h[k >>> 16 & 255] ^ d[p >>> 8 & 255] ^ j[f & 255] ^ a[l++], s = b[k >>> 24] ^ h[p >>> 16 & 255] ^ d[f >>> 8 & 255] ^ j[g & 255] ^ a[l++], p = b[p >>> 24] ^ h[f >>> 16 & 255] ^ d[g >>> 8 & 255] ^ j[k & 255] ^ a[l++], f = q, g = r, k = s;
            q = (m[f >>> 24] << 24 | m[g >>> 16 & 255] << 16 | m[k >>> 8 & 255] << 8 | m[p & 255]) ^ a[l++];
            r = (m[g >>> 24] << 24 | m[k >>> 16 & 255] << 16 | m[p >>> 8 & 255] << 8 | m[f & 255]) ^ a[l++];
            s = (m[k >>> 24] << 24 | m[p >>> 16 & 255] << 16 | m[f >>> 8 & 255] << 8 | m[g & 255]) ^ a[l++];
            p = (m[p >>> 24] << 24 | m[f >>> 16 & 255] << 16 | m[g >>> 8 & 255] << 8 | m[k & 255]) ^ a[l++];
            c[e] = q;
            c[e + 1] = r;
            c[e + 2] = s;
            c[e + 3] = p;
        },
        keySize: 8
    });
    q.AES = x._createHelper(r);
})();
/*
CryptoJS v3.1.2 tripledes-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    function j(b, c) {
        var a = (this._lBlock >>> b ^ this._rBlock) & c;
        this._rBlock ^= a;
        this._lBlock ^= a << b;
    }
    function l(b, c) {
        var a = (this._rBlock >>> b ^ this._lBlock) & c;
        this._lBlock ^= a;
        this._rBlock ^= a << b;
    }
    var h = CryptoJS, e = h.lib, n = e.WordArray, e = e.BlockCipher, g = h.algo, q = [
        57,
        49,
        41,
        33,
        25,
        17,
        9,
        1,
        58,
        50,
        42,
        34,
        26,
        18,
        10,
        2,
        59,
        51,
        43,
        35,
        27,
        19,
        11,
        3,
        60,
        52,
        44,
        36,
        63,
        55,
        47,
        39,
        31,
        23,
        15,
        7,
        62,
        54,
        46,
        38,
        30,
        22,
        14,
        6,
        61,
        53,
        45,
        37,
        29,
        21,
        13,
        5,
        28,
        20,
        12,
        4
    ], p = [
        14,
        17,
        11,
        24,
        1,
        5,
        3,
        28,
        15,
        6,
        21,
        10,
        23,
        19,
        12,
        4,
        26,
        8,
        16,
        7,
        27,
        20,
        13,
        2,
        41,
        52,
        31,
        37,
        47,
        55,
        30,
        40,
        51,
        45,
        33,
        48,
        44,
        49,
        39,
        56,
        34,
        53,
        46,
        42,
        50,
        36,
        29,
        32
    ], r = [
        1,
        2,
        4,
        6,
        8,
        10,
        12,
        14,
        15,
        17,
        19,
        21,
        23,
        25,
        27,
        28
    ], s = [
        {
            "0": 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
        },
        {
            "0": 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
        },
        {
            "0": 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
        },
        {
            "0": 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
        },
        {
            "0": 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
        },
        {
            "0": 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
        },
        {
            "0": 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
        },
        {
            "0": 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
        }
    ], t = [
        4160749569,
        528482304,
        33030144,
        2064384,
        129024,
        8064,
        504,
        2147483679
    ], m = g.DES = e.extend({
        _doReset: function() {
            for(var b = this._key.words, c = [], a = 0; 56 > a; a++){
                var f = q[a] - 1;
                c[a] = b[f >>> 5] >>> 31 - f % 32 & 1;
            }
            b = this._subKeys = [];
            for(f = 0; 16 > f; f++){
                for(var d = b[f] = [], e = r[f], a = 0; 24 > a; a++)d[a / 6 | 0] |= c[(p[a] - 1 + e) % 28] << 31 - a % 6, d[4 + (a / 6 | 0)] |= c[28 + (p[a + 24] - 1 + e) % 28] << 31 - a % 6;
                d[0] = d[0] << 1 | d[0] >>> 31;
                for(a = 1; 7 > a; a++)d[a] >>>= 4 * (a - 1) + 3;
                d[7] = d[7] << 5 | d[7] >>> 27;
            }
            c = this._invSubKeys = [];
            for(a = 0; 16 > a; a++)c[a] = b[15 - a];
        },
        encryptBlock: function(b, c) {
            this._doCryptBlock(b, c, this._subKeys);
        },
        decryptBlock: function(b, c) {
            this._doCryptBlock(b, c, this._invSubKeys);
        },
        _doCryptBlock: function(b, c, a) {
            this._lBlock = b[c];
            this._rBlock = b[c + 1];
            j.call(this, 4, 252645135);
            j.call(this, 16, 65535);
            l.call(this, 2, 858993459);
            l.call(this, 8, 16711935);
            j.call(this, 1, 1431655765);
            for(var f = 0; 16 > f; f++){
                for(var d = a[f], e = this._lBlock, h = this._rBlock, g = 0, k = 0; 8 > k; k++)g |= s[k][((h ^ d[k]) & t[k]) >>> 0];
                this._lBlock = h;
                this._rBlock = e ^ g;
            }
            a = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = a;
            j.call(this, 1, 1431655765);
            l.call(this, 8, 16711935);
            l.call(this, 2, 858993459);
            j.call(this, 16, 65535);
            j.call(this, 4, 252645135);
            b[c] = this._lBlock;
            b[c + 1] = this._rBlock;
        },
        keySize: 2,
        ivSize: 2,
        blockSize: 2
    });
    h.DES = e._createHelper(m);
    g = g.TripleDES = e.extend({
        _doReset: function() {
            var b = this._key.words;
            this._des1 = m.createEncryptor(n.create(b.slice(0, 2)));
            this._des2 = m.createEncryptor(n.create(b.slice(2, 4)));
            this._des3 = m.createEncryptor(n.create(b.slice(4, 6)));
        },
        encryptBlock: function(b, c) {
            this._des1.encryptBlock(b, c);
            this._des2.decryptBlock(b, c);
            this._des3.encryptBlock(b, c);
        },
        decryptBlock: function(b, c) {
            this._des3.decryptBlock(b, c);
            this._des2.encryptBlock(b, c);
            this._des1.decryptBlock(b, c);
        },
        keySize: 6,
        ivSize: 2,
        blockSize: 2
    });
    h.TripleDES = e._createHelper(g);
})();
/*
CryptoJS v3.1.2 enc-base64.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    var h = CryptoJS, j = h.lib.WordArray;
    h.enc.Base64 = {
        stringify: function(b) {
            var e = b.words, f = b.sigBytes, c = this._map;
            b.clamp();
            b = [];
            for(var a = 0; a < f; a += 3)for(var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++)b.push(c.charAt(d >>> 6 * (3 - g) & 63));
            if (e = c.charAt(64)) for(; b.length % 4;)b.push(e);
            return b.join("");
        },
        parse: function(b) {
            var e = b.length, f = this._map, c = f.charAt(64);
            c && (c = b.indexOf(c), -1 != c && (e = c));
            for(var c = [], a = 0, d = 0; d < e; d++)if (d % 4) {
                var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4), h = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4);
                c[a >>> 2] |= (g | h) << 24 - 8 * (a % 4);
                a++;
            }
            return j.create(c, a);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    };
})();
/*
CryptoJS v3.1.2 md5.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function(E) {
    function h(a, f, g, j, p, h, k) {
        a = a + (f & g | ~f & j) + p + k;
        return (a << h | a >>> 32 - h) + f;
    }
    function k(a, f, g, j, p, h, k) {
        a = a + (f & j | g & ~j) + p + k;
        return (a << h | a >>> 32 - h) + f;
    }
    function l(a, f, g, j, h, k, l) {
        a = a + (f ^ g ^ j) + h + l;
        return (a << k | a >>> 32 - k) + f;
    }
    function n(a, f, g, j, h, k, l) {
        a = a + (g ^ (f | ~j)) + h + l;
        return (a << k | a >>> 32 - k) + f;
    }
    for(var r = CryptoJS, q = r.lib, F = q.WordArray, s = q.Hasher, q = r.algo, a = [], t = 0; 64 > t; t++)a[t] = 4294967296 * E.abs(E.sin(t + 1)) | 0;
    q = q.MD5 = s.extend({
        _doReset: function() {
            this._hash = new F.init([
                1732584193,
                4023233417,
                2562383102,
                271733878
            ]);
        },
        _doProcessBlock: function(m, f) {
            for(var g = 0; 16 > g; g++){
                var j = f + g, p = m[j];
                m[j] = (p << 8 | p >>> 24) & 16711935 | (p << 24 | p >>> 8) & 4278255360;
            }
            var g = this._hash.words, j = m[f + 0], p = m[f + 1], q = m[f + 2], r = m[f + 3], s = m[f + 4], t = m[f + 5], u = m[f + 6], v = m[f + 7], w = m[f + 8], x = m[f + 9], y = m[f + 10], z = m[f + 11], A = m[f + 12], B = m[f + 13], C = m[f + 14], D = m[f + 15], b = g[0], c = g[1], d = g[2], e = g[3], b = h(b, c, d, e, j, 7, a[0]), e = h(e, b, c, d, p, 12, a[1]), d = h(d, e, b, c, q, 17, a[2]), c = h(c, d, e, b, r, 22, a[3]), b = h(b, c, d, e, s, 7, a[4]), e = h(e, b, c, d, t, 12, a[5]), d = h(d, e, b, c, u, 17, a[6]), c = h(c, d, e, b, v, 22, a[7]), b = h(b, c, d, e, w, 7, a[8]), e = h(e, b, c, d, x, 12, a[9]), d = h(d, e, b, c, y, 17, a[10]), c = h(c, d, e, b, z, 22, a[11]), b = h(b, c, d, e, A, 7, a[12]), e = h(e, b, c, d, B, 12, a[13]), d = h(d, e, b, c, C, 17, a[14]), c = h(c, d, e, b, D, 22, a[15]), b = k(b, c, d, e, p, 5, a[16]), e = k(e, b, c, d, u, 9, a[17]), d = k(d, e, b, c, z, 14, a[18]), c = k(c, d, e, b, j, 20, a[19]), b = k(b, c, d, e, t, 5, a[20]), e = k(e, b, c, d, y, 9, a[21]), d = k(d, e, b, c, D, 14, a[22]), c = k(c, d, e, b, s, 20, a[23]), b = k(b, c, d, e, x, 5, a[24]), e = k(e, b, c, d, C, 9, a[25]), d = k(d, e, b, c, r, 14, a[26]), c = k(c, d, e, b, w, 20, a[27]), b = k(b, c, d, e, B, 5, a[28]), e = k(e, b, c, d, q, 9, a[29]), d = k(d, e, b, c, v, 14, a[30]), c = k(c, d, e, b, A, 20, a[31]), b = l(b, c, d, e, t, 4, a[32]), e = l(e, b, c, d, w, 11, a[33]), d = l(d, e, b, c, z, 16, a[34]), c = l(c, d, e, b, C, 23, a[35]), b = l(b, c, d, e, p, 4, a[36]), e = l(e, b, c, d, s, 11, a[37]), d = l(d, e, b, c, v, 16, a[38]), c = l(c, d, e, b, y, 23, a[39]), b = l(b, c, d, e, B, 4, a[40]), e = l(e, b, c, d, j, 11, a[41]), d = l(d, e, b, c, r, 16, a[42]), c = l(c, d, e, b, u, 23, a[43]), b = l(b, c, d, e, x, 4, a[44]), e = l(e, b, c, d, A, 11, a[45]), d = l(d, e, b, c, D, 16, a[46]), c = l(c, d, e, b, q, 23, a[47]), b = n(b, c, d, e, j, 6, a[48]), e = n(e, b, c, d, v, 10, a[49]), d = n(d, e, b, c, C, 15, a[50]), c = n(c, d, e, b, t, 21, a[51]), b = n(b, c, d, e, A, 6, a[52]), e = n(e, b, c, d, r, 10, a[53]), d = n(d, e, b, c, y, 15, a[54]), c = n(c, d, e, b, p, 21, a[55]), b = n(b, c, d, e, w, 6, a[56]), e = n(e, b, c, d, D, 10, a[57]), d = n(d, e, b, c, u, 15, a[58]), c = n(c, d, e, b, B, 21, a[59]), b = n(b, c, d, e, s, 6, a[60]), e = n(e, b, c, d, z, 10, a[61]), d = n(d, e, b, c, q, 15, a[62]), c = n(c, d, e, b, x, 21, a[63]);
            g[0] = g[0] + b | 0;
            g[1] = g[1] + c | 0;
            g[2] = g[2] + d | 0;
            g[3] = g[3] + e | 0;
        },
        _doFinalize: function() {
            var a = this._data, f = a.words, g = 8 * this._nDataBytes, j = 8 * a.sigBytes;
            f[j >>> 5] |= 128 << 24 - j % 32;
            var h = E.floor(g / 4294967296);
            f[(j + 64 >>> 9 << 4) + 15] = (h << 8 | h >>> 24) & 16711935 | (h << 24 | h >>> 8) & 4278255360;
            f[(j + 64 >>> 9 << 4) + 14] = (g << 8 | g >>> 24) & 16711935 | (g << 24 | g >>> 8) & 4278255360;
            a.sigBytes = 4 * (f.length + 1);
            this._process();
            a = this._hash;
            f = a.words;
            for(g = 0; 4 > g; g++)j = f[g], f[g] = (j << 8 | j >>> 24) & 16711935 | (j << 24 | j >>> 8) & 4278255360;
            return a;
        },
        clone: function() {
            var a = s.clone.call(this);
            a._hash = this._hash.clone();
            return a;
        }
    });
    r.MD5 = s._createHelper(q);
    r.HmacMD5 = s._createHmacHelper(q);
})(Math);
/*
CryptoJS v3.1.2 sha1-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    var k = CryptoJS, b = k.lib, m = b.WordArray, l = b.Hasher, d = [], b = k.algo.SHA1 = l.extend({
        _doReset: function() {
            this._hash = new m.init([
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
            ]);
        },
        _doProcessBlock: function(n, p) {
            for(var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b = a[4], c = 0; 80 > c; c++){
                if (16 > c) d[c] = n[p + c] | 0;
                else {
                    var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16];
                    d[c] = g << 1 | g >>> 31;
                }
                g = (e << 5 | e >>> 27) + b + d[c];
                g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^ j) - 899497514);
                b = j;
                j = h;
                h = f << 30 | f >>> 2;
                f = e;
                e = g;
            }
            a[0] = a[0] + e | 0;
            a[1] = a[1] + f | 0;
            a[2] = a[2] + h | 0;
            a[3] = a[3] + j | 0;
            a[4] = a[4] + b | 0;
        },
        _doFinalize: function() {
            var b = this._data, d = b.words, a = 8 * this._nDataBytes, e = 8 * b.sigBytes;
            d[e >>> 5] |= 128 << 24 - e % 32;
            d[(e + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296);
            d[(e + 64 >>> 9 << 4) + 15] = a;
            b.sigBytes = 4 * d.length;
            this._process();
            return this._hash;
        },
        clone: function() {
            var b = l.clone.call(this);
            b._hash = this._hash.clone();
            return b;
        }
    });
    k.SHA1 = l._createHelper(b);
    k.HmacSHA1 = l._createHmacHelper(b);
})();
/*
CryptoJS v3.1.2 sha256-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function(k) {
    for(var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t = [], u = function(q) {
        return 4294967296 * (q - (q | 0)) | 0;
    }, l = 2, b = 0; 64 > b;){
        var d;
        a: {
            d = l;
            for(var w = k.sqrt(d), r = 2; r <= w; r++)if (!(d % r)) {
                d = !1;
                break a;
            }
            d = !0;
        }
        d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t[b] = u(k.pow(l, 1 / 3)), b++);
        l++;
    }
    var n = [], h = h.SHA256 = j.extend({
        _doReset: function() {
            this._hash = new v.init(s.slice(0));
        },
        _doProcessBlock: function(q, h) {
            for(var a = this._hash.words, c = a[0], d = a[1], b = a[2], k = a[3], f = a[4], g = a[5], j = a[6], l = a[7], e = 0; 64 > e; e++){
                if (16 > e) n[e] = q[h + e] | 0;
                else {
                    var m = n[e - 15], p = n[e - 2];
                    n[e] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n[e - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[e - 16];
                }
                m = l + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g ^ ~f & j) + t[e] + n[e];
                p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d ^ c & b ^ d & b);
                l = j;
                j = g;
                g = f;
                f = k + m | 0;
                k = b;
                b = d;
                d = c;
                c = m + p | 0;
            }
            a[0] = a[0] + c | 0;
            a[1] = a[1] + d | 0;
            a[2] = a[2] + b | 0;
            a[3] = a[3] + k | 0;
            a[4] = a[4] + f | 0;
            a[5] = a[5] + g | 0;
            a[6] = a[6] + j | 0;
            a[7] = a[7] + l | 0;
        },
        _doFinalize: function() {
            var d = this._data, b = d.words, a = 8 * this._nDataBytes, c = 8 * d.sigBytes;
            b[c >>> 5] |= 128 << 24 - c % 32;
            b[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296);
            b[(c + 64 >>> 9 << 4) + 15] = a;
            d.sigBytes = 4 * b.length;
            this._process();
            return this._hash;
        },
        clone: function() {
            var b = j.clone.call(this);
            b._hash = this._hash.clone();
            return b;
        }
    });
    g.SHA256 = j._createHelper(h);
    g.HmacSHA256 = j._createHmacHelper(h);
})(Math);
/*
CryptoJS v3.1.2 sha224-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    var b = CryptoJS, d = b.lib.WordArray, a = b.algo, c = a.SHA256, a = a.SHA224 = c.extend({
        _doReset: function() {
            this._hash = new d.init([
                3238371032,
                914150663,
                812702999,
                4144912697,
                4290775857,
                1750603025,
                1694076839,
                3204075428
            ]);
        },
        _doFinalize: function() {
            var a = c._doFinalize.call(this);
            a.sigBytes -= 4;
            return a;
        }
    });
    b.SHA224 = c._createHelper(a);
    b.HmacSHA224 = c._createHmacHelper(a);
})();
/*
CryptoJS v3.1.2 sha512-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    function a() {
        return d.create.apply(d, arguments);
    }
    for(var n = CryptoJS, r = n.lib.Hasher, e = n.x64, d = e.Word, T = e.WordArray, e = n.algo, ea = [
        a(1116352408, 3609767458),
        a(1899447441, 602891725),
        a(3049323471, 3964484399),
        a(3921009573, 2173295548),
        a(961987163, 4081628472),
        a(1508970993, 3053834265),
        a(2453635748, 2937671579),
        a(2870763221, 3664609560),
        a(3624381080, 2734883394),
        a(310598401, 1164996542),
        a(607225278, 1323610764),
        a(1426881987, 3590304994),
        a(1925078388, 4068182383),
        a(2162078206, 991336113),
        a(2614888103, 633803317),
        a(3248222580, 3479774868),
        a(3835390401, 2666613458),
        a(4022224774, 944711139),
        a(264347078, 2341262773),
        a(604807628, 2007800933),
        a(770255983, 1495990901),
        a(1249150122, 1856431235),
        a(1555081692, 3175218132),
        a(1996064986, 2198950837),
        a(2554220882, 3999719339),
        a(2821834349, 766784016),
        a(2952996808, 2566594879),
        a(3210313671, 3203337956),
        a(3336571891, 1034457026),
        a(3584528711, 2466948901),
        a(113926993, 3758326383),
        a(338241895, 168717936),
        a(666307205, 1188179964),
        a(773529912, 1546045734),
        a(1294757372, 1522805485),
        a(1396182291, 2643833823),
        a(1695183700, 2343527390),
        a(1986661051, 1014477480),
        a(2177026350, 1206759142),
        a(2456956037, 344077627),
        a(2730485921, 1290863460),
        a(2820302411, 3158454273),
        a(3259730800, 3505952657),
        a(3345764771, 106217008),
        a(3516065817, 3606008344),
        a(3600352804, 1432725776),
        a(4094571909, 1467031594),
        a(275423344, 851169720),
        a(430227734, 3100823752),
        a(506948616, 1363258195),
        a(659060556, 3750685593),
        a(883997877, 3785050280),
        a(958139571, 3318307427),
        a(1322822218, 3812723403),
        a(1537002063, 2003034995),
        a(1747873779, 3602036899),
        a(1955562222, 1575990012),
        a(2024104815, 1125592928),
        a(2227730452, 2716904306),
        a(2361852424, 442776044),
        a(2428436474, 593698344),
        a(2756734187, 3733110249),
        a(3204031479, 2999351573),
        a(3329325298, 3815920427),
        a(3391569614, 3928383900),
        a(3515267271, 566280711),
        a(3940187606, 3454069534),
        a(4118630271, 4000239992),
        a(116418474, 1914138554),
        a(174292421, 2731055270),
        a(289380356, 3203993006),
        a(460393269, 320620315),
        a(685471733, 587496836),
        a(852142971, 1086792851),
        a(1017036298, 365543100),
        a(1126000580, 2618297676),
        a(1288033470, 3409855158),
        a(1501505948, 4234509866),
        a(1607167915, 987167468),
        a(1816402316, 1246189591)
    ], v = [], w = 0; 80 > w; w++)v[w] = a();
    e = e.SHA512 = r.extend({
        _doReset: function() {
            this._hash = new T.init([
                new d.init(1779033703, 4089235720),
                new d.init(3144134277, 2227873595),
                new d.init(1013904242, 4271175723),
                new d.init(2773480762, 1595750129),
                new d.init(1359893119, 2917565137),
                new d.init(2600822924, 725511199),
                new d.init(528734635, 4215389547),
                new d.init(1541459225, 327033209)
            ]);
        },
        _doProcessBlock: function(a, d) {
            for(var f = this._hash.words, F = f[0], e = f[1], n = f[2], r = f[3], G = f[4], H = f[5], I = f[6], f = f[7], w = F.high, J = F.low, X = e.high, K = e.low, Y = n.high, L = n.low, Z = r.high, M = r.low, $ = G.high, N = G.low, aa = H.high, O = H.low, ba = I.high, P = I.low, ca = f.high, Q = f.low, k = w, g = J, z = X, x = K, A = Y, y = L, U = Z, B = M, l = $, h = N, R = aa, C = O, S = ba, D = P, V = ca, E = Q, m = 0; 80 > m; m++){
                var s = v[m];
                if (16 > m) var j = s.high = a[d + 2 * m] | 0, b = s.low = a[d + 2 * m + 1] | 0;
                else {
                    var j = v[m - 15], b = j.high, p = j.low, j = (b >>> 1 | p << 31) ^ (b >>> 8 | p << 24) ^ b >>> 7, p = (p >>> 1 | b << 31) ^ (p >>> 8 | b << 24) ^ (p >>> 7 | b << 25), u = v[m - 2], b = u.high, c = u.low, u = (b >>> 19 | c << 13) ^ (b << 3 | c >>> 29) ^ b >>> 6, c = (c >>> 19 | b << 13) ^ (c << 3 | b >>> 29) ^ (c >>> 6 | b << 26), b = v[m - 7], W = b.high, t = v[m - 16], q = t.high, t = t.low, b = p + b.low, j = j + W + (b >>> 0 < p >>> 0 ? 1 : 0), b = b + c, j = j + u + (b >>> 0 < c >>> 0 ? 1 : 0), b = b + t, j = j + q + (b >>> 0 < t >>> 0 ? 1 : 0);
                    s.high = j;
                    s.low = b;
                }
                var W = l & R ^ ~l & S, t = h & C ^ ~h & D, s = k & z ^ k & A ^ z & A, T = g & x ^ g & y ^ x & y, p = (k >>> 28 | g << 4) ^ (k << 30 | g >>> 2) ^ (k << 25 | g >>> 7), u = (g >>> 28 | k << 4) ^ (g << 30 | k >>> 2) ^ (g << 25 | k >>> 7), c = ea[m], fa = c.high, da = c.low, c = E + ((h >>> 14 | l << 18) ^ (h >>> 18 | l << 14) ^ (h << 23 | l >>> 9)), q = V + ((l >>> 14 | h << 18) ^ (l >>> 18 | h << 14) ^ (l << 23 | h >>> 9)) + (c >>> 0 < E >>> 0 ? 1 : 0), c = c + t, q = q + W + (c >>> 0 < t >>> 0 ? 1 : 0), c = c + da, q = q + fa + (c >>> 0 < da >>> 0 ? 1 : 0), c = c + b, q = q + j + (c >>> 0 < b >>> 0 ? 1 : 0), b = u + T, s = p + s + (b >>> 0 < u >>> 0 ? 1 : 0), V = S, E = D, S = R, D = C, R = l, C = h, h = B + c | 0, l = U + q + (h >>> 0 < B >>> 0 ? 1 : 0) | 0, U = A, B = y, A = z, y = x, z = k, x = g, g = c + b | 0, k = q + s + (g >>> 0 < c >>> 0 ? 1 : 0) | 0;
            }
            J = F.low = J + g;
            F.high = w + k + (J >>> 0 < g >>> 0 ? 1 : 0);
            K = e.low = K + x;
            e.high = X + z + (K >>> 0 < x >>> 0 ? 1 : 0);
            L = n.low = L + y;
            n.high = Y + A + (L >>> 0 < y >>> 0 ? 1 : 0);
            M = r.low = M + B;
            r.high = Z + U + (M >>> 0 < B >>> 0 ? 1 : 0);
            N = G.low = N + h;
            G.high = $ + l + (N >>> 0 < h >>> 0 ? 1 : 0);
            O = H.low = O + C;
            H.high = aa + R + (O >>> 0 < C >>> 0 ? 1 : 0);
            P = I.low = P + D;
            I.high = ba + S + (P >>> 0 < D >>> 0 ? 1 : 0);
            Q = f.low = Q + E;
            f.high = ca + V + (Q >>> 0 < E >>> 0 ? 1 : 0);
        },
        _doFinalize: function() {
            var a = this._data, d = a.words, f = 8 * this._nDataBytes, e = 8 * a.sigBytes;
            d[e >>> 5] |= 128 << 24 - e % 32;
            d[(e + 128 >>> 10 << 5) + 30] = Math.floor(f / 4294967296);
            d[(e + 128 >>> 10 << 5) + 31] = f;
            a.sigBytes = 4 * d.length;
            this._process();
            return this._hash.toX32();
        },
        clone: function() {
            var a = r.clone.call(this);
            a._hash = this._hash.clone();
            return a;
        },
        blockSize: 32
    });
    n.SHA512 = r._createHelper(e);
    n.HmacSHA512 = r._createHmacHelper(e);
})();
/*
CryptoJS v3.1.2 sha384-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    var c = CryptoJS, a = c.x64, b = a.Word, e = a.WordArray, a = c.algo, d = a.SHA512, a = a.SHA384 = d.extend({
        _doReset: function() {
            this._hash = new e.init([
                new b.init(3418070365, 3238371032),
                new b.init(1654270250, 914150663),
                new b.init(2438529370, 812702999),
                new b.init(355462360, 4144912697),
                new b.init(1731405415, 4290775857),
                new b.init(2394180231, 1750603025),
                new b.init(3675008525, 1694076839),
                new b.init(1203062813, 3204075428)
            ]);
        },
        _doFinalize: function() {
            var a = d._doFinalize.call(this);
            a.sigBytes -= 16;
            return a;
        }
    });
    c.SHA384 = d._createHelper(a);
    c.HmacSHA384 = d._createHmacHelper(a);
})();
/*
CryptoJS v3.1.2 ripemd160-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ /*

(c) 2012 by Cedric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/ (function() {
    var q = CryptoJS, d = q.lib, n = d.WordArray, p = d.Hasher, d = q.algo, x = n.create([
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ]), y = n.create([
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ]), z = n.create([
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ]), A = n.create([
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ]), B = n.create([
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
    ]), C = n.create([
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
    ]), d = d.RIPEMD160 = p.extend({
        _doReset: function() {
            this._hash = n.create([
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
            ]);
        },
        _doProcessBlock: function(e, v) {
            for(var b = 0; 16 > b; b++){
                var c = v + b, f = e[c];
                e[c] = (f << 8 | f >>> 24) & 16711935 | (f << 24 | f >>> 8) & 4278255360;
            }
            var c = this._hash.words, f = B.words, d = C.words, n = x.words, q = y.words, p = z.words, w = A.words, t, g, h, j, r, u, k, l, m, s;
            u = t = c[0];
            k = g = c[1];
            l = h = c[2];
            m = j = c[3];
            s = r = c[4];
            for(var a, b = 0; 80 > b; b += 1)a = t + e[v + n[b]] | 0, a = 16 > b ? a + ((g ^ h ^ j) + f[0]) : 32 > b ? a + ((g & h | ~g & j) + f[1]) : 48 > b ? a + (((g | ~h) ^ j) + f[2]) : 64 > b ? a + ((g & j | h & ~j) + f[3]) : a + ((g ^ (h | ~j)) + f[4]), a |= 0, a = a << p[b] | a >>> 32 - p[b], a = a + r | 0, t = r, r = j, j = h << 10 | h >>> 22, h = g, g = a, a = u + e[v + q[b]] | 0, a = 16 > b ? a + ((k ^ (l | ~m)) + d[0]) : 32 > b ? a + ((k & m | l & ~m) + d[1]) : 48 > b ? a + (((k | ~l) ^ m) + d[2]) : 64 > b ? a + ((k & l | ~k & m) + d[3]) : a + ((k ^ l ^ m) + d[4]), a |= 0, a = a << w[b] | a >>> 32 - w[b], a = a + s | 0, u = s, s = m, m = l << 10 | l >>> 22, l = k, k = a;
            a = c[1] + h + m | 0;
            c[1] = c[2] + j + s | 0;
            c[2] = c[3] + r + u | 0;
            c[3] = c[4] + t + k | 0;
            c[4] = c[0] + g + l | 0;
            c[0] = a;
        },
        _doFinalize: function() {
            var e = this._data, d = e.words, b = 8 * this._nDataBytes, c = 8 * e.sigBytes;
            d[c >>> 5] |= 128 << 24 - c % 32;
            d[(c + 64 >>> 9 << 4) + 14] = (b << 8 | b >>> 24) & 16711935 | (b << 24 | b >>> 8) & 4278255360;
            e.sigBytes = 4 * (d.length + 1);
            this._process();
            e = this._hash;
            d = e.words;
            for(b = 0; 5 > b; b++)c = d[b], d[b] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;
            return e;
        },
        clone: function() {
            var d = p.clone.call(this);
            d._hash = this._hash.clone();
            return d;
        }
    });
    q.RIPEMD160 = p._createHelper(d);
    q.HmacRIPEMD160 = p._createHmacHelper(d);
})(Math);
/*
CryptoJS v3.1.2 hmac.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    var c = CryptoJS, k = c.enc.Utf8;
    c.algo.HMAC = c.lib.Base.extend({
        init: function(a, b) {
            a = this._hasher = new a.init;
            "string" == typeof b && (b = k.parse(b));
            var c = a.blockSize, e = 4 * c;
            b.sigBytes > e && (b = a.finalize(b));
            b.clamp();
            for(var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c; d++)h[d] ^= 1549556828, j[d] ^= 909522486;
            f.sigBytes = g.sigBytes = e;
            this.reset();
        },
        reset: function() {
            var a = this._hasher;
            a.reset();
            a.update(this._iKey);
        },
        update: function(a) {
            this._hasher.update(a);
            return this;
        },
        finalize: function(a) {
            var b = this._hasher;
            a = b.finalize(a);
            b.reset();
            return b.finalize(this._oKey.clone().concat(a));
        }
    });
})();
/*
CryptoJS v3.1.2 pbkdf2-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/ (function() {
    var b = CryptoJS, a = b.lib, d = a.Base, m = a.WordArray, a = b.algo, q = a.HMAC, l = a.PBKDF2 = d.extend({
        cfg: d.extend({
            keySize: 4,
            hasher: a.SHA1,
            iterations: 1
        }),
        init: function(a) {
            this.cfg = this.cfg.extend(a);
        },
        compute: function(a, b) {
            for(var c = this.cfg, f = q.create(c.hasher, a), g = m.create(), d = m.create([
                1
            ]), l = g.words, r = d.words, n = c.keySize, c = c.iterations; l.length < n;){
                var h = f.update(b).finalize(d);
                f.reset();
                for(var j = h.words, s = j.length, k = h, p = 1; p < c; p++){
                    k = f.finalize(k);
                    f.reset();
                    for(var t = k.words, e = 0; e < s; e++)j[e] ^= t[e];
                }
                g.concat(h);
                r[0]++;
            }
            g.sigBytes = 4 * n;
            return g;
        }
    });
    b.PBKDF2 = function(a, b, c) {
        return l.create(c).compute(a, b);
    };
})();
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */ var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";
function hex2b64(d) {
    var b;
    var e;
    var a = "";
    for(b = 0; b + 3 <= d.length; b += 3){
        e = parseInt(d.substring(b, b + 3), 16);
        a += b64map.charAt(e >> 6) + b64map.charAt(e & 63);
    }
    if (b + 1 == d.length) {
        e = parseInt(d.substring(b, b + 1), 16);
        a += b64map.charAt(e << 2);
    } else if (b + 2 == d.length) {
        e = parseInt(d.substring(b, b + 2), 16);
        a += b64map.charAt(e >> 2) + b64map.charAt((e & 3) << 4);
    }
    if (b64pad) while((a.length & 3) > 0)a += b64pad;
    return a;
}
function b64tohex(f) {
    var d = "";
    var e;
    var b = 0;
    var c;
    var a;
    for(e = 0; e < f.length; ++e){
        if (f.charAt(e) == b64pad) break;
        a = b64map.indexOf(f.charAt(e));
        if (a < 0) continue;
        if (b == 0) {
            d += int2char(a >> 2);
            c = a & 3;
            b = 1;
        } else {
            if (b == 1) {
                d += int2char(c << 2 | a >> 4);
                c = a & 15;
                b = 2;
            } else if (b == 2) {
                d += int2char(c);
                d += int2char(a >> 2);
                c = a & 3;
                b = 3;
            } else {
                d += int2char(c << 2 | a >> 4);
                d += int2char(a & 15);
                b = 0;
            }
        }
    }
    if (b == 1) d += int2char(c << 2);
    return d;
}
function b64toBA(e) {
    var d = b64tohex(e);
    var c;
    var b = new Array();
    for(c = 0; 2 * c < d.length; ++c)b[c] = parseInt(d.substring(2 * c, 2 * c + 2), 16);
    return b;
}
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */ var dbits;
var canary = 244837814094590;
var j_lm = (canary & 16777215) == 15715070;
function BigInteger(e, d, f) {
    if (e != null) {
        if ("number" == typeof e) this.fromNumber(e, d, f);
        else if (d == null && "string" != typeof e) this.fromString(e, 256);
        else this.fromString(e, d);
    }
}
function nbi() {
    return new BigInteger(null);
}
function am1(f, a, b, e, h, g) {
    while(--g >= 0){
        var d = a * this[f++] + b[e] + h;
        h = Math.floor(d / 67108864);
        b[e++] = d & 67108863;
    }
    return h;
}
function am2(f, q, r, e, o, a) {
    var k = q & 32767, p = q >> 15;
    while(--a >= 0){
        var d = this[f] & 32767;
        var g = this[f++] >> 15;
        var b = p * d + g * k;
        d = k * d + ((b & 32767) << 15) + r[e] + (o & 1073741823);
        o = (d >>> 30) + (b >>> 15) + p * g + (o >>> 30);
        r[e++] = d & 1073741823;
    }
    return o;
}
function am3(f, q, r, e, o, a) {
    var k = q & 16383, p = q >> 14;
    while(--a >= 0){
        var d = this[f] & 16383;
        var g = this[f++] >> 14;
        var b = p * d + g * k;
        d = k * d + ((b & 16383) << 14) + r[e] + o;
        o = (d >> 28) + (b >> 14) + p * g;
        r[e++] = d & 268435455;
    }
    return o;
}
if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
    BigInteger.prototype.am = am2;
    dbits = 30;
} else if (j_lm && navigator.appName != "Netscape") {
    BigInteger.prototype.am = am1;
    dbits = 26;
} else {
    BigInteger.prototype.am = am3;
    dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 << dbits) - 1;
BigInteger.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv)BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv;
function int2char(a) {
    return BI_RM.charAt(a);
}
function intAt(b, a) {
    var d = BI_RC[b.charCodeAt(a)];
    return d == null ? -1 : d;
}
function bnpCopyTo(b) {
    for(var a = this.t - 1; a >= 0; --a)b[a] = this[a];
    b.t = this.t;
    b.s = this.s;
}
function bnpFromInt(a) {
    this.t = 1;
    this.s = a < 0 ? -1 : 0;
    if (a > 0) this[0] = a;
    else if (a < -1) this[0] = a + this.DV;
    else this.t = 0;
}
function nbv(a) {
    var b = nbi();
    b.fromInt(a);
    return b;
}
function bnpFromString(h, c) {
    var e;
    if (c == 16) e = 4;
    else if (c == 8) e = 3;
    else {
        if (c == 256) e = 8;
        else if (c == 2) e = 1;
        else {
            if (c == 32) e = 5;
            else if (c == 4) e = 2;
            else {
                this.fromRadix(h, c);
                return;
            }
        }
    }
    this.t = 0;
    this.s = 0;
    var g = h.length, d = false, f = 0;
    while(--g >= 0){
        var a = e == 8 ? h[g] & 255 : intAt(h, g);
        if (a < 0) {
            if (h.charAt(g) == "-") d = true;
            continue;
        }
        d = false;
        if (f == 0) this[this.t++] = a;
        else if (f + e > this.DB) {
            this[this.t - 1] |= (a & (1 << this.DB - f) - 1) << f;
            this[this.t++] = a >> this.DB - f;
        } else this[this.t - 1] |= a << f;
        f += e;
        if (f >= this.DB) f -= this.DB;
    }
    if (e == 8 && (h[0] & 128) != 0) {
        this.s = -1;
        if (f > 0) this[this.t - 1] |= (1 << this.DB - f) - 1 << f;
    }
    this.clamp();
    if (d) BigInteger.ZERO.subTo(this, this);
}
function bnpClamp() {
    var a = this.s & this.DM;
    while(this.t > 0 && this[this.t - 1] == a)--this.t;
}
function bnToString(c) {
    if (this.s < 0) return "-" + this.negate().toString(c);
    var e;
    if (c == 16) e = 4;
    else if (c == 8) e = 3;
    else {
        if (c == 2) e = 1;
        else if (c == 32) e = 5;
        else {
            if (c == 4) e = 2;
            else return this.toRadix(c);
        }
    }
    var g = (1 << e) - 1, l, a = false, h = "", f = this.t;
    var j = this.DB - f * this.DB % e;
    if (f-- > 0) {
        if (j < this.DB && (l = this[f] >> j) > 0) {
            a = true;
            h = int2char(l);
        }
        while(f >= 0){
            if (j < e) {
                l = (this[f] & (1 << j) - 1) << e - j;
                l |= this[--f] >> (j += this.DB - e);
            } else {
                l = this[f] >> (j -= e) & g;
                if (j <= 0) {
                    j += this.DB;
                    --f;
                }
            }
            if (l > 0) a = true;
            if (a) h += int2char(l);
        }
    }
    return a ? h : "0";
}
function bnNegate() {
    var a = nbi();
    BigInteger.ZERO.subTo(this, a);
    return a;
}
function bnAbs() {
    return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(b) {
    var d = this.s - b.s;
    if (d != 0) return d;
    var c = this.t;
    d = c - b.t;
    if (d != 0) return this.s < 0 ? -d : d;
    while(--c >= 0){
        if ((d = this[c] - b[c]) != 0) return d;
    }
    return 0;
}
function nbits(a) {
    var c = 1, b;
    if ((b = a >>> 16) != 0) {
        a = b;
        c += 16;
    }
    if ((b = a >> 8) != 0) {
        a = b;
        c += 8;
    }
    if ((b = a >> 4) != 0) {
        a = b;
        c += 4;
    }
    if ((b = a >> 2) != 0) {
        a = b;
        c += 2;
    }
    if ((b = a >> 1) != 0) {
        a = b;
        c += 1;
    }
    return c;
}
function bnBitLength() {
    if (this.t <= 0) return 0;
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(c, b) {
    var a;
    for(a = this.t - 1; a >= 0; --a)b[a + c] = this[a];
    for(a = c - 1; a >= 0; --a)b[a] = 0;
    b.t = this.t + c;
    b.s = this.s;
}
function bnpDRShiftTo(c, b) {
    for(var a = c; a < this.t; ++a)b[a - c] = this[a];
    b.t = Math.max(this.t - c, 0);
    b.s = this.s;
}
function bnpLShiftTo(j, e) {
    var b = j % this.DB;
    var a = this.DB - b;
    var g = (1 << a) - 1;
    var f = Math.floor(j / this.DB), h = this.s << b & this.DM, d;
    for(d = this.t - 1; d >= 0; --d){
        e[d + f + 1] = this[d] >> a | h;
        h = (this[d] & g) << b;
    }
    for(d = f - 1; d >= 0; --d)e[d] = 0;
    e[f] = h;
    e.t = this.t + f + 1;
    e.s = this.s;
    e.clamp();
}
function bnpRShiftTo(g, d) {
    d.s = this.s;
    var e = Math.floor(g / this.DB);
    if (e >= this.t) {
        d.t = 0;
        return;
    }
    var b = g % this.DB;
    var a = this.DB - b;
    var f = (1 << b) - 1;
    d[0] = this[e] >> b;
    for(var c = e + 1; c < this.t; ++c){
        d[c - e - 1] |= (this[c] & f) << a;
        d[c - e] = this[c] >> b;
    }
    if (b > 0) d[this.t - e - 1] |= (this.s & f) << a;
    d.t = this.t - e;
    d.clamp();
}
function bnpSubTo(d, f) {
    var e = 0, g = 0, b = Math.min(d.t, this.t);
    while(e < b){
        g += this[e] - d[e];
        f[e++] = g & this.DM;
        g >>= this.DB;
    }
    if (d.t < this.t) {
        g -= d.s;
        while(e < this.t){
            g += this[e];
            f[e++] = g & this.DM;
            g >>= this.DB;
        }
        g += this.s;
    } else {
        g += this.s;
        while(e < d.t){
            g -= d[e];
            f[e++] = g & this.DM;
            g >>= this.DB;
        }
        g -= d.s;
    }
    f.s = g < 0 ? -1 : 0;
    if (g < -1) f[e++] = this.DV + g;
    else if (g > 0) f[e++] = g;
    f.t = e;
    f.clamp();
}
function bnpMultiplyTo(c, e) {
    var b = this.abs(), f = c.abs();
    var d = b.t;
    e.t = d + f.t;
    while(--d >= 0)e[d] = 0;
    for(d = 0; d < f.t; ++d)e[d + b.t] = b.am(0, f[d], e, d, 0, b.t);
    e.s = 0;
    e.clamp();
    if (this.s != c.s) BigInteger.ZERO.subTo(e, e);
}
function bnpSquareTo(d) {
    var a = this.abs();
    var b = d.t = 2 * a.t;
    while(--b >= 0)d[b] = 0;
    for(b = 0; b < a.t - 1; ++b){
        var e = a.am(b, a[b], d, 2 * b, 0, 1);
        if ((d[b + a.t] += a.am(b + 1, 2 * a[b], d, 2 * b + 1, e, a.t - b - 1)) >= a.DV) {
            d[b + a.t] -= a.DV;
            d[b + a.t + 1] = 1;
        }
    }
    if (d.t > 0) d[d.t - 1] += a.am(b, a[b], d, 2 * b, 0, 1);
    d.s = 0;
    d.clamp();
}
function bnpDivRemTo(n, h, g) {
    var w = n.abs();
    if (w.t <= 0) return;
    var k = this.abs();
    if (k.t < w.t) {
        if (h != null) h.fromInt(0);
        if (g != null) this.copyTo(g);
        return;
    }
    if (g == null) g = nbi();
    var d = nbi(), a = this.s, l = n.s;
    var v = this.DB - nbits(w[w.t - 1]);
    if (v > 0) {
        w.lShiftTo(v, d);
        k.lShiftTo(v, g);
    } else {
        w.copyTo(d);
        k.copyTo(g);
    }
    var p = d.t;
    var b = d[p - 1];
    if (b == 0) return;
    var o = b * (1 << this.F1) + (p > 1 ? d[p - 2] >> this.F2 : 0);
    var A = this.FV / o, z = (1 << this.F1) / o, x = 1 << this.F2;
    var u = g.t, s = u - p, f = h == null ? nbi() : h;
    d.dlShiftTo(s, f);
    if (g.compareTo(f) >= 0) {
        g[g.t++] = 1;
        g.subTo(f, g);
    }
    BigInteger.ONE.dlShiftTo(p, f);
    f.subTo(d, d);
    while(d.t < p)d[d.t++] = 0;
    while(--s >= 0){
        var c = g[--u] == b ? this.DM : Math.floor(g[u] * A + (g[u - 1] + x) * z);
        if ((g[u] += d.am(0, c, g, s, 0, p)) < c) {
            d.dlShiftTo(s, f);
            g.subTo(f, g);
            while(g[u] < --c)g.subTo(f, g);
        }
    }
    if (h != null) {
        g.drShiftTo(p, h);
        if (a != l) BigInteger.ZERO.subTo(h, h);
    }
    g.t = p;
    g.clamp();
    if (v > 0) g.rShiftTo(v, g);
    if (a < 0) BigInteger.ZERO.subTo(g, g);
}
function bnMod(b) {
    var c = nbi();
    this.abs().divRemTo(b, null, c);
    if (this.s < 0 && c.compareTo(BigInteger.ZERO) > 0) b.subTo(c, c);
    return c;
}
function Classic(a) {
    this.m = a;
}
function cConvert(a) {
    if (a.s < 0 || a.compareTo(this.m) >= 0) return a.mod(this.m);
    else return a;
}
function cRevert(a) {
    return a;
}
function cReduce(a) {
    a.divRemTo(this.m, null, a);
}
function cMulTo(a, c, b) {
    a.multiplyTo(c, b);
    this.reduce(b);
}
function cSqrTo(a, b) {
    a.squareTo(b);
    this.reduce(b);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
    if (this.t < 1) return 0;
    var a = this[0];
    if ((a & 1) == 0) return 0;
    var b = a & 3;
    b = b * (2 - (a & 15) * b) & 15;
    b = b * (2 - (a & 255) * b) & 255;
    b = b * (2 - ((a & 65535) * b & 65535)) & 65535;
    b = b * (2 - a * b % this.DV) % this.DV;
    return b > 0 ? this.DV - b : -b;
}
function Montgomery(a) {
    this.m = a;
    this.mp = a.invDigit();
    this.mpl = this.mp & 32767;
    this.mph = this.mp >> 15;
    this.um = (1 << a.DB - 15) - 1;
    this.mt2 = 2 * a.t;
}
function montConvert(a) {
    var b = nbi();
    a.abs().dlShiftTo(this.m.t, b);
    b.divRemTo(this.m, null, b);
    if (a.s < 0 && b.compareTo(BigInteger.ZERO) > 0) this.m.subTo(b, b);
    return b;
}
function montRevert(a) {
    var b = nbi();
    a.copyTo(b);
    this.reduce(b);
    return b;
}
function montReduce(a) {
    while(a.t <= this.mt2)a[a.t++] = 0;
    for(var c = 0; c < this.m.t; ++c){
        var b = a[c] & 32767;
        var d = b * this.mpl + ((b * this.mph + (a[c] >> 15) * this.mpl & this.um) << 15) & a.DM;
        b = c + this.m.t;
        a[b] += this.m.am(0, d, a, c, 0, this.m.t);
        while(a[b] >= a.DV){
            a[b] -= a.DV;
            a[++b]++;
        }
    }
    a.clamp();
    a.drShiftTo(this.m.t, a);
    if (a.compareTo(this.m) >= 0) a.subTo(this.m, a);
}
function montSqrTo(a, b) {
    a.squareTo(b);
    this.reduce(b);
}
function montMulTo(a, c, b) {
    a.multiplyTo(c, b);
    this.reduce(b);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
    return (this.t > 0 ? this[0] & 1 : this.s) == 0;
}
function bnpExp(h, j) {
    if (h > 4294967295 || h < 1) return BigInteger.ONE;
    var f = nbi(), a = nbi(), d = j.convert(this), c = nbits(h) - 1;
    d.copyTo(f);
    while(--c >= 0){
        j.sqrTo(f, a);
        if ((h & 1 << c) > 0) j.mulTo(a, d, f);
        else {
            var b = f;
            f = a;
            a = b;
        }
    }
    return j.revert(f);
}
function bnModPowInt(b, a) {
    var c;
    if (b < 256 || a.isEven()) c = new Classic(a);
    else c = new Montgomery(a);
    return this.exp(b, c);
}
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */ function bnClone() {
    var a = nbi();
    this.copyTo(a);
    return a;
}
function bnIntValue() {
    if (this.s < 0) {
        if (this.t == 1) return this[0] - this.DV;
        else {
            if (this.t == 0) return -1;
        }
    } else {
        if (this.t == 1) return this[0];
        else {
            if (this.t == 0) return 0;
        }
    }
    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
}
function bnByteValue() {
    return this.t == 0 ? this.s : this[0] << 24 >> 24;
}
function bnShortValue() {
    return this.t == 0 ? this.s : this[0] << 16 >> 16;
}
function bnpChunkSize(a) {
    return Math.floor(Math.LN2 * this.DB / Math.log(a));
}
function bnSigNum() {
    if (this.s < 0) return -1;
    else {
        if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
        else return 1;
    }
}
function bnpToRadix(c) {
    if (c == null) c = 10;
    if (this.signum() == 0 || c < 2 || c > 36) return "0";
    var f = this.chunkSize(c);
    var e = Math.pow(c, f);
    var i = nbv(e), j = nbi(), h = nbi(), g = "";
    this.divRemTo(i, j, h);
    while(j.signum() > 0){
        g = (e + h.intValue()).toString(c).substr(1) + g;
        j.divRemTo(i, j, h);
    }
    return h.intValue().toString(c) + g;
}
function bnpFromRadix(m, h) {
    this.fromInt(0);
    if (h == null) h = 10;
    var f = this.chunkSize(h);
    var g = Math.pow(h, f), e = false, a = 0, l = 0;
    for(var c = 0; c < m.length; ++c){
        var k = intAt(m, c);
        if (k < 0) {
            if (m.charAt(c) == "-" && this.signum() == 0) e = true;
            continue;
        }
        l = h * l + k;
        if (++a >= f) {
            this.dMultiply(g);
            this.dAddOffset(l, 0);
            a = 0;
            l = 0;
        }
    }
    if (a > 0) {
        this.dMultiply(Math.pow(h, a));
        this.dAddOffset(l, 0);
    }
    if (e) BigInteger.ZERO.subTo(this, this);
}
function bnpFromNumber(f, e, h) {
    if ("number" == typeof e) {
        if (f < 2) this.fromInt(1);
        else {
            this.fromNumber(f, h);
            if (!this.testBit(f - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(f - 1), op_or, this);
            if (this.isEven()) this.dAddOffset(1, 0);
            while(!this.isProbablePrime(e)){
                this.dAddOffset(2, 0);
                if (this.bitLength() > f) this.subTo(BigInteger.ONE.shiftLeft(f - 1), this);
            }
        }
    } else {
        var d = new Array(), g = f & 7;
        d.length = (f >> 3) + 1;
        e.nextBytes(d);
        if (g > 0) d[0] &= (1 << g) - 1;
        else d[0] = 0;
        this.fromString(d, 256);
    }
}
function bnToByteArray() {
    var b = this.t, c = new Array();
    c[0] = this.s;
    var e = this.DB - b * this.DB % 8, f, a = 0;
    if (b-- > 0) {
        if (e < this.DB && (f = this[b] >> e) != (this.s & this.DM) >> e) c[a++] = f | this.s << this.DB - e;
        while(b >= 0){
            if (e < 8) {
                f = (this[b] & (1 << e) - 1) << 8 - e;
                f |= this[--b] >> (e += this.DB - 8);
            } else {
                f = this[b] >> (e -= 8) & 255;
                if (e <= 0) {
                    e += this.DB;
                    --b;
                }
            }
            if ((f & 128) != 0) f |= -256;
            if (a == 0 && (this.s & 128) != (f & 128)) ++a;
            if (a > 0 || f != this.s) c[a++] = f;
        }
    }
    return c;
}
function bnEquals(b) {
    return this.compareTo(b) == 0;
}
function bnMin(b) {
    return this.compareTo(b) < 0 ? this : b;
}
function bnMax(b) {
    return this.compareTo(b) > 0 ? this : b;
}
function bnpBitwiseTo(c, h, e) {
    var d, g, b = Math.min(c.t, this.t);
    for(d = 0; d < b; ++d)e[d] = h(this[d], c[d]);
    if (c.t < this.t) {
        g = c.s & this.DM;
        for(d = b; d < this.t; ++d)e[d] = h(this[d], g);
        e.t = this.t;
    } else {
        g = this.s & this.DM;
        for(d = b; d < c.t; ++d)e[d] = h(g, c[d]);
        e.t = c.t;
    }
    e.s = h(this.s, c.s);
    e.clamp();
}
function op_and(a, b) {
    return a & b;
}
function bnAnd(b) {
    var c = nbi();
    this.bitwiseTo(b, op_and, c);
    return c;
}
function op_or(a, b) {
    return a | b;
}
function bnOr(b) {
    var c = nbi();
    this.bitwiseTo(b, op_or, c);
    return c;
}
function op_xor(a, b) {
    return a ^ b;
}
function bnXor(b) {
    var c = nbi();
    this.bitwiseTo(b, op_xor, c);
    return c;
}
function op_andnot(a, b) {
    return a & ~b;
}
function bnAndNot(b) {
    var c = nbi();
    this.bitwiseTo(b, op_andnot, c);
    return c;
}
function bnNot() {
    var b = nbi();
    for(var a = 0; a < this.t; ++a)b[a] = this.DM & ~this[a];
    b.t = this.t;
    b.s = ~this.s;
    return b;
}
function bnShiftLeft(b) {
    var a = nbi();
    if (b < 0) this.rShiftTo(-b, a);
    else this.lShiftTo(b, a);
    return a;
}
function bnShiftRight(b) {
    var a = nbi();
    if (b < 0) this.lShiftTo(-b, a);
    else this.rShiftTo(b, a);
    return a;
}
function lbit(a) {
    if (a == 0) return -1;
    var b = 0;
    if ((a & 65535) == 0) {
        a >>= 16;
        b += 16;
    }
    if ((a & 255) == 0) {
        a >>= 8;
        b += 8;
    }
    if ((a & 15) == 0) {
        a >>= 4;
        b += 4;
    }
    if ((a & 3) == 0) {
        a >>= 2;
        b += 2;
    }
    if ((a & 1) == 0) ++b;
    return b;
}
function bnGetLowestSetBit() {
    for(var a = 0; a < this.t; ++a){
        if (this[a] != 0) return a * this.DB + lbit(this[a]);
    }
    if (this.s < 0) return this.t * this.DB;
    return -1;
}
function cbit(a) {
    var b = 0;
    while(a != 0){
        a &= a - 1;
        ++b;
    }
    return b;
}
function bnBitCount() {
    var c = 0, a = this.s & this.DM;
    for(var b = 0; b < this.t; ++b)c += cbit(this[b] ^ a);
    return c;
}
function bnTestBit(b) {
    var a = Math.floor(b / this.DB);
    if (a >= this.t) return this.s != 0;
    return (this[a] & 1 << b % this.DB) != 0;
}
function bnpChangeBit(c, b) {
    var a = BigInteger.ONE.shiftLeft(c);
    this.bitwiseTo(a, b, a);
    return a;
}
function bnSetBit(a) {
    return this.changeBit(a, op_or);
}
function bnClearBit(a) {
    return this.changeBit(a, op_andnot);
}
function bnFlipBit(a) {
    return this.changeBit(a, op_xor);
}
function bnpAddTo(d, f) {
    var e = 0, g = 0, b = Math.min(d.t, this.t);
    while(e < b){
        g += this[e] + d[e];
        f[e++] = g & this.DM;
        g >>= this.DB;
    }
    if (d.t < this.t) {
        g += d.s;
        while(e < this.t){
            g += this[e];
            f[e++] = g & this.DM;
            g >>= this.DB;
        }
        g += this.s;
    } else {
        g += this.s;
        while(e < d.t){
            g += d[e];
            f[e++] = g & this.DM;
            g >>= this.DB;
        }
        g += d.s;
    }
    f.s = g < 0 ? -1 : 0;
    if (g > 0) f[e++] = g;
    else if (g < -1) f[e++] = this.DV + g;
    f.t = e;
    f.clamp();
}
function bnAdd(b) {
    var c = nbi();
    this.addTo(b, c);
    return c;
}
function bnSubtract(b) {
    var c = nbi();
    this.subTo(b, c);
    return c;
}
function bnMultiply(b) {
    var c = nbi();
    this.multiplyTo(b, c);
    return c;
}
function bnSquare() {
    var a = nbi();
    this.squareTo(a);
    return a;
}
function bnDivide(b) {
    var c = nbi();
    this.divRemTo(b, c, null);
    return c;
}
function bnRemainder(b) {
    var c = nbi();
    this.divRemTo(b, null, c);
    return c;
}
function bnDivideAndRemainder(b) {
    var d = nbi(), c = nbi();
    this.divRemTo(b, d, c);
    return new Array(d, c);
}
function bnpDMultiply(a) {
    this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
}
function bnpDAddOffset(b, a) {
    if (b == 0) return;
    while(this.t <= a)this[this.t++] = 0;
    this[a] += b;
    while(this[a] >= this.DV){
        this[a] -= this.DV;
        if (++a >= this.t) this[this.t++] = 0;
        ++this[a];
    }
}
function NullExp() {}
function nNop(a) {
    return a;
}
function nMulTo(a, c, b) {
    a.multiplyTo(c, b);
}
function nSqrTo(a, b) {
    a.squareTo(b);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(a) {
    return this.exp(a, new NullExp());
}
function bnpMultiplyLowerTo(b, f, e) {
    var d = Math.min(this.t + b.t, f);
    e.s = 0;
    e.t = d;
    while(d > 0)e[--d] = 0;
    var c;
    for(c = e.t - this.t; d < c; ++d)e[d + this.t] = this.am(0, b[d], e, d, 0, this.t);
    for(c = Math.min(b.t, f); d < c; ++d)this.am(0, b[d], e, d, 0, f - d);
    e.clamp();
}
function bnpMultiplyUpperTo(b, e, d) {
    --e;
    var c = d.t = this.t + b.t - e;
    d.s = 0;
    while(--c >= 0)d[c] = 0;
    for(c = Math.max(e - this.t, 0); c < b.t; ++c)d[this.t + c - e] = this.am(e - c, b[c], d, 0, 0, this.t + c - e);
    d.clamp();
    d.drShiftTo(1, d);
}
function Barrett(a) {
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * a.t, this.r2);
    this.mu = this.r2.divide(a);
    this.m = a;
}
function barrettConvert(a) {
    if (a.s < 0 || a.t > 2 * this.m.t) return a.mod(this.m);
    else {
        if (a.compareTo(this.m) < 0) return a;
        else {
            var b = nbi();
            a.copyTo(b);
            this.reduce(b);
            return b;
        }
    }
}
function barrettRevert(a) {
    return a;
}
function barrettReduce(a) {
    a.drShiftTo(this.m.t - 1, this.r2);
    if (a.t > this.m.t + 1) {
        a.t = this.m.t + 1;
        a.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while(a.compareTo(this.r2) < 0)a.dAddOffset(1, this.m.t + 1);
    a.subTo(this.r2, a);
    while(a.compareTo(this.m) >= 0)a.subTo(this.m, a);
}
function barrettSqrTo(a, b) {
    a.squareTo(b);
    this.reduce(b);
}
function barrettMulTo(a, c, b) {
    a.multiplyTo(c, b);
    this.reduce(b);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(q, f) {
    var o = q.bitLength(), h, b = nbv(1), v;
    if (o <= 0) return b;
    else {
        if (o < 18) h = 1;
        else if (o < 48) h = 3;
        else {
            if (o < 144) h = 4;
            else if (o < 768) h = 5;
            else h = 6;
        }
    }
    if (o < 8) v = new Classic(f);
    else if (f.isEven()) v = new Barrett(f);
    else v = new Montgomery(f);
    var p = new Array(), d = 3, s = h - 1, a = (1 << h) - 1;
    p[1] = v.convert(this);
    if (h > 1) {
        var A = nbi();
        v.sqrTo(p[1], A);
        while(d <= a){
            p[d] = nbi();
            v.mulTo(A, p[d - 2], p[d]);
            d += 2;
        }
    }
    var l = q.t - 1, x, u = true, c = nbi(), y;
    o = nbits(q[l]) - 1;
    while(l >= 0){
        if (o >= s) x = q[l] >> o - s & a;
        else {
            x = (q[l] & (1 << o + 1) - 1) << s - o;
            if (l > 0) x |= q[l - 1] >> this.DB + o - s;
        }
        d = h;
        while((x & 1) == 0){
            x >>= 1;
            --d;
        }
        if ((o -= d) < 0) {
            o += this.DB;
            --l;
        }
        if (u) {
            p[x].copyTo(b);
            u = false;
        } else {
            while(d > 1){
                v.sqrTo(b, c);
                v.sqrTo(c, b);
                d -= 2;
            }
            if (d > 0) v.sqrTo(b, c);
            else {
                y = b;
                b = c;
                c = y;
            }
            v.mulTo(c, p[x], b);
        }
        while(l >= 0 && (q[l] & 1 << o) == 0){
            v.sqrTo(b, c);
            y = b;
            b = c;
            c = y;
            if (--o < 0) {
                o = this.DB - 1;
                --l;
            }
        }
    }
    return v.revert(b);
}
function bnGCD(c) {
    var b = this.s < 0 ? this.negate() : this.clone();
    var h = c.s < 0 ? c.negate() : c.clone();
    if (b.compareTo(h) < 0) {
        var e = b;
        b = h;
        h = e;
    }
    var d = b.getLowestSetBit(), f = h.getLowestSetBit();
    if (f < 0) return b;
    if (d < f) f = d;
    if (f > 0) {
        b.rShiftTo(f, b);
        h.rShiftTo(f, h);
    }
    while(b.signum() > 0){
        if ((d = b.getLowestSetBit()) > 0) b.rShiftTo(d, b);
        if ((d = h.getLowestSetBit()) > 0) h.rShiftTo(d, h);
        if (b.compareTo(h) >= 0) {
            b.subTo(h, b);
            b.rShiftTo(1, b);
        } else {
            h.subTo(b, h);
            h.rShiftTo(1, h);
        }
    }
    if (f > 0) h.lShiftTo(f, h);
    return h;
}
function bnpModInt(e) {
    if (e <= 0) return 0;
    var c = this.DV % e, b = this.s < 0 ? e - 1 : 0;
    if (this.t > 0) {
        if (c == 0) b = this[0] % e;
        else for(var a = this.t - 1; a >= 0; --a)b = (c * b + this[a]) % e;
    }
    return b;
}
function bnModInverse(f) {
    var j = f.isEven();
    if (this.isEven() && j || f.signum() == 0) return BigInteger.ZERO;
    var i = f.clone(), h = this.clone();
    var g = nbv(1), e = nbv(0), l = nbv(0), k = nbv(1);
    while(i.signum() != 0){
        while(i.isEven()){
            i.rShiftTo(1, i);
            if (j) {
                if (!g.isEven() || !e.isEven()) {
                    g.addTo(this, g);
                    e.subTo(f, e);
                }
                g.rShiftTo(1, g);
            } else if (!e.isEven()) e.subTo(f, e);
            e.rShiftTo(1, e);
        }
        while(h.isEven()){
            h.rShiftTo(1, h);
            if (j) {
                if (!l.isEven() || !k.isEven()) {
                    l.addTo(this, l);
                    k.subTo(f, k);
                }
                l.rShiftTo(1, l);
            } else if (!k.isEven()) k.subTo(f, k);
            k.rShiftTo(1, k);
        }
        if (i.compareTo(h) >= 0) {
            i.subTo(h, i);
            if (j) g.subTo(l, g);
            e.subTo(k, e);
        } else {
            h.subTo(i, h);
            if (j) l.subTo(g, l);
            k.subTo(e, k);
        }
    }
    if (h.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
    if (k.compareTo(f) >= 0) return k.subtract(f);
    if (k.signum() < 0) k.addTo(f, k);
    else return k;
    if (k.signum() < 0) return k.add(f);
    else return k;
}
var lowprimes = [
    2,
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53,
    59,
    61,
    67,
    71,
    73,
    79,
    83,
    89,
    97,
    101,
    103,
    107,
    109,
    113,
    127,
    131,
    137,
    139,
    149,
    151,
    157,
    163,
    167,
    173,
    179,
    181,
    191,
    193,
    197,
    199,
    211,
    223,
    227,
    229,
    233,
    239,
    241,
    251,
    257,
    263,
    269,
    271,
    277,
    281,
    283,
    293,
    307,
    311,
    313,
    317,
    331,
    337,
    347,
    349,
    353,
    359,
    367,
    373,
    379,
    383,
    389,
    397,
    401,
    409,
    419,
    421,
    431,
    433,
    439,
    443,
    449,
    457,
    461,
    463,
    467,
    479,
    487,
    491,
    499,
    503,
    509,
    521,
    523,
    541,
    547,
    557,
    563,
    569,
    571,
    577,
    587,
    593,
    599,
    601,
    607,
    613,
    617,
    619,
    631,
    641,
    643,
    647,
    653,
    659,
    661,
    673,
    677,
    683,
    691,
    701,
    709,
    719,
    727,
    733,
    739,
    743,
    751,
    757,
    761,
    769,
    773,
    787,
    797,
    809,
    811,
    821,
    823,
    827,
    829,
    839,
    853,
    857,
    859,
    863,
    877,
    881,
    883,
    887,
    907,
    911,
    919,
    929,
    937,
    941,
    947,
    953,
    967,
    971,
    977,
    983,
    991,
    997
];
var lplim = 67108864 / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(e) {
    var d, b = this.abs();
    if (b.t == 1 && b[0] <= lowprimes[lowprimes.length - 1]) {
        for(d = 0; d < lowprimes.length; ++d){
            if (b[0] == lowprimes[d]) return true;
        }
        return false;
    }
    if (b.isEven()) return false;
    d = 1;
    while(d < lowprimes.length){
        var a = lowprimes[d], c = d + 1;
        while(c < lowprimes.length && a < lplim)a *= lowprimes[c++];
        a = b.modInt(a);
        while(d < c){
            if (a % lowprimes[d++] == 0) return false;
        }
    }
    return b.millerRabin(e);
}
function bnpMillerRabin(f) {
    var g = this.subtract(BigInteger.ONE);
    var c = g.getLowestSetBit();
    if (c <= 0) return false;
    var h = g.shiftRight(c);
    f = f + 1 >> 1;
    if (f > lowprimes.length) f = lowprimes.length;
    var b = nbi();
    for(var e = 0; e < f; ++e){
        b.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var l = b.modPow(h, this);
        if (l.compareTo(BigInteger.ONE) != 0 && l.compareTo(g) != 0) {
            var d = 1;
            while(d++ < c && l.compareTo(g) != 0){
                l = l.modPowInt(2, this);
                if (l.compareTo(BigInteger.ONE) == 0) return false;
            }
            if (l.compareTo(g) != 0) return false;
        }
    }
    return true;
}
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
BigInteger.prototype.square = bnSquare;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */ function Arcfour() {
    this.i = 0;
    this.j = 0;
    this.S = new Array();
}
function ARC4init(d) {
    var c, a, b;
    for(c = 0; c < 256; ++c)this.S[c] = c;
    a = 0;
    for(c = 0; c < 256; ++c){
        a = a + this.S[c] + d[c % d.length] & 255;
        b = this.S[c];
        this.S[c] = this.S[a];
        this.S[a] = b;
    }
    this.i = 0;
    this.j = 0;
}
function ARC4next() {
    var a;
    this.i = this.i + 1 & 255;
    this.j = this.j + this.S[this.i] & 255;
    a = this.S[this.i];
    this.S[this.i] = this.S[this.j];
    this.S[this.j] = a;
    return this.S[a + this.S[this.i] & 255];
}
Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;
function prng_newstate() {
    return new Arcfour();
}
var rng_psize = 256;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */ var rng_state;
var rng_pool;
var rng_pptr;
function rng_seed_int(a) {
    rng_pool[rng_pptr++] ^= a & 255;
    rng_pool[rng_pptr++] ^= a >> 8 & 255;
    rng_pool[rng_pptr++] ^= a >> 16 & 255;
    rng_pool[rng_pptr++] ^= a >> 24 & 255;
    if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
}
function rng_seed_time() {
    rng_seed_int(new Date().getTime());
}
if (rng_pool == null) {
    rng_pool = new Array();
    rng_pptr = 0;
    var t;
    if (window !== undefined && (window.crypto !== undefined || window.msCrypto !== undefined)) {
        var crypto = window.crypto || window.msCrypto;
        if (crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            crypto.getRandomValues(ua);
            for(t = 0; t < 32; ++t)rng_pool[rng_pptr++] = ua[t];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for(t = 0; t < z.length; ++t)rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }
    }
    while(rng_pptr < rng_psize){
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
    }
    rng_pptr = 0;
    rng_seed_time();
}
function rng_get_byte() {
    if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
    }
    return rng_state.next();
}
function rng_get_bytes(b) {
    var a;
    for(a = 0; a < b.length; ++a)b[a] = rng_get_byte();
}
function SecureRandom() {}
SecureRandom.prototype.nextBytes = rng_get_bytes;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */ function parseBigInt(b, a) {
    return new BigInteger(b, a);
}
function linebrk(c, d) {
    var a = "";
    var b = 0;
    while(b + d < c.length){
        a += c.substring(b, b + d) + "\n";
        b += d;
    }
    return a + c.substring(b, c.length);
}
function byte2Hex(a) {
    if (a < 16) return "0" + a.toString(16);
    else return a.toString(16);
}
function pkcs1pad2(e, h) {
    if (h < e.length + 11) throw "Message too long for RSA";
    var g = new Array();
    var d = e.length - 1;
    while(d >= 0 && h > 0){
        var f = e.charCodeAt(d--);
        if (f < 128) g[--h] = f;
        else if (f > 127 && f < 2048) {
            g[--h] = f & 63 | 128;
            g[--h] = f >> 6 | 192;
        } else {
            g[--h] = f & 63 | 128;
            g[--h] = f >> 6 & 63 | 128;
            g[--h] = f >> 12 | 224;
        }
    }
    g[--h] = 0;
    var b = new SecureRandom();
    var a = new Array();
    while(h > 2){
        a[0] = 0;
        while(a[0] == 0)b.nextBytes(a);
        g[--h] = a[0];
    }
    g[--h] = 2;
    g[--h] = 0;
    return new BigInteger(g);
}
function oaep_mgf1_arr(c, a, e) {
    var b = "", d = 0;
    while(b.length < a){
        b += e(String.fromCharCode.apply(String, c.concat([
            (d & 4278190080) >> 24,
            (d & 16711680) >> 16,
            (d & 65280) >> 8,
            d & 255
        ])));
        d += 1;
    }
    return b;
}
function oaep_pad(q, a, f, l) {
    var c = KJUR.crypto.MessageDigest;
    var o = KJUR.crypto.Util;
    var b = null;
    if (!f) f = "sha1";
    if (typeof f === "string") {
        b = c.getCanonicalAlgName(f);
        l = c.getHashLength(b);
        f = function(i) {
            return hextorstr(o.hashHex(rstrtohex(i), b));
        };
    }
    if (q.length + 2 * l + 2 > a) throw "Message too long for RSA";
    var k = "", e;
    for(e = 0; e < a - q.length - 2 * l - 2; e += 1)k += "\0";
    var h = f("") + k + "\x01" + q;
    var g = new Array(l);
    new SecureRandom().nextBytes(g);
    var j = oaep_mgf1_arr(g, h.length, f);
    var p = [];
    for(e = 0; e < h.length; e += 1)p[e] = h.charCodeAt(e) ^ j.charCodeAt(e);
    var m = oaep_mgf1_arr(p, g.length, f);
    var d = [
        0
    ];
    for(e = 0; e < g.length; e += 1)d[e + 1] = g[e] ^ m.charCodeAt(e);
    return new BigInteger(d.concat(p));
}
function RSAKey() {
    this.n = null;
    this.e = 0;
    this.d = null;
    this.p = null;
    this.q = null;
    this.dmp1 = null;
    this.dmq1 = null;
    this.coeff = null;
}
function RSASetPublic(b, a) {
    this.isPublic = true;
    this.isPrivate = false;
    if (typeof b !== "string") {
        this.n = b;
        this.e = a;
    } else {
        if (b != null && a != null && b.length > 0 && a.length > 0) {
            this.n = parseBigInt(b, 16);
            this.e = parseInt(a, 16);
        } else throw "Invalid RSA public key";
    }
}
function RSADoPublic(a) {
    return a.modPowInt(this.e, this.n);
}
RSAKey.prototype.doPublic = RSADoPublic;
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.type = "RSA";
/*! (c) Tom Wu, Kenji Urushima | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */ function pkcs1unpad2(g, j) {
    var a = g.toByteArray();
    var f = 0;
    while(f < a.length && a[f] == 0)++f;
    if (a.length - f != j - 1 || a[f] != 2) return null;
    ++f;
    while(a[f] != 0){
        if (++f >= a.length) return null;
    }
    var e = "";
    while(++f < a.length){
        var h = a[f] & 255;
        if (h < 128) e += String.fromCharCode(h);
        else if (h > 191 && h < 224) {
            e += String.fromCharCode((h & 31) << 6 | a[f + 1] & 63);
            ++f;
        } else {
            e += String.fromCharCode((h & 15) << 12 | (a[f + 1] & 63) << 6 | a[f + 2] & 63);
            f += 2;
        }
    }
    return e;
}
function oaep_mgf1_str(c, a, e) {
    var b = "", d = 0;
    while(b.length < a){
        b += e(c + String.fromCharCode.apply(String, [
            (d & 4278190080) >> 24,
            (d & 16711680) >> 16,
            (d & 65280) >> 8,
            d & 255
        ]));
        d += 1;
    }
    return b;
}
function oaep_unpad(o, b, g, p) {
    var e = KJUR.crypto.MessageDigest;
    var r = KJUR.crypto.Util;
    var c = null;
    if (!g) g = "sha1";
    if (typeof g === "string") {
        c = e.getCanonicalAlgName(g);
        p = e.getHashLength(c);
        g = function(d) {
            return hextorstr(r.hashHex(rstrtohex(d), c));
        };
    }
    o = o.toByteArray();
    var h;
    for(h = 0; h < o.length; h += 1)o[h] &= 255;
    while(o.length < b)o.unshift(0);
    o = String.fromCharCode.apply(String, o);
    if (o.length < 2 * p + 2) throw "Cipher too short";
    var f = o.substr(1, p);
    var s = o.substr(p + 1);
    var q = oaep_mgf1_str(s, p, g);
    var k = [], h;
    for(h = 0; h < f.length; h += 1)k[h] = f.charCodeAt(h) ^ q.charCodeAt(h);
    var l = oaep_mgf1_str(String.fromCharCode.apply(String, k), o.length - p, g);
    var j = [];
    for(h = 0; h < s.length; h += 1)j[h] = s.charCodeAt(h) ^ l.charCodeAt(h);
    j = String.fromCharCode.apply(String, j);
    if (j.substr(0, p) !== g("")) throw "Hash mismatch";
    j = j.substr(p);
    var a = j.indexOf("\x01");
    var m = a != -1 ? j.substr(0, a).lastIndexOf("\0") : -1;
    if (m + 1 != a) throw "Malformed data";
    return j.substr(a + 1);
}
function RSASetPrivate(c, a, b) {
    this.isPrivate = true;
    if (typeof c !== "string") {
        this.n = c;
        this.e = a;
        this.d = b;
    } else {
        if (c != null && a != null && c.length > 0 && a.length > 0) {
            this.n = parseBigInt(c, 16);
            this.e = parseInt(a, 16);
            this.d = parseBigInt(b, 16);
        } else throw "Invalid RSA private key";
    }
}
function RSASetPrivateEx(g, d, e, c, b, a, h, f) {
    this.isPrivate = true;
    this.isPublic = false;
    if (g == null) throw "RSASetPrivateEx N == null";
    if (d == null) throw "RSASetPrivateEx E == null";
    if (g.length == 0) throw "RSASetPrivateEx N.length == 0";
    if (d.length == 0) throw "RSASetPrivateEx E.length == 0";
    if (g != null && d != null && g.length > 0 && d.length > 0) {
        this.n = parseBigInt(g, 16);
        this.e = parseInt(d, 16);
        this.d = parseBigInt(e, 16);
        this.p = parseBigInt(c, 16);
        this.q = parseBigInt(b, 16);
        this.dmp1 = parseBigInt(a, 16);
        this.dmq1 = parseBigInt(h, 16);
        this.coeff = parseBigInt(f, 16);
    } else throw "Invalid RSA private key in RSASetPrivateEx";
}
function RSAGenerate(b, l) {
    var a = new SecureRandom();
    var g = b >> 1;
    this.e = parseInt(l, 16);
    var c = new BigInteger(l, 16);
    var d = b / 2 - 100;
    var k = BigInteger.ONE.shiftLeft(d);
    for(;;){
        for(;;){
            this.p = new BigInteger(b - g, 1, a);
            if (this.p.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;
        }
        for(;;){
            this.q = new BigInteger(g, 1, a);
            if (this.q.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;
        }
        if (this.p.compareTo(this.q) <= 0) {
            var j = this.p;
            this.p = this.q;
            this.q = j;
        }
        var h = this.q.subtract(this.p).abs();
        if (h.bitLength() < d || h.compareTo(k) <= 0) continue;
        var i = this.p.subtract(BigInteger.ONE);
        var e = this.q.subtract(BigInteger.ONE);
        var f = i.multiply(e);
        if (f.gcd(c).compareTo(BigInteger.ONE) == 0) {
            this.n = this.p.multiply(this.q);
            if (this.n.bitLength() == b) {
                this.d = c.modInverse(f);
                this.dmp1 = this.d.mod(i);
                this.dmq1 = this.d.mod(e);
                this.coeff = this.q.modInverse(this.p);
                break;
            }
        }
    }
    this.isPrivate = true;
}
function RSADoPrivate(a) {
    if (this.p == null || this.q == null) return a.modPow(this.d, this.n);
    var c = a.mod(this.p).modPow(this.dmp1, this.p);
    var b = a.mod(this.q).modPow(this.dmq1, this.q);
    while(c.compareTo(b) < 0)c = c.add(this.p);
    return c.subtract(b).multiply(this.coeff).mod(this.p).multiply(this.q).add(b);
}
RSAKey.prototype.doPrivate = RSADoPrivate;
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */ function ECFieldElementFp(b, a) {
    this.x = a;
    this.q = b;
}
function feFpEquals(a) {
    if (a == this) return true;
    return this.q.equals(a.q) && this.x.equals(a.x);
}
function feFpToBigInteger() {
    return this.x;
}
function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
}
function feFpAdd(a) {
    return new ECFieldElementFp(this.q, this.x.add(a.toBigInteger()).mod(this.q));
}
function feFpSubtract(a) {
    return new ECFieldElementFp(this.q, this.x.subtract(a.toBigInteger()).mod(this.q));
}
function feFpMultiply(a) {
    return new ECFieldElementFp(this.q, this.x.multiply(a.toBigInteger()).mod(this.q));
}
function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
}
function feFpDivide(a) {
    return new ECFieldElementFp(this.q, this.x.multiply(a.toBigInteger().modInverse(this.q)).mod(this.q));
}
ECFieldElementFp.prototype.equals = feFpEquals;
ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
ECFieldElementFp.prototype.negate = feFpNegate;
ECFieldElementFp.prototype.add = feFpAdd;
ECFieldElementFp.prototype.subtract = feFpSubtract;
ECFieldElementFp.prototype.multiply = feFpMultiply;
ECFieldElementFp.prototype.square = feFpSquare;
ECFieldElementFp.prototype.divide = feFpDivide;
ECFieldElementFp.prototype.sqrt = function() {
    return new ECFieldElementFp(this.q, this.x.sqrt().mod(this.q));
};
function ECPointFp(c, a, d, b) {
    this.curve = c;
    this.x = a;
    this.y = d;
    if (b == null) this.z = BigInteger.ONE;
    else this.z = b;
    this.zinv = null;
}
function pointFpGetX() {
    if (this.zinv == null) this.zinv = this.z.modInverse(this.curve.q);
    return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q));
}
function pointFpGetY() {
    if (this.zinv == null) this.zinv = this.z.modInverse(this.curve.q);
    return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q));
}
function pointFpEquals(a) {
    if (a == this) return true;
    if (this.isInfinity()) return a.isInfinity();
    if (a.isInfinity()) return this.isInfinity();
    var c, b;
    c = a.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(a.z)).mod(this.curve.q);
    if (!c.equals(BigInteger.ZERO)) return false;
    b = a.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(a.z)).mod(this.curve.q);
    return b.equals(BigInteger.ZERO);
}
function pointFpIsInfinity() {
    if (this.x == null && this.y == null) return true;
    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
}
function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
}
function pointFpAdd(l) {
    if (this.isInfinity()) return l;
    if (l.isInfinity()) return this;
    var p = l.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(l.z)).mod(this.curve.q);
    var o = l.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(l.z)).mod(this.curve.q);
    if (BigInteger.ZERO.equals(o)) {
        if (BigInteger.ZERO.equals(p)) return this.twice();
        return this.curve.getInfinity();
    }
    var j = new BigInteger("3");
    var e = this.x.toBigInteger();
    var n = this.y.toBigInteger();
    var c = l.x.toBigInteger();
    var k = l.y.toBigInteger();
    var m = o.square();
    var i = m.multiply(o);
    var d = e.multiply(m);
    var g = p.square().multiply(this.z);
    var a = g.subtract(d.shiftLeft(1)).multiply(l.z).subtract(i).multiply(o).mod(this.curve.q);
    var h = d.multiply(j).multiply(p).subtract(n.multiply(i)).subtract(g.multiply(p)).multiply(l.z).add(p.multiply(i)).mod(this.curve.q);
    var f = i.multiply(this.z).multiply(l.z).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(a), this.curve.fromBigInteger(h), f);
}
function pointFpTwice() {
    if (this.isInfinity()) return this;
    if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();
    var g = new BigInteger("3");
    var c = this.x.toBigInteger();
    var h = this.y.toBigInteger();
    var e = h.multiply(this.z);
    var j = e.multiply(h).mod(this.curve.q);
    var i = this.curve.a.toBigInteger();
    var k = c.square().multiply(g);
    if (!BigInteger.ZERO.equals(i)) k = k.add(this.z.square().multiply(i));
    k = k.mod(this.curve.q);
    var b = k.square().subtract(c.shiftLeft(3).multiply(j)).shiftLeft(1).multiply(e).mod(this.curve.q);
    var f = k.multiply(g).multiply(c).subtract(j.shiftLeft(1)).shiftLeft(2).multiply(j).subtract(k.square().multiply(k)).mod(this.curve.q);
    var d = e.square().multiply(e).shiftLeft(3).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(b), this.curve.fromBigInteger(f), d);
}
function pointFpMultiply(d) {
    if (this.isInfinity()) return this;
    if (d.signum() == 0) return this.curve.getInfinity();
    var m = d;
    var l = m.multiply(new BigInteger("3"));
    var b = this.negate();
    var j = this;
    var q = this.curve.q.subtract(d);
    var o = q.multiply(new BigInteger("3"));
    var c = new ECPointFp(this.curve, this.x, this.y);
    var a = c.negate();
    var g;
    for(g = l.bitLength() - 2; g > 0; --g){
        j = j.twice();
        var n = l.testBit(g);
        var f = m.testBit(g);
        if (n != f) j = j.add(n ? this : b);
    }
    for(g = o.bitLength() - 2; g > 0; --g){
        c = c.twice();
        var p = o.testBit(g);
        var r = q.testBit(g);
        if (p != r) c = c.add(p ? c : a);
    }
    return j;
}
function pointFpMultiplyTwo(c, a, b) {
    var d;
    if (c.bitLength() > b.bitLength()) d = c.bitLength() - 1;
    else d = b.bitLength() - 1;
    var f = this.curve.getInfinity();
    var e = this.add(a);
    while(d >= 0){
        f = f.twice();
        if (c.testBit(d)) {
            if (b.testBit(d)) f = f.add(e);
            else f = f.add(this);
        } else if (b.testBit(d)) f = f.add(a);
        --d;
    }
    return f;
}
ECPointFp.prototype.getX = pointFpGetX;
ECPointFp.prototype.getY = pointFpGetY;
ECPointFp.prototype.equals = pointFpEquals;
ECPointFp.prototype.isInfinity = pointFpIsInfinity;
ECPointFp.prototype.negate = pointFpNegate;
ECPointFp.prototype.add = pointFpAdd;
ECPointFp.prototype.twice = pointFpTwice;
ECPointFp.prototype.multiply = pointFpMultiply;
ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
function ECCurveFp(e, d, c) {
    this.q = e;
    this.a = this.fromBigInteger(d);
    this.b = this.fromBigInteger(c);
    this.infinity = new ECPointFp(this, null, null);
}
function curveFpGetQ() {
    return this.q;
}
function curveFpGetA() {
    return this.a;
}
function curveFpGetB() {
    return this.b;
}
function curveFpEquals(a) {
    if (a == this) return true;
    return this.q.equals(a.q) && this.a.equals(a.a) && this.b.equals(a.b);
}
function curveFpGetInfinity() {
    return this.infinity;
}
function curveFpFromBigInteger(a) {
    return new ECFieldElementFp(this.q, a);
}
function curveFpDecodePointHex(m) {
    switch(parseInt(m.substr(0, 2), 16)){
        case 0:
            return this.infinity;
        case 2:
        case 3:
            var c = m.substr(0, 2);
            var l = m.substr(2);
            var j = this.fromBigInteger(new BigInteger(k, 16));
            var i = this.getA();
            var h = this.getB();
            var e = j.square().add(i).multiply(j).add(h);
            var g = e.sqrt();
            if (c == "03") g = g.negate();
            return new ECPointFp(this, j, g);
        case 4:
        case 6:
        case 7:
            var d = (m.length - 2) / 2;
            var k = m.substr(2, d);
            var f = m.substr(d + 2, d);
            return new ECPointFp(this, this.fromBigInteger(new BigInteger(k, 16)), this.fromBigInteger(new BigInteger(f, 16)));
        default:
            return null;
    }
}
ECCurveFp.prototype.getQ = curveFpGetQ;
ECCurveFp.prototype.getA = curveFpGetA;
ECCurveFp.prototype.getB = curveFpGetB;
ECCurveFp.prototype.equals = curveFpEquals;
ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
 */ ECFieldElementFp.prototype.getByteLength = function() {
    return Math.floor((this.toBigInteger().bitLength() + 7) / 8);
};
ECPointFp.prototype.getEncoded = function(c) {
    var d = function(h, f) {
        var g = h.toByteArrayUnsigned();
        if (f < g.length) g = g.slice(g.length - f);
        else while(f > g.length)g.unshift(0);
        return g;
    };
    var a = this.getX().toBigInteger();
    var e = this.getY().toBigInteger();
    var b = d(a, 32);
    if (c) {
        if (e.isEven()) b.unshift(2);
        else b.unshift(3);
    } else {
        b.unshift(4);
        b = b.concat(d(e, 32));
    }
    return b;
};
ECPointFp.decodeFrom = function(g, c) {
    var f = c[0];
    var e = c.length - 1;
    var d = c.slice(1, 1 + e / 2);
    var b = c.slice(1 + e / 2, 1 + e);
    d.unshift(0);
    b.unshift(0);
    var a = new BigInteger(d);
    var h = new BigInteger(b);
    return new ECPointFp(g, g.fromBigInteger(a), g.fromBigInteger(h));
};
ECPointFp.decodeFromHex = function(g, c) {
    var f = c.substr(0, 2);
    var e = c.length - 2;
    var d = c.substr(2, e / 2);
    var b = c.substr(2 + e / 2, e / 2);
    var a = new BigInteger(d, 16);
    var h = new BigInteger(b, 16);
    return new ECPointFp(g, g.fromBigInteger(a), g.fromBigInteger(h));
};
ECPointFp.prototype.add2D = function(c) {
    if (this.isInfinity()) return c;
    if (c.isInfinity()) return this;
    if (this.x.equals(c.x)) {
        if (this.y.equals(c.y)) return this.twice();
        return this.curve.getInfinity();
    }
    var g = c.x.subtract(this.x);
    var e = c.y.subtract(this.y);
    var a = e.divide(g);
    var d = a.square().subtract(this.x).subtract(c.x);
    var f = a.multiply(this.x.subtract(d)).subtract(this.y);
    return new ECPointFp(this.curve, d, f);
};
ECPointFp.prototype.twice2D = function() {
    if (this.isInfinity()) return this;
    if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();
    var b = this.curve.fromBigInteger(BigInteger.valueOf(2));
    var e = this.curve.fromBigInteger(BigInteger.valueOf(3));
    var a = this.x.square().multiply(e).add(this.curve.a).divide(this.y.multiply(b));
    var c = a.square().subtract(this.x.multiply(b));
    var d = a.multiply(this.x.subtract(c)).subtract(this.y);
    return new ECPointFp(this.curve, c, d);
};
ECPointFp.prototype.multiply2D = function(b) {
    if (this.isInfinity()) return this;
    if (b.signum() == 0) return this.curve.getInfinity();
    var g = b;
    var f = g.multiply(new BigInteger("3"));
    var l = this.negate();
    var d = this;
    var c;
    for(c = f.bitLength() - 2; c > 0; --c){
        d = d.twice();
        var a = f.testBit(c);
        var j = g.testBit(c);
        if (a != j) d = d.add2D(a ? this : l);
    }
    return d;
};
ECPointFp.prototype.isOnCurve = function() {
    var d = this.getX().toBigInteger();
    var i = this.getY().toBigInteger();
    var f = this.curve.getA().toBigInteger();
    var c = this.curve.getB().toBigInteger();
    var h = this.curve.getQ();
    var e = i.multiply(i).mod(h);
    var g = d.multiply(d).multiply(d).add(f.multiply(d)).add(c).mod(h);
    return e.equals(g);
};
ECPointFp.prototype.toString = function() {
    return "(" + this.getX().toBigInteger().toString() + "," + this.getY().toBigInteger().toString() + ")";
};
ECPointFp.prototype.validate = function() {
    var c = this.curve.getQ();
    if (this.isInfinity()) throw new Error("Point is at infinity.");
    var a = this.getX().toBigInteger();
    var b = this.getY().toBigInteger();
    if (a.compareTo(BigInteger.ONE) < 0 || a.compareTo(c.subtract(BigInteger.ONE)) > 0) throw new Error("x coordinate out of bounds");
    if (b.compareTo(BigInteger.ONE) < 0 || b.compareTo(c.subtract(BigInteger.ONE)) > 0) throw new Error("y coordinate out of bounds");
    if (!this.isOnCurve()) throw new Error("Point is not on the curve.");
    if (this.multiply(c).isInfinity()) throw new Error("Point is not a scalar multiple of G.");
    return true;
};
/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */ var jsonParse = function() {
    var e = "(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)";
    var j = '(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
    var i = '(?:"' + j + '*")';
    var d = new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|" + e + "|" + i + ")", "g");
    var k = new RegExp("\\\\(?:([^u])|u(.{4}))", "g");
    var g = {
        '"': '"',
        "/": "/",
        "\\": "\\",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
    };
    function h(l, m, n) {
        return m ? g[m] : String.fromCharCode(parseInt(n, 16));
    }
    var c = new String("");
    var a = "\\";
    var f = {
        "{": Object,
        "[": Array
    };
    var b = Object.hasOwnProperty;
    return function(u, q) {
        var p = u.match(d);
        var x;
        var v = p[0];
        var l = false;
        if ("{" === v) x = {};
        else if ("[" === v) x = [];
        else {
            x = [];
            l = true;
        }
        var t;
        var r = [
            x
        ];
        for(var o = 1 - l, m = p.length; o < m; ++o){
            v = p[o];
            var w;
            switch(v.charCodeAt(0)){
                default:
                    w = r[0];
                    w[t || w.length] = +v;
                    t = void 0;
                    break;
                case 34:
                    v = v.substring(1, v.length - 1);
                    if (v.indexOf(a) !== -1) v = v.replace(k, h);
                    w = r[0];
                    if (!t) {
                        if (w instanceof Array) t = w.length;
                        else {
                            t = v || c;
                            break;
                        }
                    }
                    w[t] = v;
                    t = void 0;
                    break;
                case 91:
                    w = r[0];
                    r.unshift(w[t || w.length] = []);
                    t = void 0;
                    break;
                case 93:
                    r.shift();
                    break;
                case 102:
                    w = r[0];
                    w[t || w.length] = false;
                    t = void 0;
                    break;
                case 110:
                    w = r[0];
                    w[t || w.length] = null;
                    t = void 0;
                    break;
                case 116:
                    w = r[0];
                    w[t || w.length] = true;
                    t = void 0;
                    break;
                case 123:
                    w = r[0];
                    r.unshift(w[t || w.length] = {});
                    t = void 0;
                    break;
                case 125:
                    r.shift();
                    break;
            }
        }
        if (l) {
            if (r.length !== 1) throw new Error();
            x = x[0];
        } else {
            if (r.length) throw new Error();
        }
        if (q) {
            var s = function(C, B) {
                var D = C[B];
                if (D && typeof D === "object") {
                    var n = null;
                    for(var z in D)if (b.call(D, z) && D !== C) {
                        var y = s(D, z);
                        if (y !== void 0) D[z] = y;
                        else {
                            if (!n) n = [];
                            n.push(z);
                        }
                    }
                    if (n) for(var A = n.length; --A >= 0;)delete D[n[A]];
                }
                return q.call(C, B, D);
            };
            x = s({
                "": x
            }, "");
        }
        return x;
    };
}();
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};
KJUR.asn1.ASN1Util = new function() {
    this.integerToByteHex = function(a) {
        var b = a.toString(16);
        if (b.length % 2 == 1) b = "0" + b;
        return b;
    };
    this.bigIntToMinTwosComplementsHex = function(a) {
        return twoscompl(a);
    };
    this.getPEMStringFromHex = function(a, b) {
        return hextopem(a, b);
    };
    this.newObject = function(k) {
        var F = KJUR, o = F.asn1, v = o.ASN1Object, B = o.DERBoolean, e = o.DERInteger, t = o.DERBitString, h = o.DEROctetString, x = o.DERNull, y = o.DERObjectIdentifier, m = o.DEREnumerated, g = o.DERUTF8String, f = o.DERNumericString, A = o.DERPrintableString, w = o.DERTeletexString, q = o.DERIA5String, E = o.DERUTCTime, j = o.DERGeneralizedTime, b = o.DERVisibleString, l = o.DERBMPString, n = o.DERSequence, c = o.DERSet, s = o.DERTaggedObject, p = o.ASN1Util.newObject;
        if (k instanceof o.ASN1Object) return k;
        var u = Object.keys(k);
        if (u.length != 1) throw new Error("key of param shall be only one.");
        var H = u[0];
        if (":asn1:bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":" + H + ":") == -1) throw new Error("undefined key: " + H);
        if (H == "bool") return new B(k[H]);
        if (H == "int") return new e(k[H]);
        if (H == "bitstr") return new t(k[H]);
        if (H == "octstr") return new h(k[H]);
        if (H == "null") return new x(k[H]);
        if (H == "oid") return new y(k[H]);
        if (H == "enum") return new m(k[H]);
        if (H == "utf8str") return new g(k[H]);
        if (H == "numstr") return new f(k[H]);
        if (H == "prnstr") return new A(k[H]);
        if (H == "telstr") return new w(k[H]);
        if (H == "ia5str") return new q(k[H]);
        if (H == "utctime") return new E(k[H]);
        if (H == "gentime") return new j(k[H]);
        if (H == "visstr") return new b(k[H]);
        if (H == "bmpstr") return new l(k[H]);
        if (H == "asn1") return new v(k[H]);
        if (H == "seq") {
            var d = k[H];
            var G = [];
            for(var z = 0; z < d.length; z++){
                var D = p(d[z]);
                G.push(D);
            }
            return new n({
                array: G
            });
        }
        if (H == "set") {
            var d = k[H];
            var G = [];
            for(var z = 0; z < d.length; z++){
                var D = p(d[z]);
                G.push(D);
            }
            return new c({
                array: G
            });
        }
        if (H == "tag") {
            var C = k[H];
            if (Object.prototype.toString.call(C) === "[object Array]" && C.length == 3) {
                var r = p(C[2]);
                return new s({
                    tag: C[0],
                    explicit: C[1],
                    obj: r
                });
            } else return new s(C);
        }
    };
    this.jsonToASN1HEX = function(b) {
        var a = this.newObject(b);
        return a.tohex();
    };
};
KJUR.asn1.ASN1Util.oidHexToInt = function(a) {
    var j = "";
    var k = parseInt(a.substr(0, 2), 16);
    var d = Math.floor(k / 40);
    var c = k % 40;
    var j = d + "." + c;
    var e = "";
    for(var f = 2; f < a.length; f += 2){
        var g = parseInt(a.substr(f, 2), 16);
        var h = ("00000000" + g.toString(2)).slice(-8);
        e = e + h.substr(1, 7);
        if (h.substr(0, 1) == "0") {
            var b = new BigInteger(e, 2);
            j = j + "." + b.toString(10);
            e = "";
        }
    }
    return j;
};
KJUR.asn1.ASN1Util.oidIntToHex = function(f) {
    var e = function(a) {
        var k = a.toString(16);
        if (k.length == 1) k = "0" + k;
        return k;
    };
    var d = function(o) {
        var n = "";
        var k = new BigInteger(o, 10);
        var a = k.toString(2);
        var l = 7 - a.length % 7;
        if (l == 7) l = 0;
        var q = "";
        for(var m = 0; m < l; m++)q += "0";
        a = q + a;
        for(var m = 0; m < a.length - 1; m += 7){
            var p = a.substr(m, 7);
            if (m != a.length - 7) p = "1" + p;
            n += e(parseInt(p, 2));
        }
        return n;
    };
    if (!f.match(/^[0-9.]+$/)) throw "malformed oid string: " + f;
    var g = "";
    var b = f.split(".");
    var j = parseInt(b[0]) * 40 + parseInt(b[1]);
    g += e(j);
    b.splice(0, 2);
    for(var c = 0; c < b.length; c++)g += d(b[c]);
    return g;
};
KJUR.asn1.ASN1Object = function(e) {
    var c = true;
    var b = null;
    var d = "00";
    var f = "00";
    var a = "";
    this.params = null;
    this.getLengthHexFromValue = function() {
        if (typeof this.hV == "undefined" || this.hV == null) throw new Error("this.hV is null or undefined");
        if (this.hV.length % 2 == 1) throw new Error("value hex must be even length: n=" + a.length + ",v=" + this.hV);
        var j = this.hV.length / 2;
        var i = j.toString(16);
        if (i.length % 2 == 1) i = "0" + i;
        if (j < 128) return i;
        else {
            var h = i.length / 2;
            if (h > 15) throw new Error("ASN.1 length too long to represent by 8x: n = " + j.toString(16));
            var g = 128 + h;
            return g.toString(16) + i;
        }
    };
    this.tohex = function() {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
        }
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.getValueHex = function() {
        this.tohex();
        return this.hV;
    };
    this.getFreshValueHex = function() {
        return "";
    };
    this.setByParam = function(g) {
        this.params = g;
    };
    if (e != undefined) {
        if (e.tlv != undefined) {
            this.hTLV = e.tlv;
            this.isModified = false;
        }
    }
};
KJUR.asn1.DERAbstractString = function(c) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    var b = null;
    var a = null;
    this.getString = function() {
        return this.s;
    };
    this.setString = function(d) {
        this.hTLV = null;
        this.isModified = true;
        this.s = d;
        this.hV = utf8tohex(this.s).toLowerCase();
    };
    this.setStringHex = function(d) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = d;
    };
    this.getFreshValueHex = function() {
        return this.hV;
    };
    if (typeof c != "undefined") {
        if (typeof c == "string") this.setString(c);
        else {
            if (typeof c.str != "undefined") this.setString(c.str);
            else if (typeof c.hex != "undefined") this.setStringHex(c.hex);
        }
    }
};
extendClass(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
KJUR.asn1.DERAbstractTime = function(c) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
    var b = null;
    var a = null;
    this.localDateToUTC = function(g) {
        var e = g.getTime() + g.getTimezoneOffset() * 60000;
        var f = new Date(e);
        return f;
    };
    this.formatDate = function(m, o, e) {
        var g = this.zeroPadding;
        var n = this.localDateToUTC(m);
        var p = String(n.getFullYear());
        if (o == "utc") p = p.substr(2, 2);
        var l = g(String(n.getMonth() + 1), 2);
        var q = g(String(n.getDate()), 2);
        var h = g(String(n.getHours()), 2);
        var i = g(String(n.getMinutes()), 2);
        var j = g(String(n.getSeconds()), 2);
        var r = p + l + q + h + i + j;
        if (e === true) {
            var f = n.getMilliseconds();
            if (f != 0) {
                var k = g(String(f), 3);
                k = k.replace(/[0]+$/, "");
                r = r + "." + k;
            }
        }
        return r + "Z";
    };
    this.zeroPadding = function(e, d) {
        if (e.length >= d) return e;
        return new Array(d - e.length + 1).join("0") + e;
    };
    this.setByParam = function(d) {
        this.hV = null;
        this.hTLV = null;
        this.params = d;
    };
    this.getString = function() {
        return undefined;
    };
    this.setString = function(d) {
        this.hTLV = null;
        this.isModified = true;
        if (this.params == undefined) this.params = {};
        this.params.str = d;
    };
    this.setByDate = function(d) {
        this.hTLV = null;
        this.isModified = true;
        if (this.params == undefined) this.params = {};
        this.params.date = d;
    };
    this.setByDateValue = function(h, j, e, d, f, g) {
        var i = new Date(Date.UTC(h, j - 1, e, d, f, g, 0));
        this.setByDate(i);
    };
    this.getFreshValueHex = function() {
        return this.hV;
    };
};
extendClass(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
KJUR.asn1.DERAbstractStructured = function(b) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    var a = null;
    this.setByASN1ObjectArray = function(c) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = c;
    };
    this.appendASN1Object = function(c) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(c);
    };
    this.asn1Array = new Array();
    if (typeof b != "undefined") {
        if (typeof b.array != "undefined") this.asn1Array = b.array;
    }
};
extendClass(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
KJUR.asn1.DERBoolean = function(a) {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = "01";
    if (a == false) this.hTLV = "010100";
    else this.hTLV = "0101ff";
};
extendClass(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
KJUR.asn1.DERInteger = function(b) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = "02";
    this.params = null;
    var a = twoscompl;
    this.setByBigInteger = function(c) {
        this.isModified = true;
        this.params = {
            bigint: c
        };
    };
    this.setByInteger = function(c) {
        this.isModified = true;
        this.params = c;
    };
    this.setValueHex = function(c) {
        this.isModified = true;
        this.params = {
            hex: c
        };
    };
    this.getFreshValueHex = function() {
        var d = this.params;
        var c = null;
        if (d == null) throw new Error("value not set");
        if (typeof d == "object" && d.hex != undefined) {
            this.hV = d.hex;
            return this.hV;
        }
        if (typeof d == "number") c = new BigInteger(String(d), 10);
        else if (d["int"] != undefined) c = new BigInteger(String(d["int"]), 10);
        else {
            if (d.bigint != undefined) c = d.bigint;
            else throw new Error("wrong parameter");
        }
        this.hV = a(c);
        return this.hV;
    };
    if (b != undefined) this.params = b;
};
extendClass(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
KJUR.asn1.DERBitString = function(b) {
    if (b !== undefined && typeof b.obj !== "undefined") {
        var a = KJUR.asn1.ASN1Util.newObject(b.obj);
        b.hex = "00" + a.tohex();
    }
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = "03";
    this.setHexValueIncludingUnusedBits = function(c) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = c;
    };
    this.setUnusedBitsAndHexValue = function(c, e) {
        if (c < 0 || 7 < c) throw "unused bits shall be from 0 to 7: u = " + c;
        var d = "0" + c;
        this.hTLV = null;
        this.isModified = true;
        this.hV = d + e;
    };
    this.setByBinaryString = function(e) {
        e = e.replace(/0+$/, "");
        var f = 8 - e.length % 8;
        if (f == 8) f = 0;
        e += "0000000".substr(0, f);
        var j = "";
        for(var g = 0; g < e.length - 1; g += 8){
            var d = e.substr(g, 8);
            var c = parseInt(d, 2).toString(16);
            if (c.length == 1) c = "0" + c;
            j += c;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = "0" + f + j;
    };
    this.setByBooleanArray = function(e) {
        var d = "";
        for(var c = 0; c < e.length; c++)if (e[c] == true) d += "1";
        else d += "0";
        this.setByBinaryString(d);
    };
    this.newFalseArray = function(e) {
        var c = new Array(e);
        for(var d = 0; d < e; d++)c[d] = false;
        return c;
    };
    this.getFreshValueHex = function() {
        return this.hV;
    };
    if (typeof b != "undefined") {
        if (typeof b == "string" && b.toLowerCase().match(/^[0-9a-f]+$/)) this.setHexValueIncludingUnusedBits(b);
        else if (typeof b.hex != "undefined") this.setHexValueIncludingUnusedBits(b.hex);
        else {
            if (typeof b.bin != "undefined") this.setByBinaryString(b.bin);
            else if (typeof b.array != "undefined") this.setByBooleanArray(b.array);
        }
    }
};
extendClass(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
KJUR.asn1.DEROctetString = function(b) {
    if (b !== undefined && typeof b.obj !== "undefined") {
        var a = KJUR.asn1.ASN1Util.newObject(b.obj);
        b.hex = a.tohex();
    }
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, b);
    this.hT = "04";
};
extendClass(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERNull = function() {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = "05";
    this.hTLV = "0500";
};
extendClass(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
KJUR.asn1.DERObjectIdentifier = function(a) {
    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = "06";
    this.setValueHex = function(b) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = b;
    };
    this.setValueOidString = function(b) {
        var c = oidtohex(b);
        if (c == null) throw new Error("malformed oid string: " + b);
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = c;
    };
    this.setValueName = function(c) {
        var b = KJUR.asn1.x509.OID.name2oid(c);
        if (b !== "") this.setValueOidString(b);
        else throw new Error("DERObjectIdentifier oidName undefined: " + c);
    };
    this.setValueNameOrOid = function(b) {
        if (b.match(/^[0-2].[0-9.]+$/)) this.setValueOidString(b);
        else this.setValueName(b);
    };
    this.getFreshValueHex = function() {
        return this.hV;
    };
    this.setByParam = function(b) {
        if (typeof b === "string") this.setValueNameOrOid(b);
        else if (b.oid !== undefined) this.setValueNameOrOid(b.oid);
        else {
            if (b.name !== undefined) this.setValueNameOrOid(b.name);
            else if (b.hex !== undefined) this.setValueHex(b.hex);
        }
    };
    if (a !== undefined) this.setByParam(a);
};
extendClass(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
KJUR.asn1.DEREnumerated = function(a) {
    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
    this.hT = "0a";
    this.setByBigInteger = function(b) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = twoscompl(b);
    };
    this.setByInteger = function(c) {
        var b = new BigInteger(String(c), 10);
        this.setByBigInteger(b);
    };
    this.setValueHex = function(b) {
        this.hV = b;
    };
    this.getFreshValueHex = function() {
        return this.hV;
    };
    if (typeof a != "undefined") {
        if (typeof a["int"] != "undefined") this.setByInteger(a["int"]);
        else {
            if (typeof a == "number") this.setByInteger(a);
            else if (typeof a.hex != "undefined") this.setValueHex(a.hex);
        }
    }
};
extendClass(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);
KJUR.asn1.DERUTF8String = function(a) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, a);
    this.hT = "0c";
};
extendClass(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERNumericString = function(a) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, a);
    this.hT = "12";
};
extendClass(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERPrintableString = function(a) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, a);
    this.hT = "13";
};
extendClass(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERTeletexString = function(a) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, a);
    this.hT = "14";
};
extendClass(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERIA5String = function(a) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, a);
    this.hT = "16";
};
extendClass(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERVisibleString = function(a) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, a);
    this.hT = "1a";
};
extendClass(KJUR.asn1.DERVisibleString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERBMPString = function(a) {
    KJUR.asn1.DERBMPString.superclass.constructor.call(this, a);
    this.hT = "1e";
};
extendClass(KJUR.asn1.DERBMPString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERUTCTime = function(a) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, a);
    this.hT = "17";
    this.params = undefined;
    this.getFreshValueHex = function() {
        var d = this.params;
        if (this.params == undefined) d = {
            date: new Date()
        };
        if (typeof d == "string") {
            if (d.match(/^[0-9]{12}Z$/) || d.match(/^[0-9]{12}\.[0-9]+Z$/)) this.hV = stohex(d);
            else throw new Error("malformed string for UTCTime: " + d);
        } else {
            if (d.str != undefined) this.hV = stohex(d.str);
            else if (d.date == undefined && d.millis == true) {
                var c = new Date();
                this.hV = stohex(this.formatDate(c, "utc", true));
            } else {
                if (d.date != undefined && d.date instanceof Date) {
                    var b = d.millis === true;
                    this.hV = stohex(this.formatDate(d.date, "utc", b));
                } else if (d instanceof Date) this.hV = stohex(this.formatDate(d, "utc"));
            }
        }
        if (this.hV == undefined) throw new Error("parameter not specified properly for UTCTime");
        return this.hV;
    };
    if (a != undefined) this.setByParam(a);
};
extendClass(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
KJUR.asn1.DERGeneralizedTime = function(a) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, a);
    this.hT = "18";
    this.params = a;
    this.getFreshValueHex = function() {
        var d = this.params;
        if (this.params == undefined) d = {
            date: new Date()
        };
        if (typeof d == "string") {
            if (d.match(/^[0-9]{14}Z$/) || d.match(/^[0-9]{14}\.[0-9]+Z$/)) this.hV = stohex(d);
            else throw new Error("malformed string for GeneralizedTime: " + d);
        } else {
            if (d.str != undefined) this.hV = stohex(d.str);
            else if (d.date == undefined && d.millis == true) {
                var c = new Date();
                this.hV = stohex(this.formatDate(c, "gen", true));
            } else {
                if (d.date != undefined && d.date instanceof Date) {
                    var b = d.millis === true;
                    this.hV = stohex(this.formatDate(d.date, "gen", b));
                } else if (d instanceof Date) this.hV = stohex(this.formatDate(d, "gen"));
            }
        }
        if (this.hV == undefined) throw new Error("parameter not specified properly for GeneralizedTime");
        return this.hV;
    };
    if (a != undefined) this.setByParam(a);
};
extendClass(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
KJUR.asn1.DERSequence = function(a) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, a);
    this.hT = "30";
    this.getFreshValueHex = function() {
        var c = "";
        for(var b = 0; b < this.asn1Array.length; b++){
            var d = this.asn1Array[b];
            c += d.tohex();
        }
        this.hV = c;
        return this.hV;
    };
};
extendClass(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
KJUR.asn1.DERSet = function(a) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, a);
    this.hT = "31";
    this.sortFlag = true;
    this.getFreshValueHex = function() {
        var b = new Array();
        for(var c = 0; c < this.asn1Array.length; c++){
            var d = this.asn1Array[c];
            b.push(d.tohex());
        }
        if (this.sortFlag == true) b.sort();
        this.hV = b.join("");
        return this.hV;
    };
    if (typeof a != "undefined") {
        if (typeof a.sortflag != "undefined" && a.sortflag == false) this.sortFlag = false;
    }
};
extendClass(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
KJUR.asn1.DERTaggedObject = function(f) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
    var d = KJUR.asn1, e = ASN1HEX, a = e.getV, c = e.isASN1HEX, b = d.ASN1Util.newObject;
    this.hT = "a0";
    this.hV = "";
    this.isExplicit = true;
    this.asn1Object = null;
    this.params = {
        tag: "a0",
        explicit: true
    };
    this.setASN1Object = function(g, h, i) {
        this.params = {
            tag: h,
            explicit: g,
            obj: i
        };
    };
    this.getFreshValueHex = function() {
        var h = this.params;
        if (h.explicit == undefined) h.explicit = true;
        if (h.tage != undefined) {
            h.tag = h.tage;
            h.explicit = true;
        }
        if (h.tagi != undefined) {
            h.tag = h.tagi;
            h.explicit = false;
        }
        if (h.str != undefined) this.hV = utf8tohex(h.str);
        else if (h.hex != undefined) this.hV = h.hex;
        else {
            if (h.obj != undefined) {
                var g;
                if (h.obj instanceof d.ASN1Object) g = h.obj.tohex();
                else if (typeof h.obj == "object") g = b(h.obj).tohex();
                if (h.explicit) this.hV = g;
                else this.hV = a(g, 0);
            } else throw new Error("str, hex nor obj not specified");
        }
        if (h.tag == undefined) h.tag = "a0";
        this.hT = h.tag;
        this.hTLV = null;
        this.isModified = true;
        return this.hV;
    };
    this.setByParam = function(g) {
        this.params = g;
    };
    if (f !== undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);
var ASN1HEX = new function() {};
ASN1HEX.getLblen = function(c, a) {
    if (c.substr(a + 2, 1) != "8") return 1;
    var b = parseInt(c.substr(a + 3, 1));
    if (b == 0) return -1;
    if (0 < b && b < 10) return b + 1;
    return -2;
};
ASN1HEX.getL = function(c, b) {
    var a = ASN1HEX.getLblen(c, b);
    if (a < 1) return "";
    return c.substr(b + 2, a * 2);
};
ASN1HEX.getVblen = function(d, a) {
    var c, b;
    c = ASN1HEX.getL(d, a);
    if (c == "") return -1;
    if (c.substr(0, 1) === "8") b = new BigInteger(c.substr(2), 16);
    else b = new BigInteger(c, 16);
    return b.intValue();
};
ASN1HEX.getVidx = function(c, b) {
    var a = ASN1HEX.getLblen(c, b);
    if (a < 0) return a;
    return b + (a + 1) * 2;
};
ASN1HEX.getV = function(d, a) {
    var c = ASN1HEX.getVidx(d, a);
    var b = ASN1HEX.getVblen(d, a);
    return d.substr(c, b * 2);
};
ASN1HEX.getTLV = function(b, a) {
    return b.substr(a, 2) + ASN1HEX.getL(b, a) + ASN1HEX.getV(b, a);
};
ASN1HEX.getTLVblen = function(b, a) {
    return 2 + ASN1HEX.getLblen(b, a) * 2 + ASN1HEX.getVblen(b, a) * 2;
};
ASN1HEX.getNextSiblingIdx = function(d, a) {
    var c = ASN1HEX.getVidx(d, a);
    var b = ASN1HEX.getVblen(d, a);
    return c + b * 2;
};
ASN1HEX.getChildIdx = function(e, k) {
    var l = ASN1HEX;
    var j = [];
    var c, f, g;
    c = l.getVidx(e, k);
    f = l.getVblen(e, k) * 2;
    if (e.substr(k, 2) == "03") {
        c += 2;
        f -= 2;
    }
    g = 0;
    var d = c;
    while(g <= f){
        var b = l.getTLVblen(e, d);
        g += b;
        if (g <= f) j.push(d);
        d += b;
        if (g >= f) break;
    }
    return j;
};
ASN1HEX.getNthChildIdx = function(d, b, e) {
    var c = ASN1HEX.getChildIdx(d, b);
    return c[e];
};
ASN1HEX.getIdxbyList = function(e, d, c, i) {
    var g = ASN1HEX;
    var f, b;
    if (c.length == 0) {
        if (i !== undefined) {
            if (e.substr(d, 2) !== i) return -1;
        }
        return d;
    }
    f = c.shift();
    b = g.getChildIdx(e, d);
    if (f >= b.length) return -1;
    return g.getIdxbyList(e, b[f], c, i);
};
ASN1HEX.getIdxbyListEx = function(f, k, b, g) {
    var m = ASN1HEX;
    var d, l;
    if (b.length == 0) {
        if (g !== undefined) {
            if (f.substr(k, 2) !== g) return -1;
        }
        return k;
    }
    d = b.shift();
    l = m.getChildIdx(f, k);
    var j = 0;
    for(var e = 0; e < l.length; e++){
        var c = f.substr(l[e], 2);
        if (typeof d == "number" && !m.isContextTag(c) && j == d || typeof d == "string" && m.isContextTag(c, d)) return m.getIdxbyListEx(f, l[e], b, g);
        if (!m.isContextTag(c)) j++;
    }
    return -1;
};
ASN1HEX.getTLVbyList = function(d, c, b, f) {
    var e = ASN1HEX;
    var a = e.getIdxbyList(d, c, b, f);
    if (a == -1) return null;
    if (a >= d.length) return null;
    return e.getTLV(d, a);
};
ASN1HEX.getTLVbyListEx = function(d, c, b, f) {
    var e = ASN1HEX;
    var a = e.getIdxbyListEx(d, c, b, f);
    if (a == -1) return null;
    return e.getTLV(d, a);
};
ASN1HEX.getVbyList = function(e, c, b, g, i) {
    var f = ASN1HEX;
    var a, d;
    a = f.getIdxbyList(e, c, b, g);
    if (a == -1) return null;
    if (a >= e.length) return null;
    d = f.getV(e, a);
    if (i === true) d = d.substr(2);
    return d;
};
ASN1HEX.getVbyListEx = function(b, e, a, d, f) {
    var j = ASN1HEX;
    var g, c, i;
    g = j.getIdxbyListEx(b, e, a, d);
    if (g == -1) return null;
    i = j.getV(b, g);
    if (b.substr(g, 2) == "03" && f !== false) i = i.substr(2);
    return i;
};
ASN1HEX.getInt = function(e, b, f) {
    if (f == undefined) f = -1;
    try {
        var c = e.substr(b, 2);
        if (c != "02" && c != "03") return f;
        var a = ASN1HEX.getV(e, b);
        if (c == "02") return parseInt(a, 16);
        else return bitstrtoint(a);
    } catch (d) {
        return f;
    }
};
ASN1HEX.getOID = function(c, a, d) {
    if (d == undefined) d = null;
    try {
        if (c.substr(a, 2) != "06") return d;
        var e = ASN1HEX.getV(c, a);
        return hextooid(e);
    } catch (b) {
        return d;
    }
};
ASN1HEX.getOIDName = function(d, a, f) {
    if (f == undefined) f = null;
    try {
        var e = ASN1HEX.getOID(d, a, f);
        if (e == f) return f;
        var b = KJUR.asn1.x509.OID.oid2name(e);
        if (b == "") return e;
        return b;
    } catch (c) {
        return f;
    }
};
ASN1HEX.getString = function(d, b, e) {
    if (e == undefined) e = null;
    try {
        var a = ASN1HEX.getV(d, b);
        return hextorstr(a);
    } catch (c) {
        return e;
    }
};
ASN1HEX.hextooidstr = function(e) {
    var h = function(b, a) {
        if (b.length >= a) return b;
        return new Array(a - b.length + 1).join("0") + b;
    };
    var l = [];
    var o = e.substr(0, 2);
    var f = parseInt(o, 16);
    l[0] = new String(Math.floor(f / 40));
    l[1] = new String(f % 40);
    var m = e.substr(2);
    var k = [];
    for(var g = 0; g < m.length / 2; g++)k.push(parseInt(m.substr(g * 2, 2), 16));
    var j = [];
    var d = "";
    for(var g = 0; g < k.length; g++)if (k[g] & 128) d = d + h((k[g] & 127).toString(2), 7);
    else {
        d = d + h((k[g] & 127).toString(2), 7);
        j.push(new String(parseInt(d, 2)));
        d = "";
    }
    var n = l.join(".");
    if (j.length > 0) n = n + "." + j.join(".");
    return n;
};
ASN1HEX.dump = function(t, c, l, g) {
    var p = ASN1HEX;
    var j = p.getV;
    var y = p.dump;
    var w = p.getChildIdx;
    var e = t;
    if (t instanceof KJUR.asn1.ASN1Object) e = t.tohex();
    var q = function(A, i) {
        if (A.length <= i * 2) return A;
        else {
            var v = A.substr(0, i) + "..(total " + A.length / 2 + "bytes).." + A.substr(A.length - i, i);
            return v;
        }
    };
    if (c === undefined) c = {
        ommit_long_octet: 32
    };
    if (l === undefined) l = 0;
    if (g === undefined) g = "";
    var x = c.ommit_long_octet;
    var z = e.substr(l, 2);
    if (z == "01") {
        var h = j(e, l);
        if (h == "00") return g + "BOOLEAN FALSE\n";
        else return g + "BOOLEAN TRUE\n";
    }
    if (z == "02") {
        var h = j(e, l);
        return g + "INTEGER " + q(h, x) + "\n";
    }
    if (z == "03") {
        var h = j(e, l);
        if (p.isASN1HEX(h.substr(2))) {
            var k = g + "BITSTRING, encapsulates\n";
            k = k + y(h.substr(2), c, 0, g + "  ");
            return k;
        } else return g + "BITSTRING " + q(h, x) + "\n";
    }
    if (z == "04") {
        var h = j(e, l);
        if (p.isASN1HEX(h)) {
            var k = g + "OCTETSTRING, encapsulates\n";
            k = k + y(h, c, 0, g + "  ");
            return k;
        } else return g + "OCTETSTRING " + q(h, x) + "\n";
    }
    if (z == "05") return g + "NULL\n";
    if (z == "06") {
        var m = j(e, l);
        var b = KJUR.asn1.ASN1Util.oidHexToInt(m);
        var o = KJUR.asn1.x509.OID.oid2name(b);
        var a = b.replace(/\./g, " ");
        if (o != "") return g + "ObjectIdentifier " + o + " (" + a + ")\n";
        else return g + "ObjectIdentifier (" + a + ")\n";
    }
    if (z == "0a") return g + "ENUMERATED " + parseInt(j(e, l)) + "\n";
    if (z == "0c") return g + "UTF8String '" + hextoutf8(j(e, l)) + "'\n";
    if (z == "13") return g + "PrintableString '" + hextoutf8(j(e, l)) + "'\n";
    if (z == "14") return g + "TeletexString '" + hextoutf8(j(e, l)) + "'\n";
    if (z == "16") return g + "IA5String '" + hextoutf8(j(e, l)) + "'\n";
    if (z == "17") return g + "UTCTime " + hextoutf8(j(e, l)) + "\n";
    if (z == "18") return g + "GeneralizedTime " + hextoutf8(j(e, l)) + "\n";
    if (z == "1a") return g + "VisualString '" + hextoutf8(j(e, l)) + "'\n";
    if (z == "1e") return g + "BMPString '" + ucs2hextoutf8(j(e, l)) + "'\n";
    if (z == "30") {
        if (e.substr(l, 4) == "3000") return g + "SEQUENCE {}\n";
        var k = g + "SEQUENCE\n";
        var d = w(e, l);
        var f = c;
        if ((d.length == 2 || d.length == 3) && e.substr(d[0], 2) == "06" && e.substr(d[d.length - 1], 2) == "04") {
            var o = p.oidname(j(e, d[0]));
            var r = JSON.parse(JSON.stringify(c));
            r.x509ExtName = o;
            f = r;
        }
        for(var u = 0; u < d.length; u++)k = k + y(e, f, d[u], g + "  ");
        return k;
    }
    if (z == "31") {
        var k = g + "SET\n";
        var d = w(e, l);
        for(var u = 0; u < d.length; u++)k = k + y(e, c, d[u], g + "  ");
        return k;
    }
    var z = parseInt(z, 16);
    if ((z & 128) != 0) {
        var n = z & 31;
        if ((z & 32) != 0) {
            var k = g + "[" + n + "]\n";
            var d = w(e, l);
            for(var u = 0; u < d.length; u++)k = k + y(e, c, d[u], g + "  ");
            return k;
        } else {
            var h = j(e, l);
            if (ASN1HEX.isASN1HEX(h)) {
                var k = g + "[" + n + "]\n";
                k = k + y(h, c, 0, g + "  ");
                return k;
            } else {
                if (h.substr(0, 8) == "68747470") h = hextoutf8(h);
                else if (c.x509ExtName === "subjectAltName" && n == 2) h = hextoutf8(h);
            }
            var k = g + "[" + n + "] " + h + "\n";
            return k;
        }
    }
    return g + "UNKNOWN(" + z + ") " + j(e, l) + "\n";
};
ASN1HEX.parse = function(x) {
    var t = ASN1HEX, f = t.parse, a = t.isASN1HEX, l = t.getV, b = t.getTLV, y = t.getChildIdx, i = KJUR.asn1, e = i.ASN1Util.oidHexToInt, B = i.x509.OID.oid2name, k = hextoutf8, n = ucs2hextoutf8, q = iso88591hextoutf8;
    var c = {
        "0c": "utf8str",
        "12": "numstr",
        "13": "prnstr",
        "14": "telstr",
        "16": "ia5str",
        "17": "utctime",
        "18": "gentime",
        "1a": "visstr",
        "1e": "bmpstr",
        "30": "seq",
        "31": "set"
    };
    var u = function(H) {
        var D = [];
        var E = y(H, 0);
        for(var G = 0; G < E.length; G++){
            var s = E[G];
            var d = b(H, s);
            var F = f(d);
            D.push(F);
        }
        return D;
    };
    var C = x.substr(0, 2);
    var j = {};
    var p = l(x, 0);
    if (C == "01") {
        if (x == "0101ff") return {
            bool: true
        };
        return {
            bool: false
        };
    } else {
        if (C == "02") return {
            "int": {
                hex: p
            }
        };
        else {
            if (C == "03") try {
                if (p.substr(0, 2) != "00") throw "not encap";
                var v = p.substr(2);
                if (!a(v)) throw "not encap";
                return {
                    bitstr: {
                        obj: f(v)
                    }
                };
            } catch (z) {
                var m = null;
                if (p.length <= 10) m = bitstrtobinstr(p);
                if (m == null) return {
                    bitstr: {
                        hex: p
                    }
                };
                else return {
                    bitstr: {
                        bin: m
                    }
                };
            }
            else {
                if (C == "04") try {
                    if (!a(p)) throw "not encap";
                    return {
                        octstr: {
                            obj: f(p)
                        }
                    };
                } catch (z) {
                    return {
                        octstr: {
                            hex: p
                        }
                    };
                }
                else {
                    if (C == "05") return {
                        "null": ""
                    };
                    else if (C == "06") {
                        var g = e(p);
                        var r = B(g);
                        if (r == "") return {
                            oid: g
                        };
                        else return {
                            oid: r
                        };
                    } else {
                        if (C == "0a") {
                            if (p.length > 4) return {
                                "enum": {
                                    hex: p
                                }
                            };
                            else return {
                                "enum": parseInt(p, 16)
                            };
                        } else if (C == "30" || C == "31") {
                            j[c[C]] = u(x);
                            return j;
                        } else {
                            if (C == "14") {
                                var o = q(p);
                                j[c[C]] = {
                                    str: o
                                };
                                return j;
                            } else if (C == "1e") {
                                var o = n(p);
                                j[c[C]] = {
                                    str: o
                                };
                                return j;
                            } else {
                                if (":0c:12:13:16:17:18:1a:".indexOf(C) != -1) {
                                    var o = k(p);
                                    j[c[C]] = {
                                        str: o
                                    };
                                    return j;
                                } else if (C.match(/^8[0-9]$/)) {
                                    var o = k(p);
                                    if (o == null | o == "") return {
                                        tag: {
                                            tag: C,
                                            explicit: false,
                                            hex: p
                                        }
                                    };
                                    else {
                                        if (o.match(/[\x00-\x1F\x7F-\x9F]/) != null || o.match(/[\u0000-\u001F\u0080–\u009F]/) != null) return {
                                            tag: {
                                                tag: C,
                                                explicit: false,
                                                hex: p
                                            }
                                        };
                                        else return {
                                            tag: {
                                                tag: C,
                                                explicit: false,
                                                str: o
                                            }
                                        };
                                    }
                                } else {
                                    if (C.match(/^a[0-9]$/)) try {
                                        if (!a(p)) throw new Error("not encap");
                                        return {
                                            tag: {
                                                tag: C,
                                                explicit: true,
                                                obj: f(p)
                                            }
                                        };
                                    } catch (z) {
                                        return {
                                            tag: {
                                                tag: C,
                                                explicit: true,
                                                hex: p
                                            }
                                        };
                                    }
                                    else {
                                        var A = new KJUR.asn1.ASN1Object();
                                        A.hV = p;
                                        var w = A.getLengthHexFromValue();
                                        return {
                                            asn1: {
                                                tlv: C + w + p
                                            }
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
ASN1HEX.isContextTag = function(c, b) {
    c = c.toLowerCase();
    var f, e;
    try {
        f = parseInt(c, 16);
    } catch (d) {
        return -1;
    }
    if (b === undefined) {
        if ((f & 192) == 128) return true;
        else return false;
    }
    try {
        var a = b.match(/^\[[0-9]+\]$/);
        if (a == null) return false;
        e = parseInt(b.substr(1, b.length - 1), 10);
        if (e > 31) return false;
        if ((f & 192) == 128 && (f & 31) == e) return true;
        return false;
    } catch (d) {
        return false;
    }
};
ASN1HEX.isASN1HEX = function(e) {
    var d = ASN1HEX;
    if (e.length % 2 == 1) return false;
    var c = d.getVblen(e, 0);
    var b = e.substr(0, 2);
    var f = d.getL(e, 0);
    var a = e.length - b.length - f.length;
    if (a == c * 2) return true;
    return false;
};
ASN1HEX.checkStrictDER = function(g, o, d, c, r) {
    var s = ASN1HEX;
    if (d === undefined) {
        if (typeof g != "string") throw new Error("not hex string");
        g = g.toLowerCase();
        if (!KJUR.lang.String.isHex(g)) throw new Error("not hex string");
        d = g.length;
        c = g.length / 2;
        if (c < 128) r = 1;
        else r = Math.ceil(c.toString(16)) + 1;
    }
    var k = s.getL(g, o);
    if (k.length > r * 2) throw new Error("L of TLV too long: idx=" + o);
    var n = s.getVblen(g, o);
    if (n > c) throw new Error("value of L too long than hex: idx=" + o);
    var q = s.getTLV(g, o);
    var f = q.length - 2 - s.getL(g, o).length;
    if (f !== n * 2) throw new Error("V string length and L's value not the same:" + f + "/" + n * 2);
    if (o === 0) {
        if (g.length != q.length) throw new Error("total length and TLV length unmatch:" + g.length + "!=" + q.length);
    }
    var b = g.substr(o, 2);
    if (b === "02") {
        var a = s.getVidx(g, o);
        if (g.substr(a, 2) == "00" && g.charCodeAt(a + 2) < 56) throw new Error("not least zeros for DER INTEGER");
    }
    if (parseInt(b, 16) & 32) {
        var p = s.getVblen(g, o);
        var m = 0;
        var l = s.getChildIdx(g, o);
        for(var e = 0; e < l.length; e++){
            var j = s.getTLV(g, l[e]);
            m += j.length;
            s.checkStrictDER(g, l[e], d, c, r);
        }
        if (p * 2 != m) throw new Error("sum of children's TLV length and L unmatch: " + p * 2 + "!=" + m);
    }
};
ASN1HEX.oidname = function(a) {
    var c = KJUR.asn1;
    if (KJUR.lang.String.isHex(a)) a = c.ASN1Util.oidHexToInt(a);
    var b = c.x509.OID.oid2name(a);
    if (b === "") b = a;
    return b;
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};
if (typeof KJUR.asn1.x509 == "undefined" || !KJUR.asn1.x509) KJUR.asn1.x509 = {};
KJUR.asn1.x509.Certificate = function(h) {
    KJUR.asn1.x509.Certificate.superclass.constructor.call(this);
    var d = KJUR, c = d.asn1, f = c.DERBitString, b = c.DERSequence, g = c.x509, a = g.TBSCertificate, e = g.AlgorithmIdentifier;
    this.params = undefined;
    this.setByParam = function(i) {
        this.params = i;
    };
    this.sign = function() {
        var l = this.params;
        var k = l.sigalg;
        if (l.sigalg.name != undefined) k = l.sigalg.name;
        var i = l.tbsobj.tohex();
        var j = new KJUR.crypto.Signature({
            alg: k
        });
        j.init(l.cakey);
        j.updateHex(i);
        l.sighex = j.sign();
    };
    this.getPEM = function() {
        return hextopem(this.tohex(), "CERTIFICATE");
    };
    this.tohex = function() {
        var k = this.params;
        if (k.tbsobj == undefined || k.tbsobj == null) k.tbsobj = new a(k);
        if (k.sighex == undefined && k.cakey != undefined) this.sign();
        if (k.sighex == undefined) throw new Error("sighex or cakey parameter not defined");
        var i = [];
        i.push(k.tbsobj);
        i.push(new e({
            name: k.sigalg
        }));
        i.push(new f({
            hex: "00" + k.sighex
        }));
        var j = new b({
            array: i
        });
        return j.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (h != undefined) this.params = h;
};
extendClass(KJUR.asn1.x509.Certificate, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.TBSCertificate = function(f) {
    KJUR.asn1.x509.TBSCertificate.superclass.constructor.call(this);
    var b = KJUR, i = b.asn1, d = i.x509, c = i.DERTaggedObject, h = i.DERInteger, g = i.DERSequence, l = d.AlgorithmIdentifier, e = d.Time, a = d.X500Name, j = d.Extensions, k = d.SubjectPublicKeyInfo;
    this.params = null;
    this.setByParam = function(m) {
        this.params = m;
    };
    this.tohex = function() {
        var n = [];
        var q = this.params;
        if (q.version != undefined || q.version != 1) {
            var m = 2;
            if (q.version != undefined) m = q.version - 1;
            var p = new c({
                obj: new h({
                    "int": m
                })
            });
            n.push(p);
        }
        n.push(new h(q.serial));
        n.push(new l({
            name: q.sigalg
        }));
        n.push(new a(q.issuer));
        n.push(new g({
            array: [
                new e(q.notbefore),
                new e(q.notafter)
            ]
        }));
        n.push(new a(q.subject));
        n.push(new k(KEYUTIL.getKey(q.sbjpubkey)));
        if (q.ext !== undefined && q.ext.length > 0) n.push(new c({
            tag: "a3",
            obj: new j(q.ext)
        }));
        var o = new KJUR.asn1.DERSequence({
            array: n
        });
        return o.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f !== undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.x509.TBSCertificate, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.Extensions = function(d) {
    KJUR.asn1.x509.Extensions.superclass.constructor.call(this);
    var c = KJUR, b = c.asn1, a = b.DERSequence, e = b.x509;
    this.aParam = [];
    this.setByParam = function(f) {
        this.aParam = f;
    };
    this.tohex = function() {
        var f = [];
        for(var h = 0; h < this.aParam.length; h++){
            var l = this.aParam[h];
            var k = l.extname;
            var j = null;
            if (l.extn != undefined) j = new e.PrivateExtension(l);
            else if (k == "subjectKeyIdentifier") j = new e.SubjectKeyIdentifier(l);
            else {
                if (k == "keyUsage") j = new e.KeyUsage(l);
                else if (k == "subjectAltName") j = new e.SubjectAltName(l);
                else {
                    if (k == "issuerAltName") j = new e.IssuerAltName(l);
                    else if (k == "basicConstraints") j = new e.BasicConstraints(l);
                    else {
                        if (k == "nameConstraints") j = new e.NameConstraints(l);
                        else if (k == "cRLDistributionPoints") j = new e.CRLDistributionPoints(l);
                        else {
                            if (k == "certificatePolicies") j = new e.CertificatePolicies(l);
                            else if (k == "policyMappings") j = new e.PolicyMappings(l);
                            else {
                                if (k == "policyConstraints") j = new e.PolicyConstraints(l);
                                else if (k == "inhibitAnyPolicy") j = new e.InhibitAnyPolicy(l);
                                else {
                                    if (k == "authorityKeyIdentifier") j = new e.AuthorityKeyIdentifier(l);
                                    else if (k == "extKeyUsage") j = new e.ExtKeyUsage(l);
                                    else {
                                        if (k == "authorityInfoAccess") j = new e.AuthorityInfoAccess(l);
                                        else if (k == "cRLNumber") j = new e.CRLNumber(l);
                                        else {
                                            if (k == "cRLReason") j = new e.CRLReason(l);
                                            else if (k == "ocspNonce") j = new e.OCSPNonce(l);
                                            else {
                                                if (k == "ocspNoCheck") j = new e.OCSPNoCheck(l);
                                                else if (k == "adobeTimeStamp") j = new e.AdobeTimeStamp(l);
                                                else {
                                                    if (k == "subjectDirectoryAttributes") j = new e.SubjectDirectoryAttributes(l);
                                                    else throw new Error("extension not supported:" + JSON.stringify(l));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (j != null) f.push(j);
        }
        var g = new a({
            array: f
        });
        return g.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (d != undefined) this.setByParam(d);
};
extendClass(KJUR.asn1.x509.Extensions, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.Extension = function(d) {
    KJUR.asn1.x509.Extension.superclass.constructor.call(this);
    var f = null, a = KJUR, e = a.asn1, h = e.DERObjectIdentifier, i = e.DEROctetString, b = e.DERBitString, g = e.DERBoolean, c = e.DERSequence;
    this.tohex = function() {
        var m = new h({
            oid: this.oid
        });
        var l = new i({
            hex: this.getExtnValueHex()
        });
        var k = new Array();
        k.push(m);
        if (this.critical) k.push(new g());
        k.push(l);
        var j = new c({
            array: k
        });
        return j.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.critical = false;
    if (d !== undefined) {
        if (d.critical !== undefined) this.critical = d.critical;
    }
};
extendClass(KJUR.asn1.x509.Extension, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.KeyUsage = function(c) {
    KJUR.asn1.x509.KeyUsage.superclass.constructor.call(this, c);
    var b = Error;
    var a = {
        digitalSignature: 0,
        nonRepudiation: 1,
        keyEncipherment: 2,
        dataEncipherment: 3,
        keyAgreement: 4,
        keyCertSign: 5,
        cRLSign: 6,
        encipherOnly: 7,
        decipherOnly: 8
    };
    this.getExtnValueHex = function() {
        var d = this.getBinValue();
        this.asn1ExtnValue = new KJUR.asn1.DERBitString({
            bin: d
        });
        return this.asn1ExtnValue.tohex();
    };
    this.getBinValue = function() {
        var d = this.params;
        if (typeof d != "object" || typeof d.names != "object" && typeof d.bin != "string") throw new b("parameter not yet set");
        if (d.names != undefined) return namearraytobinstr(d.names, a);
        else {
            if (d.bin != undefined) return d.bin;
            else throw new b("parameter not set properly");
        }
    };
    this.oid = "2.5.29.15";
    if (c !== undefined) this.params = c;
};
extendClass(KJUR.asn1.x509.KeyUsage, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.BasicConstraints = function(g) {
    KJUR.asn1.x509.BasicConstraints.superclass.constructor.call(this, g);
    var c = KJUR.asn1, e = c.DERBoolean, f = c.DERInteger, b = c.DERSequence;
    var a = false;
    var d = -1;
    this.getExtnValueHex = function() {
        var i = new Array();
        if (this.cA) i.push(new e());
        if (this.pathLen > -1) i.push(new f({
            "int": this.pathLen
        }));
        var h = new b({
            array: i
        });
        this.asn1ExtnValue = h;
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.19";
    this.cA = false;
    this.pathLen = -1;
    if (g !== undefined) {
        if (g.cA !== undefined) this.cA = g.cA;
        if (g.pathLen !== undefined) this.pathLen = g.pathLen;
    }
};
extendClass(KJUR.asn1.x509.BasicConstraints, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.CRLDistributionPoints = function(d) {
    KJUR.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this, d);
    var b = KJUR, a = b.asn1, c = a.x509;
    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };
    this.setByDPArray = function(e) {
        var f = [];
        for(var g = 0; g < e.length; g++)if (e[g] instanceof KJUR.asn1.ASN1Object) f.push(e[g]);
        else {
            var h = new c.DistributionPoint(e[g]);
            f.push(h);
        }
        this.asn1ExtnValue = new a.DERSequence({
            array: f
        });
    };
    this.setByOneURI = function(f) {
        var e = new c.DistributionPoint({
            fulluri: f
        });
        this.setByDPArray([
            e
        ]);
    };
    this.oid = "2.5.29.31";
    if (d !== undefined) {
        if (d.array !== undefined) this.setByDPArray(d.array);
        else if (d.uri !== undefined) this.setByOneURI(d.uri);
    }
};
extendClass(KJUR.asn1.x509.CRLDistributionPoints, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.DistributionPoint = function(e) {
    KJUR.asn1.x509.DistributionPoint.superclass.constructor.call(this);
    var a = null, c = KJUR, b = c.asn1, d = b.x509.DistributionPointName;
    this.tohex = function() {
        var f = new b.DERSequence();
        if (this.asn1DP != null) {
            var g = new b.DERTaggedObject({
                explicit: true,
                tag: "a0",
                obj: this.asn1DP
            });
            f.appendASN1Object(g);
        }
        this.hTLV = f.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) {
        if (e.dpobj !== undefined) this.asn1DP = e.dpobj;
        else {
            if (e.dpname !== undefined) this.asn1DP = new d(e.dpname);
            else if (e.fulluri !== undefined) this.asn1DP = new d({
                full: [
                    {
                        uri: e.fulluri
                    }
                ]
            });
        }
    }
};
extendClass(KJUR.asn1.x509.DistributionPoint, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.DistributionPointName = function(h) {
    KJUR.asn1.x509.DistributionPointName.superclass.constructor.call(this);
    var g = null, d = null, a = null, f = null, c = KJUR, b = c.asn1, e = b.DERTaggedObject;
    this.tohex = function() {
        if (this.type != "full") throw new Error("currently type shall be 'full': " + this.type);
        this.asn1Obj = new e({
            explicit: false,
            tag: this.tag,
            obj: this.asn1V
        });
        this.hTLV = this.asn1Obj.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (h !== undefined) {
        if (b.x509.GeneralNames.prototype.isPrototypeOf(h)) {
            this.type = "full";
            this.tag = "a0";
            this.asn1V = h;
        } else {
            if (h.full !== undefined) {
                this.type = "full";
                this.tag = "a0";
                this.asn1V = new b.x509.GeneralNames(h.full);
            } else throw new Error("This class supports GeneralNames only as argument");
        }
    }
};
extendClass(KJUR.asn1.x509.DistributionPointName, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.CertificatePolicies = function(f) {
    KJUR.asn1.x509.CertificatePolicies.superclass.constructor.call(this, f);
    var c = KJUR, b = c.asn1, e = b.x509, a = b.DERSequence, d = e.PolicyInformation;
    this.params = null;
    this.getExtnValueHex = function() {
        var j = [];
        for(var h = 0; h < this.params.array.length; h++)j.push(new d(this.params.array[h]));
        var g = new a({
            array: j
        });
        this.asn1ExtnValue = g;
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.32";
    if (f !== undefined) this.params = f;
};
extendClass(KJUR.asn1.x509.CertificatePolicies, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.PolicyInformation = function(d) {
    KJUR.asn1.x509.PolicyInformation.superclass.constructor.call(this, d);
    var c = KJUR.asn1, b = c.DERSequence, e = c.DERObjectIdentifier, a = c.x509.PolicyQualifierInfo;
    this.params = null;
    this.tohex = function() {
        if (this.params.policyoid === undefined && this.params.array === undefined) throw new Error("parameter oid and array missing");
        var f = [
            new e(this.params.policyoid)
        ];
        if (this.params.array !== undefined) {
            var j = [];
            for(var h = 0; h < this.params.array.length; h++)j.push(new a(this.params.array[h]));
            if (j.length > 0) f.push(new b({
                array: j
            }));
        }
        var g = new b({
            array: f
        });
        return g.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (d !== undefined) this.params = d;
};
extendClass(KJUR.asn1.x509.PolicyInformation, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.PolicyQualifierInfo = function(e) {
    KJUR.asn1.x509.PolicyQualifierInfo.superclass.constructor.call(this, e);
    var c = KJUR.asn1, b = c.DERSequence, d = c.DERIA5String, f = c.DERObjectIdentifier, a = c.x509.UserNotice;
    this.params = null;
    this.tohex = function() {
        if (this.params.cps !== undefined) {
            var g = new b({
                array: [
                    new f({
                        oid: "1.3.6.1.5.5.7.2.1"
                    }),
                    new d({
                        str: this.params.cps
                    })
                ]
            });
            return g.tohex();
        }
        if (this.params.unotice != undefined) {
            var g = new b({
                array: [
                    new f({
                        oid: "1.3.6.1.5.5.7.2.2"
                    }),
                    new a(this.params.unotice)
                ]
            });
            return g.tohex();
        }
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) this.params = e;
};
extendClass(KJUR.asn1.x509.PolicyQualifierInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.UserNotice = function(e) {
    KJUR.asn1.x509.UserNotice.superclass.constructor.call(this, e);
    var a = KJUR.asn1.DERSequence, d = KJUR.asn1.DERInteger, c = KJUR.asn1.x509.DisplayText, b = KJUR.asn1.x509.NoticeReference;
    this.params = null;
    this.tohex = function() {
        var f = [];
        if (this.params.noticeref !== undefined) f.push(new b(this.params.noticeref));
        if (this.params.exptext !== undefined) f.push(new c(this.params.exptext));
        var g = new a({
            array: f
        });
        return g.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) this.params = e;
};
extendClass(KJUR.asn1.x509.UserNotice, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.NoticeReference = function(d) {
    KJUR.asn1.x509.NoticeReference.superclass.constructor.call(this, d);
    var a = KJUR.asn1.DERSequence, c = KJUR.asn1.DERInteger, b = KJUR.asn1.x509.DisplayText;
    this.params = null;
    this.tohex = function() {
        var f = [];
        if (this.params.org !== undefined) f.push(new b(this.params.org));
        if (this.params.noticenum !== undefined) {
            var h = [];
            var e = this.params.noticenum;
            for(var j = 0; j < e.length; j++)h.push(new c(e[j]));
            f.push(new a({
                array: h
            }));
        }
        if (f.length == 0) throw new Error("parameter is empty");
        var g = new a({
            array: f
        });
        return g.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (d !== undefined) this.params = d;
};
extendClass(KJUR.asn1.x509.NoticeReference, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.DisplayText = function(a) {
    KJUR.asn1.x509.DisplayText.superclass.constructor.call(this, a);
    this.hT = "0c";
    if (a !== undefined) {
        if (a.type === "ia5") this.hT = "16";
        else {
            if (a.type === "vis") this.hT = "1a";
            else if (a.type === "bmp") this.hT = "1e";
        }
    }
};
extendClass(KJUR.asn1.x509.DisplayText, KJUR.asn1.DERAbstractString);
KJUR.asn1.x509.PolicyMappings = function(e) {
    KJUR.asn1.x509.PolicyMappings.superclass.constructor.call(this, e);
    var c = KJUR, b = c.asn1, d = b.x509, a = b.ASN1Util.newObject;
    this.params = null;
    this.getExtnValueHex = function() {
        var j = this.params;
        var f = [];
        for(var g = 0; g < j.array.length; g++){
            var h = j.array[g];
            f.push({
                seq: [
                    {
                        oid: h[0]
                    },
                    {
                        oid: h[1]
                    }
                ]
            });
        }
        this.asn1ExtnValue = a({
            seq: f
        });
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.33";
    if (e !== undefined) this.params = e;
};
extendClass(KJUR.asn1.x509.PolicyMappings, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.PolicyConstraints = function(e) {
    KJUR.asn1.x509.PolicyConstraints.superclass.constructor.call(this, e);
    var c = KJUR, b = c.asn1, d = b.x509, a = b.ASN1Util.newObject;
    this.params = null;
    this.getExtnValueHex = function() {
        var g = this.params;
        var f = [];
        if (g.reqexp != undefined) f.push({
            tag: {
                tagi: "80",
                obj: {
                    "int": g.reqexp
                }
            }
        });
        if (g.inhibit != undefined) f.push({
            tag: {
                tagi: "81",
                obj: {
                    "int": g.inhibit
                }
            }
        });
        this.asn1ExtnValue = a({
            seq: f
        });
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.36";
    if (e !== undefined) this.params = e;
};
extendClass(KJUR.asn1.x509.PolicyConstraints, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.InhibitAnyPolicy = function(e) {
    KJUR.asn1.x509.InhibitAnyPolicy.superclass.constructor.call(this, e);
    var c = KJUR, b = c.asn1, d = b.x509, a = b.ASN1Util.newObject;
    this.params = null;
    this.getExtnValueHex = function() {
        this.asn1ExtnValue = a({
            "int": this.params.skip
        });
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.54";
    if (e !== undefined) this.params = e;
};
extendClass(KJUR.asn1.x509.InhibitAnyPolicy, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.NameConstraints = function(f) {
    KJUR.asn1.x509.NameConstraints.superclass.constructor.call(this, f);
    var c = KJUR, b = c.asn1, e = b.x509, a = b.ASN1Util.newObject, d = e.GeneralSubtree;
    this.params = null;
    this.getExtnValueHex = function() {
        var l = this.params;
        var g = [];
        if (l.permit != undefined && l.permit.length != undefined) {
            var k = [];
            for(var h = 0; h < l.permit.length; h++)k.push(new d(l.permit[h]));
            g.push({
                tag: {
                    tagi: "a0",
                    obj: {
                        seq: k
                    }
                }
            });
        }
        if (l.exclude != undefined && l.exclude.length != undefined) {
            var j = [];
            for(var h = 0; h < l.exclude.length; h++)j.push(new d(l.exclude[h]));
            g.push({
                tag: {
                    tagi: "a1",
                    obj: {
                        seq: j
                    }
                }
            });
        }
        this.asn1ExtnValue = a({
            seq: g
        });
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.30";
    if (f !== undefined) this.params = f;
};
extendClass(KJUR.asn1.x509.NameConstraints, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.GeneralSubtree = function(e) {
    KJUR.asn1.x509.GeneralSubtree.superclass.constructor.call(this);
    var b = KJUR.asn1, d = b.x509, c = d.GeneralName, a = b.ASN1Util.newObject;
    this.params = null;
    this.setByParam = function(f) {
        this.params = f;
    };
    this.tohex = function() {
        var h = this.params;
        var f = [
            new c(h)
        ];
        if (h.min != undefined) f.push({
            tag: {
                tagi: "80",
                obj: {
                    "int": h.min
                }
            }
        });
        if (h.max != undefined) f.push({
            tag: {
                tagi: "81",
                obj: {
                    "int": h.max
                }
            }
        });
        var g = a({
            seq: f
        });
        return g.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.x509.GeneralSubtree, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.ExtKeyUsage = function(c) {
    KJUR.asn1.x509.ExtKeyUsage.superclass.constructor.call(this, c);
    var b = KJUR, a = b.asn1;
    this.setPurposeArray = function(d) {
        this.asn1ExtnValue = new a.DERSequence();
        for(var e = 0; e < d.length; e++){
            var f = new a.DERObjectIdentifier(d[e]);
            this.asn1ExtnValue.appendASN1Object(f);
        }
    };
    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.37";
    if (c !== undefined) {
        if (c.array !== undefined) this.setPurposeArray(c.array);
    }
};
extendClass(KJUR.asn1.x509.ExtKeyUsage, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.AuthorityKeyIdentifier = function(f) {
    KJUR.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this, f);
    var b = KJUR, a = b.asn1, d = a.DERTaggedObject, e = a.x509.GeneralNames, c = b.crypto.Util.isKey;
    this.asn1KID = null;
    this.asn1CertIssuer = null;
    this.asn1CertSN = null;
    this.getExtnValueHex = function() {
        var h = new Array();
        if (this.asn1KID) h.push(new d({
            explicit: false,
            tag: "80",
            obj: this.asn1KID
        }));
        if (this.asn1CertIssuer) h.push(new d({
            explicit: false,
            tag: "a1",
            obj: new e([
                {
                    dn: this.asn1CertIssuer
                }
            ])
        }));
        if (this.asn1CertSN) h.push(new d({
            explicit: false,
            tag: "82",
            obj: this.asn1CertSN
        }));
        var g = new a.DERSequence({
            array: h
        });
        this.asn1ExtnValue = g;
        return this.asn1ExtnValue.tohex();
    };
    this.setKIDByParam = function(i) {
        if (i.str !== undefined || i.hex !== undefined) this.asn1KID = new KJUR.asn1.DEROctetString(i);
        else if (typeof i === "object" && KJUR.crypto.Util.isKey(i) || typeof i === "string" && i.indexOf("BEGIN ") != -1) {
            var h = i;
            if (typeof i === "string") h = KEYUTIL.getKey(i);
            var g = KEYUTIL.getKeyID(h);
            this.asn1KID = new KJUR.asn1.DEROctetString({
                hex: g
            });
        }
    };
    this.setCertIssuerByParam = function(g) {
        if (g.str !== undefined || g.ldapstr !== undefined || g.hex !== undefined || g.certsubject !== undefined || g.certissuer !== undefined) this.asn1CertIssuer = new KJUR.asn1.x509.X500Name(g);
        else if (typeof g === "string" && g.indexOf("BEGIN ") != -1 && g.indexOf("CERTIFICATE") != -1) this.asn1CertIssuer = new KJUR.asn1.x509.X500Name({
            certissuer: g
        });
    };
    this.setCertSNByParam = function(i) {
        if (i.str !== undefined || i.bigint !== undefined || i.hex !== undefined) this.asn1CertSN = new KJUR.asn1.DERInteger(i);
        else if (typeof i === "string" && i.indexOf("BEGIN ") != -1 && i.indexOf("CERTIFICATE")) {
            var g = new X509();
            g.readCertPEM(i);
            var h = g.getSerialNumberHex();
            this.asn1CertSN = new KJUR.asn1.DERInteger({
                hex: h
            });
        }
    };
    this.oid = "2.5.29.35";
    if (f !== undefined) {
        if (f.kid !== undefined) this.setKIDByParam(f.kid);
        if (f.issuer !== undefined) this.setCertIssuerByParam(f.issuer);
        if (f.sn !== undefined) this.setCertSNByParam(f.sn);
        if (f.issuersn !== undefined && typeof f.issuersn === "string" && f.issuersn.indexOf("BEGIN ") != -1 && f.issuersn.indexOf("CERTIFICATE")) {
            this.setCertSNByParam(f.issuersn);
            this.setCertIssuerByParam(f.issuersn);
        }
    }
};
extendClass(KJUR.asn1.x509.AuthorityKeyIdentifier, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.SubjectKeyIdentifier = function(d) {
    KJUR.asn1.x509.SubjectKeyIdentifier.superclass.constructor.call(this, d);
    var b = KJUR, a = b.asn1, c = a.DEROctetString;
    this.asn1KID = null;
    this.getExtnValueHex = function() {
        this.asn1ExtnValue = this.asn1KID;
        return this.asn1ExtnValue.tohex();
    };
    this.setKIDByParam = function(g) {
        if (g.str !== undefined || g.hex !== undefined) this.asn1KID = new c(g);
        else if (typeof g === "object" && KJUR.crypto.Util.isKey(g) || typeof g === "string" && g.indexOf("BEGIN") != -1) {
            var f = g;
            if (typeof g === "string") f = KEYUTIL.getKey(g);
            var e = KEYUTIL.getKeyID(f);
            this.asn1KID = new KJUR.asn1.DEROctetString({
                hex: e
            });
        }
    };
    this.oid = "2.5.29.14";
    if (d !== undefined) {
        if (d.kid !== undefined) this.setKIDByParam(d.kid);
    }
};
extendClass(KJUR.asn1.x509.SubjectKeyIdentifier, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.AuthorityInfoAccess = function(a) {
    KJUR.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this, a);
    this.setAccessDescriptionArray = function(k) {
        var d = new Array(), b = KJUR, g = b.asn1, c = g.DERSequence, j = g.DERObjectIdentifier, l = g.x509.GeneralName;
        for(var f = 0; f < k.length; f++){
            var e;
            var h = k[f];
            if (h.ocsp !== undefined) e = new c({
                array: [
                    new j({
                        oid: "1.3.6.1.5.5.7.48.1"
                    }),
                    new l({
                        uri: h.ocsp
                    })
                ]
            });
            else {
                if (h.caissuer !== undefined) e = new c({
                    array: [
                        new j({
                            oid: "1.3.6.1.5.5.7.48.2"
                        }),
                        new l({
                            uri: h.caissuer
                        })
                    ]
                });
                else throw new Error("unknown AccessMethod parameter: " + JSON.stringify(h));
            }
            d.push(e);
        }
        this.asn1ExtnValue = new c({
            array: d
        });
    };
    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "1.3.6.1.5.5.7.1.1";
    if (a !== undefined) {
        if (a.array !== undefined) this.setAccessDescriptionArray(a.array);
    }
};
extendClass(KJUR.asn1.x509.AuthorityInfoAccess, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.SubjectAltName = function(a) {
    KJUR.asn1.x509.SubjectAltName.superclass.constructor.call(this, a);
    this.setNameArray = function(b) {
        this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(b);
    };
    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.17";
    if (a !== undefined) {
        if (a.array !== undefined) this.setNameArray(a.array);
    }
};
extendClass(KJUR.asn1.x509.SubjectAltName, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.IssuerAltName = function(a) {
    KJUR.asn1.x509.IssuerAltName.superclass.constructor.call(this, a);
    this.setNameArray = function(b) {
        this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(b);
    };
    this.getExtnValueHex = function() {
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.18";
    if (a !== undefined) {
        if (a.array !== undefined) this.setNameArray(a.array);
    }
};
extendClass(KJUR.asn1.x509.IssuerAltName, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.SubjectDirectoryAttributes = function(e) {
    KJUR.asn1.x509.SubjectDirectoryAttributes.superclass.constructor.call(this, e);
    var c = KJUR.asn1, a = c.DERSequence, b = c.ASN1Util.newObject, d = c.x509.OID.name2oid;
    this.params = null;
    this.getExtnValueHex = function() {
        var f = [];
        for(var j = 0; j < this.params.array.length; j++){
            var l = this.params.array[j];
            if (l.attr != undefined && l.array != undefined) {
                var k = {
                    seq: [
                        {
                            oid: l.attr
                        },
                        {
                            set: l.array
                        }
                    ]
                };
                f.push(b(k));
                continue;
            }
            var h = {
                seq: [
                    {
                        oid: "1.2.3.4"
                    },
                    {
                        set: [
                            {
                                utf8str: "DE"
                            }
                        ]
                    }
                ]
            };
            if (l.attr == "dateOfBirth") {
                h.seq[0].oid = d(l.attr);
                h.seq[1].set[0] = {
                    gentime: l.str
                };
            } else if (l.attr == "placeOfBirth") {
                h.seq[0].oid = d(l.attr);
                h.seq[1].set[0] = {
                    utf8str: l.str
                };
            } else {
                if (l.attr == "gender") {
                    h.seq[0].oid = d(l.attr);
                    h.seq[1].set[0] = {
                        prnstr: l.str
                    };
                } else if (l.attr == "countryOfCitizenship") {
                    h.seq[0].oid = d(l.attr);
                    h.seq[1].set[0] = {
                        prnstr: l.str
                    };
                } else {
                    if (l.attr == "countryOfResidence") {
                        h.seq[0].oid = d(l.attr);
                        h.seq[1].set[0] = {
                            prnstr: l.str
                        };
                    } else throw new Error("unsupported attribute: " + l.attr);
                }
            }
            f.push(new b(h));
        }
        var g = new a({
            array: f
        });
        this.asn1ExtnValue = g;
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.9";
    if (e !== undefined) this.params = e;
};
extendClass(KJUR.asn1.x509.SubjectDirectoryAttributes, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.PrivateExtension = function(f) {
    KJUR.asn1.x509.PrivateExtension.superclass.constructor.call(this, f);
    var c = KJUR, e = c.lang.String.isHex, b = c.asn1, d = b.x509.OID.name2oid, a = b.ASN1Util.newObject;
    this.params = null;
    this.setByParam = function(g) {
        this.oid = d(g.extname);
        this.params = g;
    };
    this.getExtnValueHex = function() {
        if (this.params.extname == undefined || this.params.extn == undefined) throw new Error("extname or extnhex not specified");
        var h = this.params.extn;
        if (typeof h == "string" && e(h)) return h;
        else {
            if (typeof h == "object") try {
                return a(h).tohex();
            } catch (g) {}
        }
        throw new Error("unsupported extn value");
    };
    if (f != undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.x509.PrivateExtension, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.CRL = function(g) {
    KJUR.asn1.x509.CRL.superclass.constructor.call(this);
    var c = KJUR, b = c.asn1, a = b.DERSequence, e = b.DERBitString, f = b.x509, d = f.AlgorithmIdentifier, h = f.TBSCertList;
    this.params = undefined;
    this.setByParam = function(i) {
        this.params = i;
    };
    this.sign = function() {
        var j = new h(this.params).tohex();
        var k = new KJUR.crypto.Signature({
            alg: this.params.sigalg
        });
        k.init(this.params.cakey);
        k.updateHex(j);
        var i = k.sign();
        this.params.sighex = i;
    };
    this.getPEM = function() {
        return hextopem(this.tohex(), "X509 CRL");
    };
    this.tohex = function() {
        var k = this.params;
        if (k.tbsobj == undefined) k.tbsobj = new h(k);
        if (k.sighex == undefined && k.cakey != undefined) this.sign();
        if (k.sighex == undefined) throw new Error("sighex or cakey parameter not defined");
        var i = [];
        i.push(k.tbsobj);
        i.push(new d({
            name: k.sigalg
        }));
        i.push(new e({
            hex: "00" + k.sighex
        }));
        var j = new a({
            array: i
        });
        return j.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g != undefined) this.params = g;
};
extendClass(KJUR.asn1.x509.CRL, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.TBSCertList = function(f) {
    KJUR.asn1.x509.TBSCertList.superclass.constructor.call(this);
    var b = KJUR, i = b.asn1, h = i.DERInteger, g = i.DERSequence, c = i.DERTaggedObject, k = i.DERObjectIdentifier, d = i.x509, l = d.AlgorithmIdentifier, e = d.Time, j = d.Extensions, a = d.X500Name;
    this.params = null;
    this.setByParam = function(m) {
        this.params = m;
    };
    this.getRevCertSequence = function() {
        var m = [];
        var n = this.params.revcert;
        for(var o = 0; o < n.length; o++){
            var p = [
                new h(n[o].sn),
                new e(n[o].date)
            ];
            if (n[o].ext != undefined) p.push(new j(n[o].ext));
            m.push(new g({
                array: p
            }));
        }
        return new g({
            array: m
        });
    };
    this.tohex = function() {
        var n = [];
        var r = this.params;
        if (r.version != undefined) {
            var m = r.version - 1;
            var p = new h({
                "int": m
            });
            n.push(p);
        }
        n.push(new l({
            name: r.sigalg
        }));
        n.push(new a(r.issuer));
        n.push(new e(r.thisupdate));
        if (r.nextupdate != undefined) n.push(new e(r.nextupdate));
        if (r.revcert != undefined) n.push(this.getRevCertSequence());
        if (r.ext != undefined) {
            var q = new j(r.ext);
            n.push(new c({
                tag: "a0",
                explicit: true,
                obj: q
            }));
        }
        var o = new g({
            array: n
        });
        return o.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f !== undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.x509.TBSCertList, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.CRLEntry = function(e) {
    KJUR.asn1.x509.CRLEntry.superclass.constructor.call(this);
    var d = null, c = null, b = KJUR, a = b.asn1;
    this.setCertSerial = function(f) {
        this.sn = new a.DERInteger(f);
    };
    this.setRevocationDate = function(f) {
        this.time = new a.x509.Time(f);
    };
    this.tohex = function() {
        var f = new a.DERSequence({
            array: [
                this.sn,
                this.time
            ]
        });
        this.TLV = f.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) {
        if (e.time !== undefined) this.setRevocationDate(e.time);
        if (e.sn !== undefined) this.setCertSerial(e.sn);
    }
};
extendClass(KJUR.asn1.x509.CRLEntry, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.CRLNumber = function(a) {
    KJUR.asn1.x509.CRLNumber.superclass.constructor.call(this, a);
    this.params = undefined;
    this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DERInteger(this.params.num);
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.20";
    if (a != undefined) this.params = a;
};
extendClass(KJUR.asn1.x509.CRLNumber, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.CRLReason = function(a) {
    KJUR.asn1.x509.CRLReason.superclass.constructor.call(this, a);
    this.params = undefined;
    this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DEREnumerated(this.params.code);
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "2.5.29.21";
    if (a != undefined) this.params = a;
};
extendClass(KJUR.asn1.x509.CRLReason, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.OCSPNonce = function(a) {
    KJUR.asn1.x509.OCSPNonce.superclass.constructor.call(this, a);
    this.params = undefined;
    this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DEROctetString(this.params);
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "1.3.6.1.5.5.7.48.1.2";
    if (a != undefined) this.params = a;
};
extendClass(KJUR.asn1.x509.OCSPNonce, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.OCSPNoCheck = function(a) {
    KJUR.asn1.x509.OCSPNoCheck.superclass.constructor.call(this, a);
    this.params = undefined;
    this.getExtnValueHex = function() {
        this.asn1ExtnValue = new KJUR.asn1.DERNull();
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "1.3.6.1.5.5.7.48.1.5";
    if (a != undefined) this.params = a;
};
extendClass(KJUR.asn1.x509.OCSPNoCheck, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.AdobeTimeStamp = function(g) {
    KJUR.asn1.x509.AdobeTimeStamp.superclass.constructor.call(this, g);
    var c = KJUR, b = c.asn1, f = b.DERInteger, d = b.DERBoolean, a = b.DERSequence, e = b.x509.GeneralName;
    this.params = null;
    this.getExtnValueHex = function() {
        var i = this.params;
        var h = [
            new f(1)
        ];
        h.push(new e({
            uri: i.uri
        }));
        if (i.reqauth != undefined) h.push(new d(i.reqauth));
        this.asn1ExtnValue = new a({
            array: h
        });
        return this.asn1ExtnValue.tohex();
    };
    this.oid = "1.2.840.113583.1.1.9.1";
    if (g !== undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.x509.AdobeTimeStamp, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.X500Name = function(f) {
    KJUR.asn1.x509.X500Name.superclass.constructor.call(this);
    this.asn1Array = [];
    this.paramArray = [];
    this.sRule = "utf8";
    var c = KJUR, b = c.asn1, e = b.x509, d = e.RDN, a = pemtohex;
    this.setByString = function(g, l) {
        if (l !== undefined) this.sRule = l;
        var k = g.split("/");
        k.shift();
        var j = [];
        for(var m = 0; m < k.length; m++)if (k[m].match(/^[^=]+=.+$/)) j.push(k[m]);
        else {
            var h = j.length - 1;
            j[h] = j[h] + "/" + k[m];
        }
        for(var m = 0; m < j.length; m++)this.asn1Array.push(new d({
            str: j[m],
            rule: this.sRule
        }));
    };
    this.setByLdapString = function(g, h) {
        if (h !== undefined) this.sRule = h;
        var i = e.X500Name.ldapToCompat(g);
        this.setByString(i, h);
    };
    this.setByObject = function(j, i) {
        if (i !== undefined) this.sRule = i;
        for(var g in j)if (j.hasOwnProperty(g)) {
            var h = new d({
                str: g + "=" + j[g],
                rule: this.sRule
            });
            this.asn1Array ? this.asn1Array.push(h) : this.asn1Array = [
                h
            ];
        }
    };
    this.setByParam = function(h) {
        if (h.rule !== undefined) this.sRule = h.rule;
        if (h.array !== undefined) this.paramArray = h.array;
        else {
            if (h.str !== undefined) this.setByString(h.str);
            else if (h.ldapstr !== undefined) this.setByLdapString(h.ldapstr);
            else {
                if (h.hex !== undefined) this.hTLV = h.hex;
                else if (h.certissuer !== undefined) {
                    var g = new X509();
                    g.readCertPEM(h.certissuer);
                    this.hTLV = g.getIssuerHex();
                } else {
                    if (h.certsubject !== undefined) {
                        var g = new X509();
                        g.readCertPEM(h.certsubject);
                        this.hTLV = g.getSubjectHex();
                    } else if (typeof h === "object" && h.certsubject === undefined && h.certissuer === undefined) this.setByObject(h);
                }
            }
        }
    };
    this.tohex = function() {
        if (typeof this.hTLV == "string") return this.hTLV;
        if (this.asn1Array.length == 0 && this.paramArray.length > 0) for(var g = 0; g < this.paramArray.length; g++){
            var k = {
                array: this.paramArray[g]
            };
            if (this.sRule != "utf8") k.rule = this.sRule;
            var h = new d(k);
            this.asn1Array.push(h);
        }
        var j = new b.DERSequence({
            array: this.asn1Array
        });
        this.hTLV = j.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f !== undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.x509.X500Name, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.X500Name.compatToLDAP = function(d) {
    if (d.substr(0, 1) !== "/") throw "malformed input";
    var b = "";
    d = d.substr(1);
    var c = d.split("/");
    c.reverse();
    c = c.map(function(a) {
        return a.replace(/,/, "\\,");
    });
    return c.join(",");
};
KJUR.asn1.x509.X500Name.onelineToLDAP = function(a) {
    return KJUR.asn1.x509.X500Name.compatToLDAP(a);
};
KJUR.asn1.x509.X500Name.ldapToCompat = function(g) {
    var c = g.split(",");
    var e = false;
    var b = [];
    for(var f = 0; c.length > 0; f++){
        var h = c.shift();
        if (e === true) {
            var d = b.pop();
            var j = (d + "," + h).replace(/\\,/g, ",");
            b.push(j);
            e = false;
        } else b.push(h);
        if (h.substr(-1, 1) === "\\") e = true;
    }
    b = b.map(function(a) {
        return a.replace("/", "\\/");
    });
    b.reverse();
    return "/" + b.join("/");
};
KJUR.asn1.x509.X500Name.ldapToOneline = function(a) {
    return KJUR.asn1.x509.X500Name.ldapToCompat(a);
};
KJUR.asn1.x509.RDN = function(b) {
    KJUR.asn1.x509.RDN.superclass.constructor.call(this);
    this.asn1Array = [];
    this.paramArray = [];
    this.sRule = "utf8";
    var a = KJUR.asn1.x509.AttributeTypeAndValue;
    this.setByParam = function(c) {
        if (c.rule !== undefined) this.sRule = c.rule;
        if (c.str !== undefined) this.addByMultiValuedString(c.str);
        if (c.array !== undefined) this.paramArray = c.array;
    };
    this.addByString = function(c) {
        this.asn1Array.push(new KJUR.asn1.x509.AttributeTypeAndValue({
            str: c,
            rule: this.sRule
        }));
    };
    this.addByMultiValuedString = function(e) {
        var c = KJUR.asn1.x509.RDN.parseString(e);
        for(var d = 0; d < c.length; d++)this.addByString(c[d]);
    };
    this.tohex = function() {
        if (this.asn1Array.length == 0 && this.paramArray.length > 0) for(var d = 0; d < this.paramArray.length; d++){
            var f = this.paramArray[d];
            if (f.rule !== undefined && this.sRule != "utf8") f.rule = this.sRule;
            var c = new a(f);
            this.asn1Array.push(c);
        }
        var e = new KJUR.asn1.DERSet({
            array: this.asn1Array
        });
        this.TLV = e.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (b !== undefined) this.setByParam(b);
};
extendClass(KJUR.asn1.x509.RDN, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.RDN.parseString = function(m) {
    var j = m.split(/\+/);
    var h = false;
    var c = [];
    for(var g = 0; j.length > 0; g++){
        var k = j.shift();
        if (h === true) {
            var f = c.pop();
            var d = (f + "+" + k).replace(/\\\+/g, "+");
            c.push(d);
            h = false;
        } else c.push(k);
        if (k.substr(-1, 1) === "\\") h = true;
    }
    var l = false;
    var b = [];
    for(var g = 0; c.length > 0; g++){
        var k = c.shift();
        if (l === true) {
            var e = b.pop();
            if (k.match(/"$/)) {
                var d = (e + "+" + k).replace(/^([^=]+)="(.*)"$/, "$1=$2");
                b.push(d);
                l = false;
            } else b.push(e + "+" + k);
        } else b.push(k);
        if (k.match(/^[^=]+="/)) l = true;
    }
    return b;
};
KJUR.asn1.x509.AttributeTypeAndValue = function(c) {
    KJUR.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this);
    this.sRule = "utf8";
    this.sType = null;
    this.sValue = null;
    this.dsType = null;
    var a = KJUR, g = a.asn1, d = g.DERSequence, l = g.DERUTF8String, i = g.DERPrintableString, h = g.DERTeletexString, b = g.DERIA5String, e = g.DERVisibleString, k = g.DERBMPString, f = a.lang.String.isMail, j = a.lang.String.isPrintable;
    this.setByParam = function(o) {
        if (o.rule !== undefined) this.sRule = o.rule;
        if (o.ds !== undefined) this.dsType = o.ds;
        if (o.value === undefined && o.str !== undefined) {
            var n = o.str;
            var m = n.match(/^([^=]+)=(.+)$/);
            if (m) {
                this.sType = m[1];
                this.sValue = m[2];
            } else throw new Error("malformed attrTypeAndValueStr: " + attrTypeAndValueStr);
        } else {
            this.sType = o.type;
            this.sValue = o.value;
        }
    };
    this.setByString = function(n, o) {
        if (o !== undefined) this.sRule = o;
        var m = n.match(/^([^=]+)=(.+)$/);
        if (m) this.setByAttrTypeAndValueStr(m[1], m[2]);
        else throw new Error("malformed attrTypeAndValueStr: " + attrTypeAndValueStr);
    };
    this._getDsType = function() {
        var o = this.sType;
        var n = this.sValue;
        var m = this.sRule;
        if (m === "prn") {
            if (o == "CN" && f(n)) return "ia5";
            if (j(n)) return "prn";
            return "utf8";
        } else if (m === "utf8") {
            if (o == "CN" && f(n)) return "ia5";
            if (o == "C") return "prn";
            return "utf8";
        }
        return "utf8";
    };
    this.setByAttrTypeAndValueStr = function(o, n, m) {
        if (m !== undefined) this.sRule = m;
        this.sType = o;
        this.sValue = n;
    };
    this.getValueObj = function(n, m) {
        if (n == "utf8") return new l({
            str: m
        });
        if (n == "prn") return new i({
            str: m
        });
        if (n == "tel") return new h({
            str: m
        });
        if (n == "ia5") return new b({
            str: m
        });
        if (n == "vis") return new e({
            str: m
        });
        if (n == "bmp") return new k({
            str: m
        });
        throw new Error("unsupported directory string type: type=" + n + " value=" + m);
    };
    this.tohex = function() {
        if (this.dsType == null) this.dsType = this._getDsType();
        var n = KJUR.asn1.x509.OID.atype2obj(this.sType);
        var m = this.getValueObj(this.dsType, this.sValue);
        var p = new d({
            array: [
                n,
                m
            ]
        });
        this.TLV = p.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (c !== undefined) this.setByParam(c);
};
extendClass(KJUR.asn1.x509.AttributeTypeAndValue, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.SubjectPublicKeyInfo = function(f) {
    KJUR.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);
    var l = null, k = null, a = KJUR, j = a.asn1, i = j.DERInteger, b = j.DERBitString, m = j.DERObjectIdentifier, e = j.DERSequence, h = j.ASN1Util.newObject, d = j.x509, o = d.AlgorithmIdentifier, g = a.crypto, n = g.ECDSA, c = g.DSA;
    this.getASN1Object = function() {
        if (this.asn1AlgId == null || this.asn1SubjPKey == null) throw "algId and/or subjPubKey not set";
        var p = new e({
            array: [
                this.asn1AlgId,
                this.asn1SubjPKey
            ]
        });
        return p;
    };
    this.tohex = function() {
        var p = this.getASN1Object();
        this.hTLV = p.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setPubKey = function(q) {
        try {
            if (q instanceof RSAKey) {
                var u = h({
                    seq: [
                        {
                            "int": {
                                bigint: q.n
                            }
                        },
                        {
                            "int": {
                                "int": q.e
                            }
                        }
                    ]
                });
                var s = u.tohex();
                this.asn1AlgId = new o({
                    name: "rsaEncryption"
                });
                this.asn1SubjPKey = new b({
                    hex: "00" + s
                });
            }
        } catch (p) {}
        try {
            if (q instanceof KJUR.crypto.ECDSA) {
                var r = new m({
                    name: q.curveName
                });
                this.asn1AlgId = new o({
                    name: "ecPublicKey",
                    asn1params: r
                });
                this.asn1SubjPKey = new b({
                    hex: "00" + q.pubKeyHex
                });
            }
        } catch (p) {}
        try {
            if (q instanceof KJUR.crypto.DSA) {
                var r = new h({
                    seq: [
                        {
                            "int": {
                                bigint: q.p
                            }
                        },
                        {
                            "int": {
                                bigint: q.q
                            }
                        },
                        {
                            "int": {
                                bigint: q.g
                            }
                        }
                    ]
                });
                this.asn1AlgId = new o({
                    name: "dsa",
                    asn1params: r
                });
                var t = new i({
                    bigint: q.y
                });
                this.asn1SubjPKey = new b({
                    hex: "00" + t.tohex()
                });
            }
        } catch (p) {}
    };
    if (f !== undefined) this.setPubKey(f);
};
extendClass(KJUR.asn1.x509.SubjectPublicKeyInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.Time = function(f) {
    KJUR.asn1.x509.Time.superclass.constructor.call(this);
    var e = null, a = null, d = KJUR, c = d.asn1, b = c.DERUTCTime, g = c.DERGeneralizedTime;
    this.params = null;
    this.type = null;
    this.setTimeParams = function(h) {
        this.timeParams = h;
    };
    this.setByParam = function(h) {
        this.params = h;
    };
    this.getType = function(h) {
        if (h.match(/^[0-9]{12}Z$/)) return "utc";
        if (h.match(/^[0-9]{14}Z$/)) return "gen";
        if (h.match(/^[0-9]{12}\.[0-9]+Z$/)) return "utc";
        if (h.match(/^[0-9]{14}\.[0-9]+Z$/)) return "gen";
        return null;
    };
    this.tohex = function() {
        var i = this.params;
        var h = null;
        if (typeof i == "string") i = {
            str: i
        };
        if (i != null && i.str && (i.type == null || i.type == undefined)) i.type = this.getType(i.str);
        if (i != null && i.str) {
            if (i.type == "utc") h = new b(i.str);
            if (i.type == "gen") h = new g(i.str);
        } else if (this.type == "gen") h = new g();
        else h = new b();
        if (h == null) throw new Error("wrong setting for Time");
        this.TLV = h.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f != undefined) this.setByParam(f);
};
KJUR.asn1.x509.Time_bak = function(f) {
    KJUR.asn1.x509.Time_bak.superclass.constructor.call(this);
    var e = null, a = null, d = KJUR, c = d.asn1, b = c.DERUTCTime, g = c.DERGeneralizedTime;
    this.setTimeParams = function(h) {
        this.timeParams = h;
    };
    this.tohex = function() {
        var h = null;
        if (this.timeParams != null) {
            if (this.type == "utc") h = new b(this.timeParams);
            else h = new g(this.timeParams);
        } else if (this.type == "utc") h = new b();
        else h = new g();
        this.TLV = h.tohex();
        return this.TLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.type = "utc";
    if (f !== undefined) {
        if (f.type !== undefined) this.type = f.type;
        else if (f.str !== undefined) {
            if (f.str.match(/^[0-9]{12}Z$/)) this.type = "utc";
            if (f.str.match(/^[0-9]{14}Z$/)) this.type = "gen";
        }
        this.timeParams = f;
    }
};
extendClass(KJUR.asn1.x509.Time, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.AlgorithmIdentifier = function(e) {
    KJUR.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this);
    this.nameAlg = null;
    this.asn1Alg = null;
    this.asn1Params = null;
    this.paramEmpty = false;
    var b = KJUR, a = b.asn1, c = a.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
    this.tohex = function() {
        if (this.nameAlg === null && this.asn1Alg === null) throw new Error("algorithm not specified");
        if (this.nameAlg !== null) {
            var f = null;
            for(var h in c)if (h === this.nameAlg) f = c[h];
            if (f !== null) {
                this.hTLV = f;
                return this.hTLV;
            }
        }
        if (this.nameAlg !== null && this.asn1Alg === null) this.asn1Alg = a.x509.OID.name2obj(this.nameAlg);
        var g = [
            this.asn1Alg
        ];
        if (this.asn1Params !== null) g.push(this.asn1Params);
        var i = new a.DERSequence({
            array: g
        });
        this.hTLV = i.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) {
        if (e.name !== undefined) this.nameAlg = e.name;
        if (e.asn1params !== undefined) this.asn1Params = e.asn1params;
        if (e.paramempty !== undefined) this.paramEmpty = e.paramempty;
    }
    if (this.asn1Params === null && this.paramEmpty === false && this.nameAlg !== null) {
        if (this.nameAlg.name !== undefined) this.nameAlg = this.nameAlg.name;
        var d = this.nameAlg.toLowerCase();
        if (d.substr(-7, 7) !== "withdsa" && d.substr(-9, 9) !== "withecdsa") this.asn1Params = new a.DERNull();
    }
};
extendClass(KJUR.asn1.x509.AlgorithmIdentifier, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV = {
    SHAwithRSAandMGF1: "300d06092a864886f70d01010a3000",
    SHA256withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040201a11a301806092a864886f70d010108300b0609608648016503040201a203020120",
    SHA384withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040202a11a301806092a864886f70d010108300b0609608648016503040202a203020130",
    SHA512withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040203a11a301806092a864886f70d010108300b0609608648016503040203a203020140"
};
KJUR.asn1.x509.GeneralName = function(f) {
    KJUR.asn1.x509.GeneralName.superclass.constructor.call(this);
    var l = {
        rfc822: "81",
        dns: "82",
        dn: "a4",
        uri: "86",
        ip: "87",
        otherName: "a0"
    }, b = KJUR, h = b.asn1, d = h.x509, a = d.X500Name, g = d.OtherName, e = h.DERIA5String, i = h.DERPrintableString, k = h.DEROctetString, c = h.DERTaggedObject, m = h.ASN1Object, j = Error;
    this.params = null;
    this.setByParam = function(n) {
        this.params = n;
    };
    this.tohex = function() {
        var p = this.params;
        var A, y, q;
        var y = false;
        if (p.other !== undefined) A = "a0", q = new g(p.other);
        else {
            if (p.rfc822 !== undefined) {
                A = "81";
                q = new e({
                    str: p.rfc822
                });
            } else if (p.dns !== undefined) {
                A = "82";
                q = new e({
                    str: p.dns
                });
            } else {
                if (p.dn !== undefined) {
                    A = "a4";
                    y = true;
                    if (typeof p.dn === "string") q = new a({
                        str: p.dn
                    });
                    else if (p.dn instanceof KJUR.asn1.x509.X500Name) q = p.dn;
                    else q = new a(p.dn);
                } else if (p.ldapdn !== undefined) {
                    A = "a4";
                    y = true;
                    q = new a({
                        ldapstr: p.ldapdn
                    });
                } else {
                    if (p.certissuer !== undefined || p.certsubj !== undefined) {
                        A = "a4";
                        y = true;
                        var n, o;
                        var z = null;
                        if (p.certsubj !== undefined) {
                            n = false;
                            o = p.certsubj;
                        } else {
                            n = true;
                            o = p.certissuer;
                        }
                        o.match(/^[0-9A-Fa-f]+$/);
                        if (o.indexOf("-----BEGIN ") != -1) z = pemtohex(o);
                        if (z == null) throw new Error("certsubj/certissuer not cert");
                        var w = new X509();
                        w.hex = z;
                        var s;
                        if (n) s = w.getIssuerHex();
                        else s = w.getSubjectHex();
                        q = new m();
                        q.hTLV = s;
                    } else if (p.uri !== undefined) {
                        A = "86";
                        q = new e({
                            str: p.uri
                        });
                    } else {
                        if (p.ip !== undefined) {
                            A = "87";
                            var v;
                            var t = p.ip;
                            try {
                                if (t.match(/^[0-9a-f]+$/)) {
                                    var r = t.length;
                                    if (r == 8 || r == 16 || r == 32 || r == 64) v = t;
                                    else throw "err";
                                } else v = iptohex(t);
                            } catch (u) {
                                throw new j("malformed IP address: " + p.ip + ":" + u.message);
                            }
                            q = new k({
                                hex: v
                            });
                        } else throw new j("improper params");
                    }
                }
            }
        }
        var B = new c({
            tag: A,
            explicit: y,
            obj: q
        });
        return B.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f !== undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.x509.GeneralName, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.GeneralNames = function(d) {
    KJUR.asn1.x509.GeneralNames.superclass.constructor.call(this);
    var a = null, c = KJUR, b = c.asn1;
    this.setByParamArray = function(g) {
        for(var e = 0; e < g.length; e++){
            var f = new b.x509.GeneralName(g[e]);
            this.asn1Array.push(f);
        }
    };
    this.tohex = function() {
        var e = new b.DERSequence({
            array: this.asn1Array
        });
        return e.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.asn1Array = new Array();
    if (typeof d != "undefined") this.setByParamArray(d);
};
extendClass(KJUR.asn1.x509.GeneralNames, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.OtherName = function(g) {
    KJUR.asn1.x509.OtherName.superclass.constructor.call(this);
    var f = null, e = null, d = KJUR, c = d.asn1, h = c.DERObjectIdentifier, a = c.DERSequence, b = c.ASN1Util.newObject;
    this.params = null;
    this.setByParam = function(i) {
        this.params = i;
    };
    this.tohex = function() {
        var k = this.params;
        if (k.oid == undefined || k.value == undefined) throw new Error("oid or value not specified");
        var l = new h({
            oid: k.oid
        });
        var i = b({
            tag: {
                tag: "a0",
                explicit: true,
                obj: k.value
            }
        });
        var j = new a({
            array: [
                l,
                i
            ]
        });
        return j.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g !== undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.x509.OtherName, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.OID = new function() {
    var a = KJUR.asn1.DERObjectIdentifier;
    this.name2oidList = {
        "aes128-CBC": "2.16.840.1.101.3.4.1.2",
        "aes256-CBC": "2.16.840.1.101.3.4.1.42",
        sha1: "1.3.14.3.2.26",
        sha256: "2.16.840.1.101.3.4.2.1",
        sha384: "2.16.840.1.101.3.4.2.2",
        sha512: "2.16.840.1.101.3.4.2.3",
        sha224: "2.16.840.1.101.3.4.2.4",
        md5: "1.2.840.113549.2.5",
        md2: "1.3.14.7.2.2.1",
        ripemd160: "1.3.36.3.2.1",
        hmacWithSHA1: "1.2.840.113549.2.7",
        hmacWithSHA224: "1.2.840.113549.2.8",
        hmacWithSHA256: "1.2.840.113549.2.9",
        hmacWithSHA384: "1.2.840.113549.2.10",
        hmacWithSHA512: "1.2.840.113549.2.11",
        MD2withRSA: "1.2.840.113549.1.1.2",
        MD4withRSA: "1.2.840.113549.1.1.3",
        MD5withRSA: "1.2.840.113549.1.1.4",
        SHA1withRSA: "1.2.840.113549.1.1.5",
        "pkcs1-MGF": "1.2.840.113549.1.1.8",
        rsaPSS: "1.2.840.113549.1.1.10",
        SHA224withRSA: "1.2.840.113549.1.1.14",
        SHA256withRSA: "1.2.840.113549.1.1.11",
        SHA384withRSA: "1.2.840.113549.1.1.12",
        SHA512withRSA: "1.2.840.113549.1.1.13",
        SHA1withECDSA: "1.2.840.10045.4.1",
        SHA224withECDSA: "1.2.840.10045.4.3.1",
        SHA256withECDSA: "1.2.840.10045.4.3.2",
        SHA384withECDSA: "1.2.840.10045.4.3.3",
        SHA512withECDSA: "1.2.840.10045.4.3.4",
        dsa: "1.2.840.10040.4.1",
        SHA1withDSA: "1.2.840.10040.4.3",
        SHA224withDSA: "2.16.840.1.101.3.4.3.1",
        SHA256withDSA: "2.16.840.1.101.3.4.3.2",
        rsaEncryption: "1.2.840.113549.1.1.1",
        commonName: "2.5.4.3",
        countryName: "2.5.4.6",
        localityName: "2.5.4.7",
        stateOrProvinceName: "2.5.4.8",
        streetAddress: "2.5.4.9",
        organizationName: "2.5.4.10",
        organizationalUnitName: "2.5.4.11",
        domainComponent: "0.9.2342.19200300.100.1.25",
        userId: "0.9.2342.19200300.100.1.1",
        surname: "2.5.4.4",
        givenName: "2.5.4.42",
        title: "2.5.4.12",
        distinguishedName: "2.5.4.49",
        emailAddress: "1.2.840.113549.1.9.1",
        description: "2.5.4.13",
        businessCategory: "2.5.4.15",
        postalCode: "2.5.4.17",
        uniqueIdentifier: "2.5.4.45",
        organizationIdentifier: "2.5.4.97",
        jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1",
        jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2",
        jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3",
        subjectDirectoryAttributes: "2.5.29.9",
        subjectKeyIdentifier: "2.5.29.14",
        keyUsage: "2.5.29.15",
        subjectAltName: "2.5.29.17",
        issuerAltName: "2.5.29.18",
        basicConstraints: "2.5.29.19",
        cRLNumber: "2.5.29.20",
        cRLReason: "2.5.29.21",
        nameConstraints: "2.5.29.30",
        cRLDistributionPoints: "2.5.29.31",
        certificatePolicies: "2.5.29.32",
        anyPolicy: "2.5.29.32.0",
        policyMappings: "2.5.29.33",
        authorityKeyIdentifier: "2.5.29.35",
        policyConstraints: "2.5.29.36",
        extKeyUsage: "2.5.29.37",
        inhibitAnyPolicy: "2.5.29.54",
        authorityInfoAccess: "1.3.6.1.5.5.7.1.1",
        ocsp: "1.3.6.1.5.5.7.48.1",
        ocspBasic: "1.3.6.1.5.5.7.48.1.1",
        ocspNonce: "1.3.6.1.5.5.7.48.1.2",
        ocspNoCheck: "1.3.6.1.5.5.7.48.1.5",
        caIssuers: "1.3.6.1.5.5.7.48.2",
        anyExtendedKeyUsage: "2.5.29.37.0",
        serverAuth: "1.3.6.1.5.5.7.3.1",
        clientAuth: "1.3.6.1.5.5.7.3.2",
        codeSigning: "1.3.6.1.5.5.7.3.3",
        emailProtection: "1.3.6.1.5.5.7.3.4",
        timeStamping: "1.3.6.1.5.5.7.3.8",
        ocspSigning: "1.3.6.1.5.5.7.3.9",
        smtpUTF8Mailbox: "1.3.6.1.5.5.7.8.9",
        dateOfBirth: "1.3.6.1.5.5.7.9.1",
        placeOfBirth: "1.3.6.1.5.5.7.9.2",
        gender: "1.3.6.1.5.5.7.9.3",
        countryOfCitizenship: "1.3.6.1.5.5.7.9.4",
        countryOfResidence: "1.3.6.1.5.5.7.9.5",
        ecPublicKey: "1.2.840.10045.2.1",
        "P-256": "1.2.840.10045.3.1.7",
        secp256r1: "1.2.840.10045.3.1.7",
        secp256k1: "1.3.132.0.10",
        secp384r1: "1.3.132.0.34",
        secp521r1: "1.3.132.0.35",
        pkcs5PBES2: "1.2.840.113549.1.5.13",
        pkcs5PBKDF2: "1.2.840.113549.1.5.12",
        "des-EDE3-CBC": "1.2.840.113549.3.7",
        data: "1.2.840.113549.1.7.1",
        "signed-data": "1.2.840.113549.1.7.2",
        "enveloped-data": "1.2.840.113549.1.7.3",
        "digested-data": "1.2.840.113549.1.7.5",
        "encrypted-data": "1.2.840.113549.1.7.6",
        "authenticated-data": "1.2.840.113549.1.9.16.1.2",
        tstinfo: "1.2.840.113549.1.9.16.1.4",
        signingCertificate: "1.2.840.113549.1.9.16.2.12",
        timeStampToken: "1.2.840.113549.1.9.16.2.14",
        signaturePolicyIdentifier: "1.2.840.113549.1.9.16.2.15",
        etsArchiveTimeStamp: "1.2.840.113549.1.9.16.2.27",
        signingCertificateV2: "1.2.840.113549.1.9.16.2.47",
        etsArchiveTimeStampV2: "1.2.840.113549.1.9.16.2.48",
        extensionRequest: "1.2.840.113549.1.9.14",
        contentType: "1.2.840.113549.1.9.3",
        messageDigest: "1.2.840.113549.1.9.4",
        signingTime: "1.2.840.113549.1.9.5",
        counterSignature: "1.2.840.113549.1.9.6",
        archiveTimeStampV3: "0.4.0.1733.2.4",
        pdfRevocationInfoArchival: "1.2.840.113583.1.1.8",
        adobeTimeStamp: "1.2.840.113583.1.1.9.1",
        smimeMailboxLegacy: "2.23.140.1.5.1.1",
        smimeMailboxMulti: "2.23.140.1.5.1.2",
        smimeMailboxStrict: "2.23.140.1.5.1.3",
        smimeOrganizationLegacy: "2.23.140.1.5.2.1",
        smimeOrganizationMulti: "2.23.140.1.5.2.2",
        smimeOrganizationStrict: "2.23.140.1.5.2.3",
        smimeSponsorLegacy: "2.23.140.1.5.3.1",
        smimeSponsorMulti: "2.23.140.1.5.3.2",
        smimeSponsorStrict: "2.23.140.1.5.3.3",
        smimeIndividualLegacy: "2.23.140.1.5.4.1",
        smimeIndividualMulti: "2.23.140.1.5.4.2",
        smimeIndividualStrict: "2.23.140.1.5.4.3"
    };
    this.atype2oidList = {
        CN: "2.5.4.3",
        L: "2.5.4.7",
        ST: "2.5.4.8",
        O: "2.5.4.10",
        OU: "2.5.4.11",
        C: "2.5.4.6",
        STREET: "2.5.4.9",
        DC: "0.9.2342.19200300.100.1.25",
        UID: "0.9.2342.19200300.100.1.1",
        SN: "2.5.4.4",
        T: "2.5.4.12",
        GN: "2.5.4.42",
        DN: "2.5.4.49",
        E: "1.2.840.113549.1.9.1",
        description: "2.5.4.13",
        businessCategory: "2.5.4.15",
        postalCode: "2.5.4.17",
        serialNumber: "2.5.4.5",
        uniqueIdentifier: "2.5.4.45",
        organizationIdentifier: "2.5.4.97",
        jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1",
        jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2",
        jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3"
    };
    this.objCache = {};
    this.name2obj = function(b) {
        if (typeof this.objCache[b] != "undefined") return this.objCache[b];
        if (typeof this.name2oidList[b] == "undefined") throw "Name of ObjectIdentifier not defined: " + b;
        var c = this.name2oidList[b];
        var d = new a({
            oid: c
        });
        this.objCache[b] = d;
        return d;
    };
    this.atype2obj = function(b) {
        if (this.objCache[b] !== undefined) return this.objCache[b];
        var c;
        if (b.match(/^\d+\.\d+\.[0-9.]+$/)) c = b;
        else if (this.atype2oidList[b] !== undefined) c = this.atype2oidList[b];
        else {
            if (this.name2oidList[b] !== undefined) c = this.name2oidList[b];
            else throw new Error("AttributeType name undefined: " + b);
        }
        var d = new a({
            oid: c
        });
        this.objCache[b] = d;
        return d;
    };
    this.registerOIDs = function(b) {
        if (!this.checkOIDs(b)) return;
        for(var c in b)this.name2oidList[c] = b[c];
    };
    this.checkOIDs = function(b) {
        try {
            var d = Object.keys(b);
            if (d.length == 0) return false;
            d.map(function(g, e, h) {
                var f = this[g];
                if (!f.match(/^[0-2]\.[0-9.]+$/)) throw new Error("value is not OID");
            }, b);
            return true;
        } catch (c) {
            return false;
        }
    };
};
KJUR.asn1.x509.OID.oid2name = function(b) {
    var c = KJUR.asn1.x509.OID.name2oidList;
    for(var a in c){
        if (c[a] == b) return a;
    }
    return "";
};
KJUR.asn1.x509.OID.oid2atype = function(b) {
    var c = KJUR.asn1.x509.OID.atype2oidList;
    for(var a in c){
        if (c[a] == b) return a;
    }
    return b;
};
KJUR.asn1.x509.OID.name2oid = function(a) {
    if (a.match(/^[0-9.]+$/)) return a;
    var b = KJUR.asn1.x509.OID.name2oidList;
    if (b[a] === undefined) return "";
    return b[a];
};
KJUR.asn1.x509.X509Util = {};
KJUR.asn1.x509.X509Util.newCertPEM = function(e) {
    var d = KJUR.asn1.x509, b = d.TBSCertificate, a = d.Certificate;
    var c = new a(e);
    return c.getPEM();
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};
if (typeof KJUR.asn1.cms == "undefined" || !KJUR.asn1.cms) KJUR.asn1.cms = {};
KJUR.asn1.cms.Attribute = function(f) {
    var e = Error, d = KJUR, c = d.asn1, b = c.DERSequence, a = c.DERSet, g = c.DERObjectIdentifier;
    this.params = null;
    this.typeOid = null;
    this.setByParam = function(h) {
        this.params = h;
    };
    this.getValueArray = function() {
        throw new e("not yet implemented abstract");
    };
    this.tohex = function() {
        var j = new g({
            oid: this.typeOid
        });
        var h = new a({
            array: this.getValueArray()
        });
        var i = new b({
            array: [
                j,
                h
            ]
        });
        return i.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
};
extendClass(KJUR.asn1.cms.Attribute, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.ContentType = function(c) {
    var b = KJUR, a = b.asn1;
    a.cms.ContentType.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.3";
    this.getValueArray = function() {
        var d = new a.DERObjectIdentifier(this.params.type);
        return [
            d
        ];
    };
    if (c != undefined) this.setByParam(c);
};
extendClass(KJUR.asn1.cms.ContentType, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.MessageDigest = function(e) {
    var b = KJUR, a = b.asn1, c = a.DEROctetString, d = a.cms;
    d.MessageDigest.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.4";
    this.getValueArray = function() {
        var f = new c(this.params);
        return [
            f
        ];
    };
    if (e != undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.cms.MessageDigest, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.SigningTime = function(c) {
    var b = KJUR, a = b.asn1;
    a.cms.SigningTime.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.5";
    this.getValueArray = function() {
        var d = new a.x509.Time(this.params);
        return [
            d
        ];
    };
    if (c != undefined) this.setByParam(c);
};
extendClass(KJUR.asn1.cms.SigningTime, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.SigningCertificate = function(h) {
    var e = Error, d = KJUR, c = d.asn1, b = c.DERSequence, g = c.cms, a = g.ESSCertID, f = d.crypto;
    g.SigningCertificate.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.12";
    this.getValueArray = function() {
        if (this.params == null || this.params == undefined || this.params.array == undefined) throw new e("parameter 'array' not specified");
        var o = this.params.array;
        var k = [];
        for(var l = 0; l < o.length; l++){
            var n = o[l];
            if (h.hasis == false && typeof n == "string" && (n.indexOf("-----BEGIN") != -1 || ASN1HEX.isASN1HEX(n))) n = {
                cert: n
            };
            if (n.hasis != false && h.hasis == false) n.hasis = false;
            k.push(new a(n));
        }
        var j = new b({
            array: k
        });
        var m = new b({
            array: [
                j
            ]
        });
        return [
            m
        ];
    };
    if (h != undefined) this.setByParam(h);
};
extendClass(KJUR.asn1.cms.SigningCertificate, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.ESSCertID = function(g) {
    KJUR.asn1.cms.ESSCertID.superclass.constructor.call(this);
    var d = Error, c = KJUR, b = c.asn1, f = b.DEROctetString, a = b.DERSequence, e = b.cms.IssuerSerial;
    this.params = null;
    this.getCertHash = function(k, h) {
        if (k.hash != undefined) return k.hash;
        if (typeof k == "string" && k.indexOf("-----BEGIN") == -1 && !ASN1HEX.isASN1HEX(k)) return k;
        var i;
        if (typeof k == "string") i = k;
        else {
            if (k.cert != undefined) i = k.cert;
            else throw new d("hash nor cert unspecified");
        }
        var j;
        if (i.indexOf("-----BEGIN") != -1) j = pemtohex(i);
        else j = i;
        if (typeof k == "string") {
            if (k.indexOf("-----BEGIN") != -1) j = pemtohex(k);
            else if (ASN1HEX.isASN1HEX(k)) j = k;
        }
        var l;
        if (k.alg != undefined) l = k.alg;
        else {
            if (h != undefined) l = h;
            else throw new d("hash alg unspecified");
        }
        return c.crypto.Util.hashHex(j, l);
    };
    this.tohex = function() {
        var k = this.params;
        var j = this.getCertHash(k, "sha1");
        var h = [];
        h.push(new f({
            hex: j
        }));
        if (typeof k == "string" && k.indexOf("-----BEGIN") != -1 || k.cert != undefined && k.hasis != false || k.issuer != undefined && k.serial != undefined) h.push(new e(k));
        var i = new a({
            array: h
        });
        return i.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.cms.ESSCertID, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.SigningCertificateV2 = function(d) {
    var h = Error, a = KJUR, g = a.asn1, e = g.DERSequence, b = g.x509, i = g.cms, c = i.ESSCertIDv2, f = a.crypto;
    i.SigningCertificateV2.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.47";
    this.getValueArray = function() {
        if (this.params == null || this.params == undefined || this.params.array == undefined) throw new h("parameter 'array' not specified");
        var o = this.params.array;
        var l = [];
        for(var m = 0; m < o.length; m++){
            var n = o[m];
            if ((d.alg != undefined || d.hasis == false) && typeof n == "string" && (n.indexOf("-----BEGIN") != -1 || ASN1HEX.isASN1HEX(n))) n = {
                cert: n
            };
            if (n.alg == undefined && d.alg != undefined) n.alg = d.alg;
            if (n.hasis != false && d.hasis == false) n.hasis = false;
            l.push(new c(n));
        }
        var k = new e({
            array: l
        });
        var j = new e({
            array: [
                k
            ]
        });
        return [
            j
        ];
    };
    if (d != undefined) this.setByParam(d);
};
extendClass(KJUR.asn1.cms.SigningCertificateV2, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.ESSCertIDv2 = function(h) {
    KJUR.asn1.cms.ESSCertIDv2.superclass.constructor.call(this);
    var d = Error, c = KJUR, b = c.asn1, f = b.DEROctetString, a = b.DERSequence, e = b.cms.IssuerSerial, g = b.x509.AlgorithmIdentifier;
    this.params = null;
    this.tohex = function() {
        var l = this.params;
        var k = this.getCertHash(l, "sha256");
        var i = [];
        if (l.alg != undefined && l.alg != "sha256") i.push(new g({
            name: l.alg
        }));
        i.push(new f({
            hex: k
        }));
        if (typeof l == "string" && l.indexOf("-----BEGIN") != -1 || l.cert != undefined && l.hasis != false || l.issuer != undefined && l.serial != undefined) i.push(new e(l));
        var j = new a({
            array: i
        });
        return j.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (h != undefined) this.setByParam(h);
};
extendClass(KJUR.asn1.cms.ESSCertIDv2, KJUR.asn1.cms.ESSCertID);
KJUR.asn1.cms.IssuerSerial = function(e) {
    var i = Error, c = KJUR, h = c.asn1, g = h.DERInteger, f = h.DERSequence, j = h.cms, d = h.x509, a = d.GeneralNames, b = X509;
    j.IssuerSerial.superclass.constructor.call(this);
    this.setByParam = function(k) {
        this.params = k;
    };
    this.tohex = function() {
        var p = this.params;
        var l, r;
        if (typeof p == "string" && p.indexOf("-----BEGIN") != -1 || p.cert != undefined) {
            var n;
            if (p.cert != undefined) n = p.cert;
            else n = p;
            var k = new b();
            k.readCertPEM(n);
            l = k.getIssuer();
            r = {
                hex: k.getSerialNumberHex()
            };
        } else {
            if (p.issuer != undefined && p.serial) {
                l = p.issuer;
                r = p.serial;
            } else throw new i("cert or issuer and serial parameter not specified");
        }
        var q = new a([
            {
                dn: l
            }
        ]);
        var o = new g(r);
        var m = new f({
            array: [
                q,
                o
            ]
        });
        return m.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e != undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.cms.IssuerSerial, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.SignerIdentifier = function(f) {
    var c = KJUR, i = c.asn1, h = i.DERInteger, g = i.DERSequence, l = i.cms, k = l.IssuerAndSerialNumber, d = l.SubjectKeyIdentifier, e = i.x509, a = e.X500Name, b = X509, j = Error;
    l.SignerIdentifier.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var o = this.params;
        if (o.type == "isssn") {
            var m = new k(o);
            return m.tohex();
        } else {
            if (o.type == "skid") {
                var n = new d(o);
                return n.tohex();
            } else throw new Error("wrong property for isssn or skid");
        }
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f != undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.cms.SignerIdentifier, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.IssuerAndSerialNumber = function(e) {
    var c = KJUR, h = c.asn1, g = h.DERInteger, f = h.DERSequence, j = h.cms, d = h.x509, a = d.X500Name, b = X509, i = Error;
    j.IssuerAndSerialNumber.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var p = this.params;
        var l, r;
        if (typeof p == "string" && p.indexOf("-----BEGIN") != -1 || p.cert != undefined) {
            var n;
            if (p.cert != undefined) n = p.cert;
            else n = p;
            var k = new b();
            k.readCertPEM(n);
            l = k.getIssuer();
            r = {
                hex: k.getSerialNumberHex()
            };
        } else {
            if (p.issuer != undefined && p.serial) {
                l = p.issuer;
                r = p.serial;
            } else throw new i("cert or issuer and serial parameter not specified");
        }
        var q = new a(l);
        var o = new g(r);
        var m = new f({
            array: [
                q,
                o
            ]
        });
        return m.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(k) {
        this.params = k;
    };
    if (e != undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.cms.IssuerAndSerialNumber, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.SubjectKeyIdentifier = function(g) {
    var d = KJUR, k = d.asn1, i = k.DERInteger, h = k.DERSequence, j = k.ASN1Util.newObject, m = k.cms, f = m.IssuerAndSerialName, c = m.SubjectKeyIdentifier, e = k.x509, a = e.X500Name, b = X509, l = Error;
    m.SubjectKeyIdentifier.superclass.constructor.call(this);
    this.tohex = function() {
        var r = this.params;
        if (r.cert == undefined && r.skid == undefined) throw new l("property cert nor skid undefined");
        var q;
        if (r.cert != undefined) {
            var n = new b(r.cert);
            var o = n.getExtSubjectKeyIdentifier();
            q = o.kid.hex;
        } else if (r.skid != undefined) q = r.skid;
        var p = j({
            tag: {
                tage: "a0",
                obj: {
                    octstr: {
                        hex: q
                    }
                }
            }
        });
        return p.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.cms.SubjectKeyIdentifier, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.AttributeList = function(f) {
    var d = Error, c = KJUR, b = c.asn1, a = b.DERSet, e = b.cms;
    e.AttributeList.superclass.constructor.call(this);
    this.params = null;
    this.hTLV = null;
    this.setByParam = function(g) {
        this.params = g;
    };
    this.tohex = function() {
        var o = this.params;
        if (this.hTLV != null) return this.hTLV;
        var m = true;
        if (o.sortflag != undefined) m = o.sortflag;
        var j = o.array;
        var g = [];
        for(var l = 0; l < j.length; l++){
            var n = j[l];
            var k = n.attr;
            if (k == "contentType") g.push(new e.ContentType(n));
            else if (k == "messageDigest") g.push(new e.MessageDigest(n));
            else {
                if (k == "signingTime") g.push(new e.SigningTime(n));
                else if (k == "signingCertificate") g.push(new e.SigningCertificate(n));
                else {
                    if (k == "signingCertificateV2") g.push(new e.SigningCertificateV2(n));
                    else if (k == "signaturePolicyIdentifier") g.push(new KJUR.asn1.cades.SignaturePolicyIdentifier(n));
                    else {
                        if (k == "signatureTimeStamp" || k == "timeStampToken") g.push(new KJUR.asn1.cades.SignatureTimeStamp(n));
                        else throw new d("unknown attr: " + k);
                    }
                }
            }
        }
        var h = new a({
            array: g,
            sortflag: m
        });
        this.hTLV = h.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f != undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.cms.AttributeList, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.SignerInfo = function(q) {
    var n = Error, r = KJUR, i = r.asn1, c = i.DERInteger, f = i.DEROctetString, h = i.DERSequence, m = i.DERTaggedObject, k = i.cms, p = k.SignerIdentifier, l = k.AttributeList, g = k.ContentType, e = k.EncapsulatedContentInfo, d = k.MessageDigest, j = k.SignedData, a = i.x509, s = a.AlgorithmIdentifier, b = r.crypto, o = KEYUTIL;
    k.SignerInfo.superclass.constructor.call(this);
    this.params = null;
    this.sign = function() {
        var y = this.params;
        var x = y.sigalg;
        var u = new l(y.sattrs).tohex();
        var v = o.getKey(y.signkey);
        var w = new b.Signature({
            alg: x
        });
        w.init(v);
        w.updateHex(u);
        var t = w.sign();
        y.sighex = t;
    };
    this.tohex = function() {
        var w = this.params;
        var t = [];
        t.push(new c({
            "int": w.version
        }));
        t.push(new p(w.id));
        t.push(new s({
            name: w.hashalg
        }));
        if (w.sattrs != undefined) {
            var x = new l(w.sattrs);
            try {
                t.push(new m({
                    tag: "a0",
                    explicit: false,
                    obj: x
                }));
            } catch (v) {
                throw new n("si sattr error: " + v);
            }
        }
        if (w.sigalgfield != undefined) t.push(new s({
            name: w.sigalgfield
        }));
        else t.push(new s({
            name: w.sigalg
        }));
        if (w.sighex == undefined && w.signkey != undefined) this.sign();
        t.push(new f({
            hex: w.sighex
        }));
        if (w.uattrs != undefined) {
            var x = new l(w.uattrs);
            try {
                t.push(new m({
                    tag: "a1",
                    explicit: false,
                    obj: x
                }));
            } catch (v) {
                throw new n("si uattr error: " + v);
            }
        }
        var u = new h({
            array: t
        });
        return u.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (q != undefined) this.setByParam(q);
};
extendClass(KJUR.asn1.cms.SignerInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.EncapsulatedContentInfo = function(g) {
    var c = KJUR, b = c.asn1, e = b.DERTaggedObject, a = b.DERSequence, h = b.DERObjectIdentifier, d = b.DEROctetString, f = b.cms;
    f.EncapsulatedContentInfo.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var m = this.params;
        var i = [];
        i.push(new h(m.type));
        if (m.content != undefined && (m.content.hex != undefined || m.content.str != undefined) && m.isDetached != true) {
            var k = new d(m.content);
            var l = new e({
                tag: "a0",
                explicit: true,
                obj: k
            });
            i.push(l);
        }
        var j = new a({
            array: i
        });
        return j.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(i) {
        this.params = i;
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.cms.EncapsulatedContentInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.ContentInfo = function(g) {
    var c = KJUR, b = c.asn1, d = b.DERTaggedObject, a = b.DERSequence, h = b.DERObjectIdentifier, f = b.x509, e = f.OID.name2obj;
    KJUR.asn1.cms.ContentInfo.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var l = this.params;
        var i = [];
        i.push(new h(l.type));
        var k = new d({
            tag: "a0",
            explicit: true,
            obj: l.obj
        });
        i.push(k);
        var j = new a({
            array: i
        });
        return j.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(i) {
        this.params = i;
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.cms.ContentInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.SignedData = function(e) {
    var j = Error, a = KJUR, h = a.asn1, m = h.ASN1Object, g = h.DERInteger, p = h.DERSet, f = h.DERSequence, b = h.DERTaggedObject, o = h.cms, l = o.EncapsulatedContentInfo, d = o.SignerInfo, q = o.ContentInfo, k = o.CertificateSet, i = o.RevocationInfoChoices, c = h.x509, n = c.AlgorithmIdentifier;
    KJUR.asn1.cms.SignedData.superclass.constructor.call(this);
    this.params = null;
    this.checkAndFixParam = function() {
        var r = this.params;
        this._setDigestAlgs(r);
        this._setContentTypeByEContent(r);
        this._setMessageDigestByEContent(r);
        this._setSignerInfoVersion(r);
        this._setSignedDataVersion(r);
    };
    this._setDigestAlgs = function(v) {
        var u = {};
        var t = v.sinfos;
        for(var r = 0; r < t.length; r++){
            var s = t[r];
            u[s.hashalg] = 1;
        }
        v.hashalgs = Object.keys(u).sort();
    };
    this._setContentTypeByEContent = function(w) {
        var u = w.econtent.type;
        var v = w.sinfos;
        for(var r = 0; r < v.length; r++){
            var t = v[r];
            var s = this._getAttrParamByName(t, "contentType");
            s.type = u;
        }
    };
    this._setMessageDigestByEContent = function(r) {
        var v = r.econtent;
        var y = r.econtent.type;
        var x = v.content.hex;
        if (x == undefined && v.type == "data" && v.content.str != undefined) x = rstrtohex(v.content.str);
        var A = r.sinfos;
        for(var u = 0; u < A.length; u++){
            var t = A[u];
            var s = t.hashalg;
            var z = this._getAttrParamByName(t, "messageDigest");
            var w = KJUR.crypto.Util.hashHex(x, s);
            z.hex = w;
        }
    };
    this._getAttrParamByName = function(t, s) {
        var u = t.sattrs.array;
        for(var r = 0; r < u.length; r++){
            if (u[r].attr == s) return u[r];
        }
    };
    this._setSignerInfoVersion = function(v) {
        var t = v.sinfos;
        for(var r = 0; r < t.length; r++){
            var s = t[r];
            var u = 1;
            if (s.id.type == "skid") u = 3;
            s.version = u;
        }
    };
    this._setSignedDataVersion = function(s) {
        var r = this._getSignedDataVersion(s);
        s.version = r;
    };
    this._getSignedDataVersion = function(w) {
        if (w.revinfos != undefined) {
            var r = w.revinfos;
            for(var t = 0; t < r.length; t++){
                var s = r[t];
                if (s.ocsp != undefined) return 5;
            }
        }
        var v = w.sinfos;
        for(var t = 0; t < v.length; t++){
            var u = w.sinfos[t];
            if (u.version == 3) return 3;
        }
        if (w.econtent.type != "data") return 3;
        return 1;
    };
    this.tohex = function() {
        var y = this.params;
        if (this.getEncodedHexPrepare != undefined) this.getEncodedHexPrepare();
        if (y.fixed != true) this.checkAndFixParam();
        var r = [];
        r.push(new g({
            "int": y.version
        }));
        var w = [];
        for(var v = 0; v < y.hashalgs.length; v++){
            var t = y.hashalgs[v];
            w.push(new n({
                name: t
            }));
        }
        r.push(new p({
            array: w
        }));
        r.push(new l(y.econtent));
        if (y.certs != undefined) r.push(new k(y.certs));
        if (y.revinfos != undefined) r.push(new i(y.revinfos));
        var u = [];
        for(var v = 0; v < y.sinfos.length; v++){
            var x = y.sinfos[v];
            u.push(new d(x));
        }
        r.push(new p({
            array: u
        }));
        var s = new f({
            array: r
        });
        return s.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.getContentInfo = function() {
        var r = new q({
            type: "signed-data",
            obj: this
        });
        return r;
    };
    this.getContentInfoEncodedHex = function() {
        return this.getContentInfo().tohex();
    };
    if (e != undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.cms.SignedData, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.CertificateSet = function(f) {
    KJUR.asn1.cms.CertificateSet.superclass.constructor.call(this);
    var c = Error, b = KJUR.asn1, e = b.DERTaggedObject, a = b.DERSet, d = b.ASN1Object;
    this.params = null;
    this.tohex = function() {
        var j = this.params;
        var p = [];
        var q;
        if (j instanceof Array) q = j;
        else {
            if (j.array != undefined) q = j.array;
            else throw new c("cert array not specified");
        }
        for(var k = 0; k < q.length; k++){
            var l = q[k];
            var n = pemtohex(l);
            var g = new d();
            g.hTLV = n;
            p.push(g);
        }
        var m = {
            array: p
        };
        if (j.sortflag == false) m.sortflag = false;
        var o = new a(m);
        var h = new e({
            tag: "a0",
            explicit: false,
            obj: o
        });
        return h.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f != undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.cms.CertificateSet, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.RevocationInfoChoices = function(a) {
    KJUR.asn1.cms.RevocationInfoChoices.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var e = this.params;
        if (!e instanceof Array) throw new Error("params is not array");
        var b = [];
        for(var c = 0; c < e.length; c++)b.push(new KJUR.asn1.cms.RevocationInfoChoice(e[c]));
        var d = KJUR.asn1.ASN1Util.newObject({
            tag: {
                tagi: "a1",
                obj: {
                    set: b
                }
            }
        });
        return d.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (a != undefined) this.setByParam(a);
};
extendClass(KJUR.asn1.cms.RevocationInfoChoices, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.RevocationInfoChoice = function(a) {
    KJUR.asn1.cms.RevocationInfoChoice.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var d = this.params;
        if (d.crl != undefined && typeof d.crl == "string") {
            var b = d.crl;
            if (d.crl.indexOf("-----BEGIN") != -1) b = pemtohex(d.crl);
            return b;
        } else {
            if (d.ocsp != undefined) {
                var c = KJUR.asn1.ASN1Util.newObject({
                    tag: {
                        tagi: "a1",
                        obj: new KJUR.asn1.cms.OtherRevocationFormat(d)
                    }
                });
                return c.tohex();
            } else throw new Error("property crl or ocsp undefined");
        }
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (a != undefined) this.setByParam(a);
};
extendClass(KJUR.asn1.cms.RevocationInfoChoice, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.OtherRevocationFormat = function(f) {
    KJUR.asn1.cms.OtherRevocationFormat.superclass.constructor.call(this);
    var d = Error, c = KJUR, b = c.asn1, a = b.ASN1Util.newObject, e = c.lang.String.isHex;
    this.params = null;
    this.tohex = function() {
        var h = this.params;
        if (h.ocsp == undefined) throw new d("property ocsp not specified");
        if (!e(h.ocsp) || !ASN1HEX.isASN1HEX(h.ocsp)) throw new d("ocsp value not ASN.1 hex string");
        var g = a({
            seq: [
                {
                    oid: "1.3.6.1.5.5.7.16.2"
                },
                {
                    asn1: {
                        tlv: h.ocsp
                    }
                }
            ]
        });
        return g.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f != undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.cms.OtherRevocationFormat, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.CMSUtil = new function() {};
KJUR.asn1.cms.CMSUtil.newSignedData = function(a) {
    return new KJUR.asn1.cms.SignedData(a);
};
KJUR.asn1.cms.CMSUtil.verifySignedData = function(n) {
    var C = KJUR, p = C.asn1, s = p.cms, D = s.SignerInfo, q = s.SignedData, y = s.SigningTime, b = s.SigningCertificate, d = s.SigningCertificateV2, A = p.cades, u = A.SignaturePolicyIdentifier, i = C.lang.String.isHex, v = ASN1HEX, h = v.getVbyList, a = v.getTLVbyList, t = v.getIdxbyList, z = v.getChildIdx, c = v.getTLV, B = v.oidname, j = C.crypto.Util.hashHex;
    n.cms === undefined && i(n.cms);
    var E = n.cms;
    var g = function(J, H) {
        var G;
        for(var I = 3; I < 6; I++){
            G = t(J, 0, [
                1,
                0,
                I
            ]);
            if (G !== undefined) {
                var F = J.substr(G, 2);
                if (F === "a0") H.certsIdx = G;
                if (F === "a1") H.revinfosIdx = G;
                if (F === "31") H.signerinfosIdx = G;
            }
        }
    };
    var l = function(I, F) {
        var H = F.signerinfosIdx;
        if (H === undefined) return;
        var L = z(I, H);
        F.signerInfoIdxList = L;
        for(var G = 0; G < L.length; G++){
            var K = L[G];
            var J = {
                idx: K
            };
            k(I, J);
            F.signerInfos.push(J);
        }
    };
    var k = function(I, J) {
        var F = J.idx;
        J.signerid_issuer1 = a(I, F, [
            1,
            0
        ], "30");
        J.signerid_serial1 = h(I, F, [
            1,
            1
        ], "02");
        J.hashalg = B(h(I, F, [
            2,
            0
        ], "06"));
        var H = t(I, F, [
            3
        ], "a0");
        J.idxSignedAttrs = H;
        f(I, J, H);
        var G = z(I, F);
        var K = G.length;
        if (K < 6) throw "malformed SignerInfo";
        J.sigalg = B(h(I, F, [
            K - 2,
            0
        ], "06"));
        J.sigval = h(I, F, [
            K - 1
        ], "04");
    };
    var f = function(L, M, F) {
        var J = z(L, F);
        M.signedAttrIdxList = J;
        for(var K = 0; K < J.length; K++){
            var I = J[K];
            var G = h(L, I, [
                0
            ], "06");
            var H;
            if (G === "2a864886f70d010905") {
                H = hextoutf8(h(L, I, [
                    1,
                    0
                ]));
                M.saSigningTime = H;
            } else if (G === "2a864886f70d010904") {
                H = h(L, I, [
                    1,
                    0
                ], "04");
                M.saMessageDigest = H;
            }
        }
    };
    var w = function(G, F) {
        if (h(G, 0, [
            0
        ], "06") !== "2a864886f70d010702") return F;
        F.cmsType = "signedData";
        F.econtent = h(G, 0, [
            1,
            0,
            2,
            1,
            0
        ]);
        g(G, F);
        F.signerInfos = [];
        l(G, F);
    };
    var o = function(J, F) {
        var G = F.parse.signerInfos;
        var L = G.length;
        var K = true;
        for(var I = 0; I < L; I++){
            var H = G[I];
            e(J, F, H, I);
            if (!H.isValid) K = false;
        }
        F.isValid = K;
    };
    var x = function(F, Q, J, P) {
        var N = Q.parse.certsIdx;
        var H;
        if (Q.certs === undefined) {
            H = [];
            Q.certkeys = [];
            var K = z(F, N);
            for(var I = 0; I < K.length; I++){
                var M = c(F, K[I]);
                var O = new X509();
                O.readCertHex(M);
                H[I] = O;
                Q.certkeys[I] = O.getPublicKey();
            }
            Q.certs = H;
        } else H = Q.certs;
        Q.cccc = H.length;
        Q.cccci = K.length;
        for(var I = 0; I < H.length; I++){
            var L = O.getIssuerHex();
            var G = O.getSerialNumberHex();
            if (J.signerid_issuer1 === L && J.signerid_serial1 === G) J.certkey_idx = I;
        }
    };
    var e = function(F, R, I, N) {
        I.verifyDetail = {};
        var Q = I.verifyDetail;
        var K = R.parse.econtent;
        var G = I.hashalg;
        var L = I.saMessageDigest;
        Q.validMessageDigest = false;
        if (j(K, G) === L) Q.validMessageDigest = true;
        x(F, R, I, N);
        Q.validSignatureValue = false;
        var H = I.sigalg;
        var M = "31" + c(F, I.idxSignedAttrs).substr(2);
        I.signedattrshex = M;
        var J = R.certs[I.certkey_idx].getPublicKey();
        var P = new KJUR.crypto.Signature({
            alg: H
        });
        P.init(J);
        P.updateHex(M);
        var O = P.verify(I.sigval);
        Q.validSignatureValue_isValid = O;
        if (O === true) Q.validSignatureValue = true;
        I.isValid = false;
        if (Q.validMessageDigest && Q.validSignatureValue) I.isValid = true;
    };
    var m = function() {};
    var r = {
        isValid: false,
        parse: {}
    };
    w(E, r.parse);
    o(E, r);
    return r;
};
KJUR.asn1.cms.CMSParser = function() {
    var g = Error, a = X509, h = new a(), l = ASN1HEX, i = l.getV, b = l.getTLV, f = l.getIdxbyList, c = l.getTLVbyList, d = l.getTLVbyListEx, e = l.getVbyList, k = l.getVbyListEx, j = l.getChildIdx;
    this.getCMSSignedData = function(m) {
        var o = c(m, 0, [
            1,
            0
        ]);
        var n = this.getSignedData(o);
        return n;
    };
    this.getSignedData = function(o) {
        var q = j(o, 0);
        var v = {};
        var p = i(o, q[0]);
        var n = parseInt(p, 16);
        v.version = n;
        var r = b(o, q[1]);
        v.hashalgs = this.getHashAlgArray(r);
        var t = b(o, q[2]);
        v.econtent = this.getEContent(t);
        var m = d(o, 0, [
            "[0]"
        ]);
        if (m != null) v.certs = this.getCertificateSet(m);
        var u = d(o, 0, [
            "[1]"
        ]);
        u;
        var s = d(o, 0, [
            3
        ]);
        v.sinfos = this.getSignerInfos(s);
        return v;
    };
    this.getHashAlgArray = function(s) {
        var q = j(s, 0);
        var m = new a();
        var n = [];
        for(var r = 0; r < q.length; r++){
            var p = b(s, q[r]);
            var o = m.getAlgorithmIdentifierName(p);
            n.push(o);
        }
        return n;
    };
    this.getEContent = function(m) {
        var n = {};
        var p = e(m, 0, [
            0
        ]);
        var o = e(m, 0, [
            1,
            0
        ]);
        n.type = KJUR.asn1.x509.OID.oid2name(ASN1HEX.hextooidstr(p));
        n.content = {
            hex: o
        };
        return n;
    };
    this.getSignerInfos = function(p) {
        var r = [];
        var m = j(p, 0);
        for(var n = 0; n < m.length; n++){
            var o = b(p, m[n]);
            var q = this.getSignerInfo(o);
            r.push(q);
        }
        return r;
    };
    this.getSignerInfo = function(s) {
        var y = {};
        var u = j(s, 0);
        var q = l.getInt(s, u[0], -1);
        if (q != -1) y.version = q;
        var t = b(s, u[1]);
        var p = this.getIssuerAndSerialNumber(t);
        y.id = p;
        var z = b(s, u[2]);
        var n = h.getAlgorithmIdentifierName(z);
        y.hashalg = n;
        var w = d(s, 0, [
            "[0]"
        ]);
        if (w != null) {
            var A = this.getAttributeList(w);
            y.sattrs = A;
        }
        var m = d(s, 0, [
            3
        ]);
        var x = h.getAlgorithmIdentifierName(m);
        y.sigalg = x;
        var o = k(s, 0, [
            4
        ]);
        y.sighex = o;
        var r = d(s, 0, [
            "[1]"
        ]);
        if (r != null) {
            var v = this.getAttributeList(r);
            y.uattrs = v;
        }
        return y;
    };
    this.getSignerIdentifier = function(m) {
        if (m.substr(0, 2) == "30") return this.getIssuerAndSerialNumber(m);
        else throw new Error("SKID of signerIdentifier not supported");
    };
    this.getIssuerAndSerialNumber = function(n) {
        var o = {
            type: "isssn"
        };
        var m = j(n, 0);
        var p = b(n, m[0]);
        o.issuer = h.getX500Name(p);
        var q = i(n, m[1]);
        o.serial = {
            hex: q
        };
        return o;
    };
    this.getAttributeList = function(q) {
        var m = [];
        var n = j(q, 0);
        for(var o = 0; o < n.length; o++){
            var p = b(q, n[o]);
            var r = this.getAttribute(p);
            m.push(r);
        }
        return {
            array: m
        };
    };
    this.getAttribute = function(p) {
        var t = {};
        var q = j(p, 0);
        var o = l.getOID(p, q[0]);
        var m = KJUR.asn1.x509.OID.oid2name(o);
        t.attr = m;
        var r = b(p, q[1]);
        var u = j(r, 0);
        if (u.length == 1) t.valhex = b(r, u[0]);
        else {
            var s = [];
            for(var n = 0; n < u.length; n++)s.push(b(r, u[n]));
            t.valhex = s;
        }
        if (m == "contentType") this.setContentType(t);
        else if (m == "messageDigest") this.setMessageDigest(t);
        else {
            if (m == "signingTime") this.setSigningTime(t);
            else if (m == "signingCertificate") this.setSigningCertificate(t);
            else {
                if (m == "signingCertificateV2") this.setSigningCertificateV2(t);
                else if (m == "signaturePolicyIdentifier") this.setSignaturePolicyIdentifier(t);
            }
        }
        return t;
    };
    this.setContentType = function(m) {
        var n = l.getOIDName(m.valhex, 0, null);
        if (n != null) {
            m.type = n;
            delete m.valhex;
        }
    };
    this.setSigningTime = function(o) {
        var n = i(o.valhex, 0);
        var m = hextoutf8(n);
        o.str = m;
        delete o.valhex;
    };
    this.setMessageDigest = function(m) {
        var n = i(m.valhex, 0);
        m.hex = n;
        delete m.valhex;
    };
    this.setSigningCertificate = function(n) {
        var q = j(n.valhex, 0);
        if (q.length > 0) {
            var m = b(n.valhex, q[0]);
            var p = j(m, 0);
            var t = [];
            for(var o = 0; o < p.length; o++){
                var s = b(m, p[o]);
                var u = this.getESSCertID(s);
                t.push(u);
            }
            n.array = t;
        }
        if (q.length > 1) {
            var r = b(n.valhex, q[1]);
            n.polhex = r;
        }
        delete n.valhex;
    };
    this.setSignaturePolicyIdentifier = function(s) {
        var q = j(s.valhex, 0);
        if (q.length > 0) {
            var r = l.getOID(s.valhex, q[0]);
            s.oid = r;
        }
        if (q.length > 1) {
            var m = new a();
            var t = j(s.valhex, q[1]);
            var p = b(s.valhex, t[0]);
            var o = m.getAlgorithmIdentifierName(p);
            s.alg = o;
            var n = i(s.valhex, t[1]);
            s.hash = n;
        }
        delete s.valhex;
    };
    this.setSigningCertificateV2 = function(o) {
        var s = j(o.valhex, 0);
        if (s.length > 0) {
            var n = b(o.valhex, s[0]);
            var r = j(n, 0);
            var u = [];
            for(var q = 0; q < r.length; q++){
                var m = b(n, r[q]);
                var p = this.getESSCertIDv2(m);
                u.push(p);
            }
            o.array = u;
        }
        if (s.length > 1) {
            var t = b(o.valhex, s[1]);
            o.polhex = t;
        }
        delete o.valhex;
    };
    this.getESSCertID = function(o) {
        var p = {};
        var n = j(o, 0);
        if (n.length > 0) {
            var q = i(o, n[0]);
            p.hash = q;
        }
        if (n.length > 1) {
            var m = b(o, n[1]);
            var r = this.getIssuerSerial(m);
            if (r.serial != undefined) p.serial = r.serial;
            if (r.issuer != undefined) p.issuer = r.issuer;
        }
        return p;
    };
    this.getESSCertIDv2 = function(q) {
        var s = {};
        var p = j(q, 0);
        if (p.length < 1 || 3 < p.length) throw new g("wrong number of elements");
        var r = 0;
        if (q.substr(p[0], 2) == "30") {
            var o = b(q, p[0]);
            s.alg = h.getAlgorithmIdentifierName(o);
            r++;
        } else s.alg = "sha256";
        var n = i(q, p[r]);
        s.hash = n;
        if (p.length > r + 1) {
            var m = b(q, p[r + 1]);
            var t = this.getIssuerSerial(m);
            s.issuer = t.issuer;
            s.serial = t.serial;
        }
        return s;
    };
    this.getIssuerSerial = function(q) {
        var r = {};
        var n = j(q, 0);
        var m = b(q, n[0]);
        var p = h.getGeneralNames(m);
        var o = p[0].dn;
        r.issuer = o;
        var s = i(q, n[1]);
        r.serial = {
            hex: s
        };
        return r;
    };
    this.getCertificateSet = function(p) {
        var n = j(p, 0);
        var m = [];
        for(var o = 0; o < n.length; o++){
            var r = b(p, n[o]);
            if (r.substr(0, 2) == "30") {
                var q = hextopem(r, "CERTIFICATE");
                m.push(q);
            }
        }
        return {
            array: m,
            sortflag: false
        };
    };
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};
if (typeof KJUR.asn1.tsp == "undefined" || !KJUR.asn1.tsp) KJUR.asn1.tsp = {};
KJUR.asn1.tsp.TimeStampToken = function(d) {
    var c = KJUR, b = c.asn1, a = b.tsp;
    a.TimeStampToken.superclass.constructor.call(this);
    this.params = null;
    this.getEncodedHexPrepare = function() {
        var e = new a.TSTInfo(this.params.econtent.content);
        this.params.econtent.content.hex = e.tohex();
    };
    if (d != undefined) this.setByParam(d);
};
extendClass(KJUR.asn1.tsp.TimeStampToken, KJUR.asn1.cms.SignedData);
KJUR.asn1.tsp.TSTInfo = function(f) {
    var m = Error, c = KJUR, j = c.asn1, g = j.DERSequence, i = j.DERInteger, l = j.DERBoolean, h = j.DERGeneralizedTime, n = j.DERObjectIdentifier, e = j.DERTaggedObject, k = j.tsp, d = k.MessageImprint, b = k.Accuracy, a = j.x509.X500Name, o = j.x509.GeneralName;
    k.TSTInfo.superclass.constructor.call(this);
    this.dVersion = new i({
        "int": 1
    });
    this.dPolicy = null;
    this.dMessageImprint = null;
    this.dSerial = null;
    this.dGenTime = null;
    this.dAccuracy = null;
    this.dOrdering = null;
    this.dNonce = null;
    this.dTsa = null;
    this.tohex = function() {
        var p = [
            this.dVersion
        ];
        if (this.dPolicy == null) throw new Error("policy shall be specified.");
        p.push(this.dPolicy);
        if (this.dMessageImprint == null) throw new Error("messageImprint shall be specified.");
        p.push(this.dMessageImprint);
        if (this.dSerial == null) throw new Error("serialNumber shall be specified.");
        p.push(this.dSerial);
        if (this.dGenTime == null) throw new Error("genTime shall be specified.");
        p.push(this.dGenTime);
        if (this.dAccuracy != null) p.push(this.dAccuracy);
        if (this.dOrdering != null) p.push(this.dOrdering);
        if (this.dNonce != null) p.push(this.dNonce);
        if (this.dTsa != null) p.push(this.dTsa);
        var q = new g({
            array: p
        });
        this.hTLV = q.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f !== undefined) {
        if (typeof f.policy == "string") {
            if (!f.policy.match(/^[0-9.]+$/)) throw "policy shall be oid like 0.1.4.134";
            this.dPolicy = new n({
                oid: f.policy
            });
        }
        if (f.messageImprint !== undefined) this.dMessageImprint = new d(f.messageImprint);
        if (f.serial !== undefined) this.dSerial = new i(f.serial);
        if (f.genTime !== undefined) this.dGenTime = new h(f.genTime);
        if (f.accuracy !== undefined) this.dAccuracy = new b(f.accuracy);
        if (f.ordering !== undefined && f.ordering == true) this.dOrdering = new l();
        if (f.nonce !== undefined) this.dNonce = new i(f.nonce);
        if (f.tsa !== undefined) this.dTsa = new e({
            tag: "a0",
            explicit: true,
            obj: new o({
                dn: f.tsa
            })
        });
    }
};
extendClass(KJUR.asn1.tsp.TSTInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.Accuracy = function(d) {
    var c = KJUR, b = c.asn1, a = b.ASN1Util.newObject;
    b.tsp.Accuracy.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var f = this.params;
        var e = [];
        if (f.seconds != undefined && typeof f.seconds == "number") e.push({
            "int": f.seconds
        });
        if (f.millis != undefined && typeof f.millis == "number") e.push({
            tag: {
                tagi: "80",
                obj: {
                    "int": f.millis
                }
            }
        });
        if (f.micros != undefined && typeof f.micros == "number") e.push({
            tag: {
                tagi: "81",
                obj: {
                    "int": f.micros
                }
            }
        });
        return a({
            seq: e
        }).tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (d != undefined) this.setByParam(d);
};
extendClass(KJUR.asn1.tsp.Accuracy, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.MessageImprint = function(g) {
    var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.DEROctetString, f = b.x509, e = f.AlgorithmIdentifier;
    b.tsp.MessageImprint.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var k = this.params;
        var j = new e({
            name: k.alg
        });
        var h = new d({
            hex: k.hash
        });
        var i = new a({
            array: [
                j,
                h
            ]
        });
        return i.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g !== undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.tsp.MessageImprint, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.TimeStampReq = function(c) {
    var a = KJUR, f = a.asn1, d = f.DERSequence, e = f.DERInteger, h = f.DERBoolean, j = f.ASN1Object, i = f.DERObjectIdentifier, g = f.tsp, b = g.MessageImprint;
    g.TimeStampReq.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var m = this.params;
        var k = [];
        k.push(new e({
            "int": 1
        }));
        if (m.messageImprint instanceof KJUR.asn1.ASN1Object) k.push(m.messageImprint);
        else k.push(new b(m.messageImprint));
        if (m.policy != undefined) k.push(new i(m.policy));
        if (m.nonce != undefined) k.push(new e(m.nonce));
        if (m.certreq == true) k.push(new h());
        var l = new d({
            array: k
        });
        return l.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (c != undefined) this.setByParam(c);
};
extendClass(KJUR.asn1.tsp.TimeStampReq, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.TimeStampResp = function(g) {
    var e = KJUR, d = e.asn1, c = d.DERSequence, f = d.ASN1Object, a = d.tsp, b = a.PKIStatusInfo;
    a.TimeStampResp.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var j = this.params;
        var h = [];
        if (j.econtent != undefined || j.tst != undefined) {
            if (j.statusinfo != undefined) h.push(new b(j.statusinfo));
            else h.push(new b("granted"));
            if (j.econtent != undefined) h.push(new a.TimeStampToken(j).getContentInfo());
            else {
                if (j.tst instanceof d.ASN1Object) h.push(j.tst);
                else throw new Error("improper member tst value");
            }
        } else {
            if (j.statusinfo != undefined) h.push(new b(j.statusinfo));
            else throw new Error("parameter for token nor statusinfo not specified");
        }
        var i = new c({
            array: h
        });
        return i.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.tsp.TimeStampResp, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIStatusInfo = function(d) {
    var h = Error, a = KJUR, g = a.asn1, e = g.DERSequence, i = g.tsp, f = i.PKIStatus, c = i.PKIFreeText, b = i.PKIFailureInfo;
    i.PKIStatusInfo.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var l = this.params;
        var j = [];
        if (typeof l == "string") j.push(new f(l));
        else {
            if (l.status == undefined) throw new h("property 'status' unspecified");
            j.push(new f(l.status));
            if (l.statusstr != undefined) j.push(new c(l.statusstr));
            if (l.failinfo != undefined) j.push(new b(l.failinfo));
        }
        var k = new e({
            array: j
        });
        return k.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (d != undefined) this.setByParam(d);
};
extendClass(KJUR.asn1.tsp.PKIStatusInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIStatus = function(g) {
    var e = Error, d = KJUR, c = d.asn1, f = c.DERInteger, b = c.tsp;
    b.PKIStatus.superclass.constructor.call(this);
    var a = {
        granted: 0,
        grantedWithMods: 1,
        rejection: 2,
        waiting: 3,
        revocationWarning: 4,
        revocationNotification: 5
    };
    this.params = null;
    this.tohex = function() {
        var k = this.params;
        var h, j;
        if (typeof k == "string") try {
            j = a[k];
        } catch (i) {
            throw new e("undefined name: " + k);
        }
        else {
            if (typeof k == "number") j = k;
            else throw new e("unsupported params");
        }
        return new f({
            "int": j
        }).tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.tsp.PKIStatus, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIFreeText = function(g) {
    var f = Error, e = KJUR, d = e.asn1, b = d.DERSequence, c = d.DERUTF8String, a = d.tsp;
    a.PKIFreeText.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var l = this.params;
        if (!l instanceof Array) throw new f("wrong params: not array");
        var h = [];
        for(var k = 0; k < l.length; k++)h.push(new c({
            str: l[k]
        }));
        var j = new b({
            array: h
        });
        return j.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.tsp.PKIFreeText, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIFailureInfo = function(h) {
    var f = Error, e = KJUR, d = e.asn1, g = d.DERBitString, b = d.tsp, c = b.PKIFailureInfo;
    var a = {
        badAlg: 0,
        badRequest: 2,
        badDataFormat: 5,
        timeNotAvailable: 14,
        unacceptedPolicy: 15,
        unacceptedExtension: 16,
        addInfoNotAvailable: 17,
        systemFailure: 25
    };
    c.superclass.constructor.call(this);
    this.params = null;
    this.getBinValue = function() {
        var n = this.params;
        var m = 0;
        if (typeof n == "number" && 0 <= n && n <= 25) {
            m |= 1 << n;
            var k = m.toString(2);
            var l = "";
            for(var j = k.length - 1; j >= 0; j--)l += k[j];
            return l;
        } else {
            if (typeof n == "string" && a[n] != undefined) return namearraytobinstr([
                n
            ], a);
            else {
                if (typeof n == "object" && n.length != undefined) return namearraytobinstr(n, a);
                else throw new f("wrong params");
            }
        }
        return;
    };
    this.tohex = function() {
        var j = this.params;
        var i = this.getBinValue();
        return new g({
            bin: i
        }).tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (h != undefined) this.setByParam(h);
};
extendClass(KJUR.asn1.tsp.PKIFailureInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.AbstractTSAAdapter = function(a) {
    this.getTSTHex = function(c, b) {
        throw "not implemented yet";
    };
};
KJUR.asn1.tsp.SimpleTSAAdapter = function(e) {
    var d = KJUR, c = d.asn1, a = c.tsp, b = d.crypto.Util.hashHex;
    a.SimpleTSAAdapter.superclass.constructor.call(this);
    this.params = null;
    this.serial = 0;
    this.getTSTHex = function(g, f) {
        var i = b(g, f);
        this.params.econtent.content.messageImprint = {
            alg: f,
            hash: i
        };
        this.params.econtent.content.serial = {
            "int": this.serial++
        };
        var h = Math.floor(Math.random() * 1000000000);
        this.params.econtent.content.nonce = {
            "int": h
        };
        var j = new a.TimeStampToken(this.params);
        return j.getContentInfoEncodedHex();
    };
    if (e !== undefined) this.params = e;
};
extendClass(KJUR.asn1.tsp.SimpleTSAAdapter, KJUR.asn1.tsp.AbstractTSAAdapter);
KJUR.asn1.tsp.FixedTSAAdapter = function(e) {
    var d = KJUR, c = d.asn1, a = c.tsp, b = d.crypto.Util.hashHex;
    a.FixedTSAAdapter.superclass.constructor.call(this);
    this.params = null;
    this.getTSTHex = function(g, f) {
        var h = b(g, f);
        this.params.econtent.content.messageImprint = {
            alg: f,
            hash: h
        };
        var i = new a.TimeStampToken(this.params);
        return i.getContentInfoEncodedHex();
    };
    if (e !== undefined) this.params = e;
};
extendClass(KJUR.asn1.tsp.FixedTSAAdapter, KJUR.asn1.tsp.AbstractTSAAdapter);
KJUR.asn1.tsp.TSPUtil = new function() {};
KJUR.asn1.tsp.TSPUtil.newTimeStampToken = function(a) {
    return new KJUR.asn1.tsp.TimeStampToken(a);
};
KJUR.asn1.tsp.TSPUtil.parseTimeStampReq = function(a) {
    var b = new KJUR.asn1.tsp.TSPParser();
    return b.getTimeStampReq(a);
};
KJUR.asn1.tsp.TSPUtil.parseMessageImprint = function(a) {
    var b = new KJUR.asn1.tsp.TSPParser();
    return b.getMessageImprint(a);
};
KJUR.asn1.tsp.TSPParser = function() {
    var e = Error, a = X509, f = new a(), k = ASN1HEX, g = k.getV, b = k.getTLV, d = k.getIdxbyList, c = k.getTLVbyListEx, i = k.getChildIdx;
    var j = [
        "granted",
        "grantedWithMods",
        "rejection",
        "waiting",
        "revocationWarning",
        "revocationNotification"
    ];
    var h = {
        0: "badAlg",
        2: "badRequest",
        5: "badDataFormat",
        14: "timeNotAvailable",
        15: "unacceptedPolicy",
        16: "unacceptedExtension",
        17: "addInfoNotAvailable",
        25: "systemFailure"
    };
    this.getResponse = function(n) {
        var l = i(n, 0);
        if (l.length == 1) return this.getPKIStatusInfo(b(n, l[0]));
        else if (l.length > 1) {
            var o = this.getPKIStatusInfo(b(n, l[0]));
            var m = b(n, l[1]);
            var p = this.getToken(m);
            p.statusinfo = o;
            return p;
        }
    };
    this.getToken = function(m) {
        var l = new KJUR.asn1.cms.CMSParser;
        var n = l.getCMSSignedData(m);
        this.setTSTInfo(n);
        return n;
    };
    this.setTSTInfo = function(l) {
        var o = l.econtent;
        if (o.type == "tstinfo") {
            var n = o.content.hex;
            var m = this.getTSTInfo(n);
            o.content = m;
        }
    };
    this.getTSTInfo = function(r) {
        var x = {};
        var s = i(r, 0);
        var p = g(r, s[1]);
        x.policy = hextooid(p);
        var o = b(r, s[2]);
        x.messageImprint = this.getMessageImprint(o);
        var u = g(r, s[3]);
        x.serial = {
            hex: u
        };
        var y = g(r, s[4]);
        x.genTime = {
            str: hextoutf8(y)
        };
        var q = 0;
        if (s.length > 5 && r.substr(s[5], 2) == "30") {
            var v = b(r, s[5]);
            x.accuracy = this.getAccuracy(v);
            q++;
        }
        if (s.length > 5 + q && r.substr(s[5 + q], 2) == "01") {
            var z = g(r, s[5 + q]);
            if (z == "ff") x.ordering = true;
            q++;
        }
        if (s.length > 5 + q && r.substr(s[5 + q], 2) == "02") {
            var n = g(r, s[5 + q]);
            x.nonce = {
                hex: n
            };
            q++;
        }
        if (s.length > 5 + q && r.substr(s[5 + q], 2) == "a0") {
            var m = b(r, s[5 + q]);
            m = "30" + m.substr(2);
            pGeneralNames = f.getGeneralNames(m);
            var t = pGeneralNames[0].dn;
            x.tsa = t;
            q++;
        }
        if (s.length > 5 + q && r.substr(s[5 + q], 2) == "a1") {
            var l = b(r, s[5 + q]);
            l = "30" + l.substr(2);
            var w = f.getExtParamArray(l);
            x.ext = w;
            q++;
        }
        return x;
    };
    this.getAccuracy = function(q) {
        var r = {};
        var o = i(q, 0);
        for(var p = 0; p < o.length; p++){
            var m = q.substr(o[p], 2);
            var l = g(q, o[p]);
            var n = parseInt(l, 16);
            if (m == "02") r.seconds = n;
            else {
                if (m == "80") r.millis = n;
                else if (m == "81") r.micros = n;
            }
        }
        return r;
    };
    this.getMessageImprint = function(n) {
        if (n.substr(0, 2) != "30") throw new Error("head of messageImprint hex shall be x30");
        var s = {};
        var l = i(n, 0);
        var t = d(n, 0, [
            0,
            0
        ]);
        var o = g(n, t);
        var p = k.hextooidstr(o);
        var r = KJUR.asn1.x509.OID.oid2name(p);
        if (r == "") throw new Error("hashAlg name undefined: " + p);
        var m = r;
        var q = d(n, 0, [
            1
        ]);
        s.alg = m;
        s.hash = g(n, q);
        return s;
    };
    this.getPKIStatusInfo = function(o) {
        var t = {};
        var r = i(o, 0);
        var n = 0;
        try {
            var l = g(o, r[0]);
            var p = parseInt(l, 16);
            t.status = j[p];
        } catch (s) {}
        if (r.length > 1 && o.substr(r[1], 2) == "30") {
            var m = b(o, r[1]);
            t.statusstr = this.getPKIFreeText(m);
            n++;
        }
        if (r.length > n && o.substr(r[1 + n], 2) == "03") {
            var q = b(o, r[1 + n]);
            t.failinfo = this.getPKIFailureInfo(q);
        }
        return t;
    };
    this.getPKIFreeText = function(n) {
        var o = [];
        var l = i(n, 0);
        for(var m = 0; m < l.length; m++)o.push(k.getString(n, l[m]));
        return o;
    };
    this.getPKIFailureInfo = function(l) {
        var m = k.getInt(l, 0);
        if (h[m] != undefined) return h[m];
        else return m;
    };
    this.getTimeStampReq = function(q) {
        var p = {};
        p.certreq = false;
        var s = i(q, 0);
        if (s.length < 2) throw new Error("TimeStampReq must have at least 2 items");
        var n = b(q, s[1]);
        p.messageImprint = KJUR.asn1.tsp.TSPUtil.parseMessageImprint(n);
        for(var o = 2; o < s.length; o++){
            var m = s[o];
            var l = q.substr(m, 2);
            if (l == "06") {
                var r = g(q, m);
                p.policy = k.hextooidstr(r);
            }
            if (l == "02") p.nonce = g(q, m);
            if (l == "01") p.certreq = true;
        }
        return p;
    };
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};
if (typeof KJUR.asn1.cades == "undefined" || !KJUR.asn1.cades) KJUR.asn1.cades = {};
KJUR.asn1.cades.SignaturePolicyIdentifier = function(e) {
    var c = KJUR, b = c.asn1, a = b.cades, d = a.SignaturePolicyId;
    a.SignaturePolicyIdentifier.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.15";
    this.params = null;
    this.getValueArray = function() {
        return [
            new d(this.params)
        ];
    };
    this.setByParam = function(f) {
        this.params = f;
    };
    if (e != undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.cades.SignaturePolicyIdentifier, KJUR.asn1.cms.Attribute);
KJUR.asn1.cades.SignaturePolicyId = function(e) {
    var a = KJUR, g = a.asn1, f = g.DERSequence, i = g.DERObjectIdentifier, d = g.x509, j = d.AlgorithmIdentifier, c = g.cades, h = c.SignaturePolicyId, b = c.OtherHashAlgAndValue;
    h.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var m = this.params;
        var k = [];
        k.push(new i(m.oid));
        k.push(new b(m));
        var l = new f({
            array: k
        });
        return l.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(k) {
        this.params = k;
    };
    if (e != undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.cades.SignaturePolicyId, KJUR.asn1.ASN1Object);
KJUR.asn1.cades.OtherHashAlgAndValue = function(e) {
    var h = Error, a = KJUR, g = a.asn1, f = g.DERSequence, i = g.DEROctetString, d = g.x509, j = d.AlgorithmIdentifier, c = g.cades, b = c.OtherHashAlgAndValue;
    b.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var o = this.params;
        if (o.alg == undefined) throw new h("property 'alg' not specified");
        if (o.hash == undefined && o.cert == undefined) throw new h("property 'hash' nor 'cert' not specified");
        var m = null;
        if (o.hash != undefined) m = o.hash;
        else if (o.cert != undefined) {
            if (typeof o.cert != "string") throw new h("cert not string");
            var n = o.cert;
            if (o.cert.indexOf("-----BEGIN") != -1) n = pemtohex(o.cert);
            m = KJUR.crypto.Util.hashHex(n, o.alg);
        }
        var k = [];
        k.push(new j({
            name: o.alg
        }));
        k.push(new i({
            hex: m
        }));
        var l = new f({
            array: k
        });
        return l.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e != undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.cades.OtherHashAlgAndValue, KJUR.asn1.ASN1Object);
KJUR.asn1.cades.OtherHashValue = function(g) {
    KJUR.asn1.cades.OtherHashValue.superclass.constructor.call(this);
    var d = Error, c = KJUR, f = c.lang.String.isHex, b = c.asn1, e = b.DEROctetString, a = c.crypto.Util.hashHex;
    this.params = null;
    this.tohex = function() {
        var j = this.params;
        if (j.hash == undefined && j.cert == undefined) throw new d("hash or cert not specified");
        var h = null;
        if (j.hash != undefined) h = j.hash;
        else if (j.cert != undefined) {
            if (typeof j.cert != "string") throw new d("cert not string");
            var i = j.cert;
            if (j.cert.indexOf("-----BEGIN") != -1) i = pemtohex(j.cert);
            h = KJUR.crypto.Util.hashHex(i, "sha1");
        }
        return new e({
            hex: h
        }).tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.cades.OtherHashValue, KJUR.asn1.ASN1Object);
KJUR.asn1.cades.SignatureTimeStamp = function(h) {
    var d = Error, c = KJUR, f = c.lang.String.isHex, b = c.asn1, e = b.ASN1Object, g = b.x509, a = b.cades;
    a.SignatureTimeStamp.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.14";
    this.params = null;
    this.getValueArray = function() {
        var l = this.params;
        if (l.tst != undefined) {
            if (f(l.tst)) {
                var j = new e();
                j.hTLV = l.tst;
                return [
                    j
                ];
            } else {
                if (l.tst instanceof e) return [
                    l.tst
                ];
                else throw new d("params.tst has wrong value");
            }
        } else if (l.res != undefined) {
            var k = l.res;
            if (k instanceof e) k = k.tohex();
            if (typeof k != "string" || !f(k)) throw new d("params.res has wrong value");
            var i = ASN1HEX.getTLVbyList(k, 0, [
                1
            ]);
            var j = new e();
            j.hTLV = l.tst;
            return [
                j
            ];
        }
    };
    if (h != null) this.setByParam(h);
};
extendClass(KJUR.asn1.cades.SignatureTimeStamp, KJUR.asn1.cms.Attribute);
KJUR.asn1.cades.CompleteCertificateRefs = function(h) {
    var f = Error, e = KJUR, d = e.asn1, b = d.DERSequence, c = d.cades, a = c.OtherCertID, g = e.lang.String.isHex;
    c.CompleteCertificateRefs.superclass.constructor.call(this);
    this.typeOid = "1.2.840.113549.1.9.16.2.21";
    this.params = null;
    this.getValueArray = function() {
        var o = this.params;
        var k = [];
        for(var m = 0; m < o.array.length; m++){
            var n = o.array[m];
            if (typeof n == "string") {
                if (n.indexOf("-----BEGIN") != -1) n = {
                    cert: n
                };
                else {
                    if (g(n)) n = {
                        hash: n
                    };
                    else throw new f("unsupported value: " + n);
                }
            }
            if (o.alg != undefined && n.alg == undefined) n.alg = o.alg;
            if (o.hasis != undefined && n.hasis == undefined) n.hasis = o.hasis;
            var j = new a(n);
            k.push(j);
        }
        var l = new b({
            array: k
        });
        return [
            l
        ];
    };
    if (h != undefined) this.setByParam(h);
};
extendClass(KJUR.asn1.cades.CompleteCertificateRefs, KJUR.asn1.cms.Attribute);
KJUR.asn1.cades.OtherCertID = function(e) {
    var a = KJUR, h = a.asn1, f = h.DERSequence, i = h.cms, g = i.IssuerSerial, c = h.cades, d = c.OtherHashValue, b = c.OtherHashAlgAndValue;
    c.OtherCertID.superclass.constructor.call(this);
    this.params = e;
    this.tohex = function() {
        var n = this.params;
        if (typeof n == "string") {
            if (n.indexOf("-----BEGIN") != -1) n = {
                cert: n
            };
            else if (_isHex(n)) n = {
                hash: n
            };
        }
        var j = [];
        var m = null;
        if (n.alg != undefined) m = new b(n);
        else m = new d(n);
        j.push(m);
        if (n.cert != undefined && n.hasis == true || n.issuer != undefined && n.serial != undefined) {
            var l = new g(n);
            j.push(l);
        }
        var k = new f({
            array: j
        });
        return k.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e != undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.cades.OtherCertID, KJUR.asn1.ASN1Object);
KJUR.asn1.cades.OtherHash = function(g) {
    var i = Error, a = KJUR, h = a.asn1, j = h.cms, c = h.cades, b = c.OtherHashAlgAndValue, e = c.OtherHashValue, d = a.crypto.Util.hashHex, f = a.lang.String.isHex;
    c.OtherHash.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var l = this.params;
        if (typeof l == "string") {
            if (l.indexOf("-----BEGIN") != -1) l = {
                cert: l
            };
            else if (f(l)) l = {
                hash: l
            };
        }
        var k = null;
        if (l.alg != undefined) k = new b(l);
        else k = new e(l);
        return k.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g != undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.cades.OtherHash, KJUR.asn1.ASN1Object);
KJUR.asn1.cades.CAdESUtil = new function() {};
KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned = function(a) {
    var c = new KJUR.asn1.cms.CMSParser();
    var b = c.getCMSSignedData(a);
    return b;
};
KJUR.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned = function(g, q, c) {
    var p = ASN1HEX, s = p.getChildIdx, a = p.getTLV, l = p.getV, v = KJUR, h = v.asn1, n = h.ASN1Object, j = h.cms, k = j.AttributeList, w = j.SignerInfo;
    var o = {};
    var t = s(g, q);
    if (t.length != 6) throw "not supported items for SignerInfo (!=6)";
    var d = t.shift();
    o.version = a(g, d);
    var e = t.shift();
    o.si = a(g, e);
    var m = t.shift();
    o.digalg = a(g, m);
    var f = t.shift();
    o.sattrs = a(g, f);
    var i = t.shift();
    o.sigalg = a(g, i);
    var b = t.shift();
    o.sig = a(g, b);
    o.sigval = l(g, b);
    var u = null;
    o.obj = new w();
    u = new n();
    u.hTLV = o.version;
    o.obj.dCMSVersion = u;
    u = new n();
    u.hTLV = o.si;
    o.obj.dSignerIdentifier = u;
    u = new n();
    u.hTLV = o.digalg;
    o.obj.dDigestAlgorithm = u;
    u = new n();
    u.hTLV = o.sattrs;
    o.obj.dSignedAttrs = u;
    u = new n();
    u.hTLV = o.sigalg;
    o.obj.dSigAlg = u;
    u = new n();
    u.hTLV = o.sig;
    o.obj.dSig = u;
    o.obj.dUnsignedAttrs = new k();
    return o;
};
if (typeof KJUR.asn1.csr == "undefined" || !KJUR.asn1.csr) KJUR.asn1.csr = {};
KJUR.asn1.csr.CertificationRequest = function(g) {
    var d = KJUR, c = d.asn1, e = c.DERBitString, b = c.DERSequence, a = c.csr, f = c.x509, h = a.CertificationRequestInfo;
    a.CertificationRequest.superclass.constructor.call(this);
    this.setByParam = function(i) {
        this.params = i;
    };
    this.sign = function() {
        var j = new h(this.params).tohex();
        var k = new KJUR.crypto.Signature({
            alg: this.params.sigalg
        });
        k.init(this.params.sbjprvkey);
        k.updateHex(j);
        var i = k.sign();
        this.params.sighex = i;
    };
    this.getPEM = function() {
        return hextopem(this.tohex(), "CERTIFICATE REQUEST");
    };
    this.tohex = function() {
        var l = this.params;
        var j = new KJUR.asn1.csr.CertificationRequestInfo(this.params);
        var m = new KJUR.asn1.x509.AlgorithmIdentifier({
            name: l.sigalg
        });
        if (l.sighex == undefined && l.sbjprvkey != undefined) this.sign();
        if (l.sighex == undefined) throw new Error("sighex or sbjprvkey parameter not defined");
        var k = new e({
            hex: "00" + l.sighex
        });
        var i = new b({
            array: [
                j,
                m,
                k
            ]
        });
        return i.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (g !== undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.csr.CertificationRequest, KJUR.asn1.ASN1Object);
KJUR.asn1.csr.CertificationRequestInfo = function(f) {
    var b = KJUR, j = b.asn1, c = j.DERBitString, g = j.DERSequence, i = j.DERInteger, p = j.DERUTF8String, d = j.DERTaggedObject, h = j.ASN1Util.newObject, n = j.csr, e = j.x509, a = e.X500Name, l = e.Extensions, o = e.SubjectPublicKeyInfo, k = n.AttributeList;
    n.CertificationRequestInfo.superclass.constructor.call(this);
    this.params = null;
    this.setByParam = function(q) {
        if (q != undefined) this.params = q;
    };
    this.tohex = function() {
        var v = this.params;
        var r = [];
        r.push(new i({
            "int": 0
        }));
        r.push(new a(v.subject));
        r.push(new o(KEYUTIL.getKey(v.sbjpubkey)));
        if (v.attrs != undefined) {
            var u = m(v.attrs);
            var t = h({
                tag: {
                    tage: "a0",
                    obj: u
                }
            });
            r.push(t);
        } else if (v.extreq != undefined) {
            var q = new l(v.extreq);
            var t = h({
                tag: {
                    tage: "a0",
                    obj: {
                        seq: [
                            {
                                oid: "1.2.840.113549.1.9.14"
                            },
                            {
                                set: [
                                    q
                                ]
                            }
                        ]
                    }
                }
            });
            r.push(t);
        } else r.push(new d({
            tag: "a0",
            explicit: false,
            obj: new p({
                str: ""
            })
        }));
        var s = new g({
            array: r
        });
        return s.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    function m(s) {
        var w = Error, v = KJUR.asn1.x509.Extensions;
        var y = [];
        for(var u = 0; u < s.length; u++){
            var r = s[u];
            var x = r.attr;
            if (x == "extensionRequest") {
                var t = new v(r.ext);
                var q = {
                    seq: [
                        {
                            oid: "1.2.840.113549.1.9.14"
                        },
                        {
                            set: [
                                t
                            ]
                        }
                    ]
                };
                y.push(q);
            } else if (x == "unstructuredName") {
                var q = {
                    seq: [
                        {
                            oid: "1.2.840.113549.1.9.2"
                        },
                        {
                            set: r.names
                        }
                    ]
                };
                y.push(q);
            } else {
                if (x == "challengePassword") {
                    var q = {
                        seq: [
                            {
                                oid: "1.2.840.113549.1.9.7"
                            },
                            {
                                set: [
                                    {
                                        utf8str: r.password
                                    }
                                ]
                            }
                        ]
                    };
                    y.push(q);
                } else throw new w("unknown CSR attribute");
            }
        }
        return {
            set: y
        };
    }
    if (f != undefined) this.setByParam(f);
};
extendClass(KJUR.asn1.csr.CertificationRequestInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.csr.AttributeList = function(b) {
    function a(c) {}
};
extendClass(KJUR.asn1.csr.AttributeList, KJUR.asn1.ASN1Object);
KJUR.asn1.csr.CSRUtil = new function() {};
KJUR.asn1.csr.CSRUtil.newCSRPEM = function(e) {
    var b = KEYUTIL, a = KJUR.asn1.csr;
    var c = new a.CertificationRequest(e);
    var d = c.getPEM();
    return d;
};
KJUR.asn1.csr.CSRUtil.getParam = function(d, a) {
    var m = ASN1HEX, i = m.getV, j = m.getIdxbyList, b = m.getTLVbyList, o = m.getTLVbyListEx, n = m.getVbyListEx;
    var l = function(u) {
        var t = j(u, 0, [
            0,
            3,
            0,
            0
        ], "06");
        if (i(u, t) != "2a864886f70d01090e") return null;
        return b(u, 0, [
            0,
            3,
            0,
            1,
            0
        ], "30");
    };
    var g = {};
    if (d.indexOf("-----BEGIN CERTIFICATE REQUEST") == -1) throw new Error("argument is not PEM file");
    var e = pemtohex(d, "CERTIFICATE REQUEST");
    if (a) g.tbs = b(e, 0, [
        0
    ]);
    try {
        var p = o(e, 0, [
            0,
            1
        ]);
        if (p == "3000") g.subject = {};
        else {
            var f = new X509();
            g.subject = f.getX500Name(p);
        }
    } catch (q) {}
    var k = o(e, 0, [
        0,
        2
    ]);
    var r = KEYUTIL.getKey(k, null, "pkcs8pub");
    g.sbjpubkey = KEYUTIL.getPEM(r, "PKCS8PUB");
    var c = l(e);
    var f = new X509();
    if (c != null) g.extreq = f.getExtParamArray(c);
    try {
        var h = o(e, 0, [
            1
        ], "30");
        var f = new X509();
        g.sigalg = f.getAlgorithmIdentifierName(h);
    } catch (q) {}
    try {
        var s = n(e, 0, [
            2
        ]);
        g.sighex = s;
    } catch (q) {}
    return g;
};
KJUR.asn1.csr.CSRUtil.verifySignature = function(b) {
    try {
        var c = null;
        if (typeof b == "string" && b.indexOf("-----BEGIN CERTIFICATE REQUEST") != -1) c = KJUR.asn1.csr.CSRUtil.getParam(b, true);
        else if (typeof b == "object" && b.sbjpubkey != undefined && b.sigalg != undefined && b.sighex != undefined && b.tbs != undefined) c = b;
        if (c == null) return false;
        var d = new KJUR.crypto.Signature({
            alg: c.sigalg
        });
        d.init(c.sbjpubkey);
        d.updateHex(c.tbs);
        return d.verify(c.sighex);
    } catch (a) {
        alert(a);
        return false;
    }
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};
if (typeof KJUR.asn1.ocsp == "undefined" || !KJUR.asn1.ocsp) KJUR.asn1.ocsp = {};
KJUR.asn1.ocsp.DEFAULT_HASH = "sha1";
KJUR.asn1.ocsp.OCSPResponse = function(e) {
    KJUR.asn1.ocsp.OCSPResponse.superclass.constructor.call(this);
    var a = KJUR.asn1.DEREnumerated, b = KJUR.asn1.ASN1Util.newObject, c = KJUR.asn1.ocsp.ResponseBytes;
    var d = [
        "successful",
        "malformedRequest",
        "internalError",
        "tryLater",
        "_not_used_",
        "sigRequired",
        "unauthorized"
    ];
    this.params = null;
    this._getStatusCode = function() {
        var f = this.params.resstatus;
        if (typeof f == "number") return f;
        if (typeof f != "string") return -1;
        return d.indexOf(f);
    };
    this.setByParam = function(f) {
        this.params = f;
    };
    this.tohex = function() {
        var h = this.params;
        var g = this._getStatusCode();
        if (g == -1) throw new Error("responseStatus not supported: " + h.resstatus);
        if (g != 0) return b({
            seq: [
                {
                    "enum": {
                        "int": g
                    }
                }
            ]
        }).tohex();
        var f = new c(h);
        return b({
            seq: [
                {
                    "enum": {
                        "int": 0
                    }
                },
                {
                    tag: {
                        tag: "a0",
                        explicit: true,
                        obj: f
                    }
                }
            ]
        }).tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.ocsp.OCSPResponse, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.ResponseBytes = function(e) {
    KJUR.asn1.ocsp.ResponseBytes.superclass.constructor.call(this);
    var b = KJUR.asn1, a = b.DERSequence, f = b.DERObjectIdentifier, c = b.DEROctetString, d = b.ocsp.BasicOCSPResponse;
    this.params = null;
    this.setByParam = function(g) {
        this.params = g;
    };
    this.tohex = function() {
        var j = this.params;
        if (j.restype != "ocspBasic") throw new Error("not supported responseType: " + j.restype);
        var i = new d(j);
        var g = [];
        g.push(new f({
            name: "ocspBasic"
        }));
        g.push(new c({
            hex: i.tohex()
        }));
        var h = new a({
            array: g
        });
        return h.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.ocsp.ResponseBytes, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.BasicOCSPResponse = function(d) {
    KJUR.asn1.ocsp.BasicOCSPResponse.superclass.constructor.call(this);
    var i = Error, g = KJUR.asn1, j = g.ASN1Object, e = g.DERSequence, f = g.DERGeneralizedTime, c = g.DERTaggedObject, b = g.DERBitString, h = g.x509.Extensions, k = g.x509.AlgorithmIdentifier, l = g.ocsp, a = l.ResponderID;
    _SingleResponseList = l.SingleResponseList, _ResponseData = l.ResponseData;
    this.params = null;
    this.setByParam = function(m) {
        this.params = m;
    };
    this.sign = function() {
        var o = this.params;
        var m = o.tbsresp.tohex();
        var n = new KJUR.crypto.Signature({
            alg: o.sigalg
        });
        n.init(o.reskey);
        n.updateHex(m);
        o.sighex = n.sign();
    };
    this.tohex = function() {
        var t = this.params;
        if (t.tbsresp == undefined) t.tbsresp = new _ResponseData(t);
        if (t.sighex == undefined && t.reskey != undefined) this.sign();
        var n = [];
        n.push(t.tbsresp);
        n.push(new k({
            name: t.sigalg
        }));
        n.push(new b({
            hex: "00" + t.sighex
        }));
        if (t.certs != undefined && t.certs.length != undefined) {
            var m = [];
            for(var q = 0; q < t.certs.length; q++){
                var s = t.certs[q];
                var r = null;
                if (ASN1HEX.isASN1HEX(s)) r = s;
                else {
                    if (s.match(/-----BEGIN/)) r = pemtohex(s);
                    else throw new i("certs[" + q + "] not hex or PEM");
                }
                m.push(new j({
                    tlv: r
                }));
            }
            var p = new e({
                array: m
            });
            n.push(new c({
                tag: "a0",
                explicit: true,
                obj: p
            }));
        }
        var o = new e({
            array: n
        });
        return o.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (d !== undefined) this.setByParam(d);
};
extendClass(KJUR.asn1.ocsp.BasicOCSPResponse, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.ResponseData = function(c) {
    KJUR.asn1.ocsp.ResponseData.superclass.constructor.call(this);
    var h = Error, f = KJUR.asn1, d = f.DERSequence, e = f.DERGeneralizedTime, b = f.DERTaggedObject, g = f.x509.Extensions, i = f.ocsp, a = i.ResponderID;
    _SingleResponseList = i.SingleResponseList;
    this.params = null;
    this.tohex = function() {
        var m = this.params;
        if (m.respid != undefined) new h("respid not specified");
        if (m.prodat != undefined) new h("prodat not specified");
        if (m.array != undefined) new h("array not specified");
        var j = [];
        j.push(new a(m.respid));
        j.push(new e(m.prodat));
        j.push(new _SingleResponseList(m.array));
        if (m.ext != undefined) {
            var l = new g(m.ext);
            j.push(new b({
                tag: "a1",
                explicit: true,
                obj: l
            }));
        }
        var k = new d({
            array: j
        });
        return k.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(j) {
        this.params = j;
    };
    if (c !== undefined) this.setByParam(c);
};
extendClass(KJUR.asn1.ocsp.ResponseData, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.ResponderID = function(g) {
    KJUR.asn1.ocsp.ResponderID.superclass.constructor.call(this);
    var d = KJUR, c = d.asn1, b = c.ASN1Util.newObject, f = c.x509.X500Name, e = d.lang.String.isHex, a = Error;
    this.params = null;
    this.tohex = function() {
        var m = this.params;
        if (m.key != undefined) {
            var l = null;
            if (typeof m.key == "string") {
                if (e(m.key)) l = m.key;
                if (m.key.match(/-----BEGIN CERTIFICATE/)) {
                    var h = new X509(m.key);
                    var k = h.getExtSubjectKeyIdentifier();
                    if (k != null) l = k.kid.hex;
                }
            } else if (m.key instanceof X509) {
                var k = m.key.getExtSubjectKeyIdentifier();
                if (k != null) l = k.kid.hex;
            }
            if (l == null) throw new a("wrong key member value");
            var j = b({
                tag: {
                    tag: "a2",
                    explicit: true,
                    obj: {
                        octstr: {
                            hex: l
                        }
                    }
                }
            });
            return j.tohex();
        } else if (m.name != undefined) {
            var i = null;
            if (typeof m.name == "string" && m.name.match(/-----BEGIN CERTIFICATE/)) {
                var h = new X509(m.name);
                i = h.getSubject();
            } else {
                if (m.name instanceof X509) i = m.name.getSubject();
                else if (typeof m.name == "object" && (m.name.array != undefined || m.name.str != undefined)) i = m.name;
            }
            if (i == null) throw new a("wrong name member value");
            var j = b({
                tag: {
                    tag: "a1",
                    explicit: true,
                    obj: new f(i)
                }
            });
            return j.tohex();
        }
        throw new a("key or name not specified");
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(h) {
        this.params = h;
    };
    if (g !== undefined) this.setByParam(g);
};
extendClass(KJUR.asn1.ocsp.ResponderID, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.SingleResponseList = function(d) {
    KJUR.asn1.ocsp.SingleResponseList.superclass.constructor.call(this);
    var c = KJUR.asn1, b = c.DERSequence, a = c.ocsp.SingleResponse;
    this.params = null;
    this.tohex = function() {
        var h = this.params;
        if (typeof h != "object" || h.length == undefined) throw new Error("params not specified properly");
        var e = [];
        for(var g = 0; g < h.length; g++)e.push(new a(h[g]));
        var f = new b({
            array: e
        });
        return f.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(e) {
        this.params = e;
    };
    if (d !== undefined) this.setByParam(d);
};
extendClass(KJUR.asn1.ocsp.SingleResponseList, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.SingleResponse = function(e) {
    var k = Error, a = KJUR, i = a.asn1, f = i.DERSequence, g = i.DERGeneralizedTime, b = i.DERTaggedObject, l = i.ocsp, h = l.CertID, c = l.CertStatus, d = i.x509, j = d.Extensions;
    l.SingleResponse.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var q = this.params;
        var n = [];
        if (q.certid == undefined) throw new k("certid unspecified");
        if (q.status == undefined) throw new k("status unspecified");
        if (q.thisupdate == undefined) throw new k("thisupdate unspecified");
        n.push(new h(q.certid));
        n.push(new c(q.status));
        n.push(new g(q.thisupdate));
        if (q.nextupdate != undefined) {
            var m = new g(q.nextupdate);
            n.push(new b({
                tag: "a0",
                explicit: true,
                obj: m
            }));
        }
        if (q.ext != undefined) {
            var p = new j(q.ext);
            n.push(new b({
                tag: "a1",
                explicit: true,
                obj: p
            }));
        }
        var o = new f({
            array: n
        });
        return o.tohex();
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(m) {
        this.params = m;
    };
    if (e !== undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.ocsp.SingleResponse, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.CertID = function(e) {
    var b = KJUR, i = b.asn1, l = i.DEROctetString, h = i.DERInteger, f = i.DERSequence, d = i.x509, m = d.AlgorithmIdentifier, n = i.ocsp, k = n.DEFAULT_HASH, g = b.crypto, c = g.Util.hashHex, a = X509, o = ASN1HEX, j = o.getVbyList;
    n.CertID.superclass.constructor.call(this);
    this.DEFAULT_HASH = "sha1";
    this.params = null;
    this.setByValue = function(s, r, p, q) {
        if (q == undefined) q = this.DEFAULT_HASH;
        this.params = {
            alg: q,
            issname: s,
            isskey: r,
            sbjsn: p
        };
    };
    this.setByCert = function(p, q, r) {
        if (r == undefined) r = this.DEFAULT_HASH;
        this.params = {
            alg: r,
            issuerCert: p,
            subjectCert: q
        };
    };
    this.getParamByCerts = function(y, x, t) {
        if (t == undefined) t = this.DEFAULT_HASH;
        var q = new a(y);
        var v = new a(x);
        var s = c(q.getSubjectHex(), t);
        var u = q.getPublicKeyHex();
        var p = c(j(u, 0, [
            1
        ], "03", true), t);
        var w = v.getSerialNumberHex();
        var r = {
            alg: t,
            issname: s,
            isskey: p,
            sbjsn: w
        };
        return r;
    };
    this.tohex = function() {
        if (typeof this.params != "object") throw new Error("params not set");
        var s = this.params;
        var u, r, y, q;
        if (s.alg == undefined) q = this.DEFAULT_HASH;
        else q = s.alg;
        if (s.issuerCert != undefined && s.subjectCert != undefined) {
            var t = this.getParamByCerts(s.issuerCert, s.subjectCert, q);
            u = t.issname;
            r = t.isskey;
            y = t.sbjsn;
        } else {
            if (s.issname != undefined && s.isskey != undefined && s.sbjsn != undefined) {
                u = s.issname;
                r = s.isskey;
                y = s.sbjsn;
            } else throw new Error("required param members not defined");
        }
        var A = new m({
            name: q
        });
        var v = new l({
            hex: u
        });
        var x = new l({
            hex: r
        });
        var w = new h({
            hex: y
        });
        var z = new f({
            array: [
                A,
                v,
                x,
                w
            ]
        });
        this.hTLV = z.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) this.setByParam(e);
};
extendClass(KJUR.asn1.ocsp.CertID, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.CertStatus = function(a) {
    KJUR.asn1.ocsp.CertStatus.superclass.constructor.call(this);
    this.params = null;
    this.tohex = function() {
        var d = this.params;
        if (d.status == "good") return "8000";
        if (d.status == "unknown") return "8200";
        if (d.status == "revoked") {
            var c = [
                {
                    gentime: {
                        str: d.time
                    }
                }
            ];
            if (d.reason != undefined) c.push({
                tag: {
                    tag: "a0",
                    explicit: true,
                    obj: {
                        "enum": {
                            "int": d.reason
                        }
                    }
                }
            });
            var b = {
                tag: "a1",
                explicit: false,
                obj: {
                    seq: c
                }
            };
            return KJUR.asn1.ASN1Util.newObject({
                tag: b
            }).tohex();
        }
        throw new Error("bad status");
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    this.setByParam = function(b) {
        this.params = b;
    };
    if (a !== undefined) this.setByParam(a);
};
extendClass(KJUR.asn1.ocsp.CertStatus, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.Request = function(f) {
    var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
    d.Request.superclass.constructor.call(this);
    this.dReqCert = null;
    this.dExt = null;
    this.tohex = function() {
        var g = [];
        if (this.dReqCert === null) throw "reqCert not set";
        g.push(this.dReqCert);
        var h = new a({
            array: g
        });
        this.hTLV = h.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (typeof f !== "undefined") {
        var e = new d.CertID(f);
        this.dReqCert = e;
    }
};
extendClass(KJUR.asn1.ocsp.Request, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.TBSRequest = function(e) {
    var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
    d.TBSRequest.superclass.constructor.call(this);
    this.version = 0;
    this.dRequestorName = null;
    this.dRequestList = [];
    this.dRequestExt = null;
    this.setRequestListByParam = function(h) {
        var f = [];
        for(var g = 0; g < h.length; g++){
            var j = new d.Request(h[0]);
            f.push(j);
        }
        this.dRequestList = f;
    };
    this.tohex = function() {
        var f = [];
        if (this.version !== 0) throw "not supported version: " + this.version;
        if (this.dRequestorName !== null) throw "requestorName not supported";
        var h = new a({
            array: this.dRequestList
        });
        f.push(h);
        if (this.dRequestExt !== null) throw "requestExtensions not supported";
        var g = new a({
            array: f
        });
        this.hTLV = g.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (e !== undefined) {
        if (e.reqList !== undefined) this.setRequestListByParam(e.reqList);
    }
};
extendClass(KJUR.asn1.ocsp.TBSRequest, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.OCSPRequest = function(f) {
    var c = KJUR, b = c.asn1, a = b.DERSequence, d = b.ocsp;
    d.OCSPRequest.superclass.constructor.call(this);
    this.dTbsRequest = null;
    this.dOptionalSignature = null;
    this.tohex = function() {
        var g = [];
        if (this.dTbsRequest !== null) g.push(this.dTbsRequest);
        else throw "tbsRequest not set";
        if (this.dOptionalSignature !== null) throw "optionalSignature not supported";
        var h = new a({
            array: g
        });
        this.hTLV = h.tohex();
        return this.hTLV;
    };
    this.getEncodedHex = function() {
        return this.tohex();
    };
    if (f !== undefined) {
        if (f.reqList !== undefined) {
            var e = new d.TBSRequest(f);
            this.dTbsRequest = e;
        }
    }
};
extendClass(KJUR.asn1.ocsp.OCSPRequest, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.OCSPUtil = {};
KJUR.asn1.ocsp.OCSPUtil.getRequestHex = function(a, b, h) {
    var d = KJUR, c = d.asn1, e = c.ocsp;
    if (h === undefined) h = e.DEFAULT_HASH;
    var g = {
        alg: h,
        issuerCert: a,
        subjectCert: b
    };
    var f = new e.OCSPRequest({
        reqList: [
            g
        ]
    });
    return f.tohex();
};
KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo = function(b) {
    var m = ASN1HEX, c = m.getVbyList, k = m.getVbyListEx, e = m.getIdxbyList, d = m.getIdxbyListEx, g = m.getV;
    var n = {};
    try {
        var j = k(b, 0, [
            0
        ], "0a");
        n.responseStatus = parseInt(j, 16);
    } catch (f) {}
    if (n.responseStatus !== 0) return n;
    try {
        var i = e(b, 0, [
            1,
            0,
            1,
            0,
            0,
            2,
            0,
            1
        ]);
        if (b.substr(i, 2) === "80") n.certStatus = "good";
        else {
            if (b.substr(i, 2) === "a1") {
                n.certStatus = "revoked";
                n.revocationTime = hextoutf8(c(b, i, [
                    0
                ]));
            } else if (b.substr(i, 2) === "82") n.certStatus = "unknown";
        }
    } catch (f) {}
    try {
        var a = e(b, 0, [
            1,
            0,
            1,
            0,
            0,
            2,
            0,
            2
        ]);
        n.thisUpdate = hextoutf8(g(b, a));
    } catch (f) {}
    try {
        var l = e(b, 0, [
            1,
            0,
            1,
            0,
            0,
            2,
            0,
            3
        ]);
        if (b.substr(l, 2) === "a0") n.nextUpdate = hextoutf8(c(b, l, [
            0
        ]));
    } catch (f) {}
    return n;
};
KJUR.asn1.ocsp.OCSPParser = function() {
    var g = Error, a = X509, h = new a(), l = ASN1HEX, i = l.getV, b = l.getTLV, f = l.getIdxbyList, e = l.getVbyList, c = l.getTLVbyList, k = l.getVbyListEx, d = l.getTLVbyListEx, j = l.getChildIdx;
    this.getOCSPRequest = function(o) {
        var n = j(o, 0);
        if (n.length != 1 && n.length != 2) throw new g("wrong number elements: " + n.length);
        var m = this.getTBSRequest(b(o, n[0]));
        return m;
    };
    this.getTBSRequest = function(o) {
        var m = {};
        var n = d(o, 0, [
            0
        ], "30");
        m.array = this.getRequestList(n);
        var p = d(o, 0, [
            "[2]",
            0
        ], "30");
        if (p != null) m.ext = h.getExtParamArray(p);
        return m;
    };
    this.getRequestList = function(p) {
        var m = [];
        var n = j(p, 0);
        for(var o = 0; o < n.length; o++){
            var p = b(p, n[o]);
            m.push(this.getRequest(p));
        }
        return m;
    };
    this.getRequest = function(n) {
        var m = j(n, 0);
        if (m.length != 1 && m.length != 2) throw new g("wrong number elements: " + m.length);
        var p = this.getCertID(b(n, m[0]));
        if (m.length == 2) {
            var o = f(n, 0, [
                1,
                0
            ]);
            p.ext = h.getExtParamArray(b(n, o));
        }
        return p;
    };
    this.getCertID = function(p) {
        var o = j(p, 0);
        if (o.length != 4) throw new g("wrong number elements: " + o.length);
        var n = new a();
        var m = {};
        m.alg = n.getAlgorithmIdentifierName(b(p, o[0]));
        m.issname = i(p, o[1]);
        m.isskey = i(p, o[2]);
        m.sbjsn = i(p, o[3]);
        return m;
    };
    this.getOCSPResponse = function(r) {
        var o = j(r, 0);
        var m;
        var q = i(r, o[0]);
        var p = parseInt(q);
        if (o.length == 1) return {
            resstatus: p
        };
        var n = c(r, 0, [
            1,
            0
        ]);
        m = this.getResponseBytes(n);
        m.resstatus = p;
        return m;
    };
    this.getResponseBytes = function(p) {
        var o = j(p, 0);
        var n;
        var q = c(p, 0, [
            1,
            0
        ]);
        n = this.getBasicOCSPResponse(q);
        var m = i(p, o[0]);
        n.restype = KJUR.asn1.x509.OID.oid2name(hextooid(m));
        return n;
    };
    this.getBasicOCSPResponse = function(q) {
        var t = j(q, 0);
        var v;
        v = this.getResponseData(b(q, t[0]));
        var u = new X509();
        v.alg = u.getAlgorithmIdentifierName(b(q, t[1]));
        var n = i(q, t[2]);
        v.sighex = n.substr(2);
        var m = k(q, 0, [
            "[0]"
        ]);
        if (m != null) {
            var r = j(m, 0);
            var o = [];
            for(var p = 0; p < r.length; p++){
                var s = b(m, r[p]);
                o.push(s);
            }
            v.certs = o;
        }
        return v;
    };
    this.getResponseData = function(q) {
        var p = j(q, 0);
        var r = p.length;
        var o = {};
        var n = 0;
        if (q.substr(p[0], 2) == "a0") n++;
        o.respid = this.getResponderID(b(q, p[n++]));
        var t = i(q, p[n++]);
        o.prodat = hextoutf8(t);
        o.array = this.getSingleResponseList(b(q, p[n++]));
        if (q.substr(p[r - 1], 2) == "a1") {
            var s = c(q, p[r - 1], [
                0
            ]);
            var m = new X509();
            o.ext = m.getExtParamArray(s);
        }
        return o;
    };
    this.getResponderID = function(o) {
        var n = {};
        if (o.substr(0, 2) == "a2") {
            var p = e(o, 0, [
                0
            ]);
            n.key = p;
        }
        if (o.substr(0, 2) == "a1") {
            var q = c(o, 0, [
                0
            ]);
            var m = new X509();
            n.name = m.getX500Name(q);
        }
        return n;
    };
    this.getSingleResponseList = function(q) {
        var n = j(q, 0);
        var m = [];
        for(var o = 0; o < n.length; o++){
            var r = this.getSingleResponse(b(q, n[o]));
            m.push(r);
        }
        return m;
    };
    this.getSingleResponse = function(p) {
        var t = j(p, 0);
        var v = {};
        var r = this.getCertID(b(p, t[0]));
        v.certid = r;
        var u = this.getCertStatus(b(p, t[1]));
        v.status = u;
        if (p.substr(t[2], 2) == "18") {
            var q = i(p, t[2]);
            v.thisupdate = hextoutf8(q);
        }
        for(var o = 3; o < t.length; o++){
            if (p.substr(t[o], 2) == "a0") {
                var m = e(p, t[o], [
                    0
                ], "18");
                v.nextupdate = hextoutf8(m);
            }
            if (p.substr(t[o], 2) == "a1") {
                var s = new X509();
                var n = c(p, 0, [
                    o,
                    0
                ]);
                v.ext = s.getExtParamArray(n);
            }
        }
        return v;
    };
    this.getCertStatus = function(p) {
        var m = {};
        if (p == "8000") return {
            status: "good"
        };
        if (p == "8200") return {
            status: "unknown"
        };
        if (p.substr(0, 2) == "a1") {
            m.status = "revoked";
            var o = e(p, 0, [
                0
            ]);
            var n = hextoutf8(o);
            m.time = n;
        }
        return m;
    };
};
var KJUR;
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.lang == "undefined" || !KJUR.lang) KJUR.lang = {};
KJUR.lang.String = function() {};
function Base64x() {}
function stoBA(d) {
    var b = new Array();
    for(var c = 0; c < d.length; c++)b[c] = d.charCodeAt(c);
    return b;
}
function BAtos(b) {
    var d = "";
    for(var c = 0; c < b.length; c++)d = d + String.fromCharCode(b[c]);
    return d;
}
function BAtohex(b) {
    var e = "";
    for(var d = 0; d < b.length; d++){
        var c = b[d].toString(16);
        if (c.length == 1) c = "0" + c;
        e = e + c;
    }
    return e;
}
function stohex(a) {
    return BAtohex(stoBA(a));
}
function stob64(a) {
    return hex2b64(stohex(a));
}
function stob64u(a) {
    return b64tob64u(hex2b64(stohex(a)));
}
function b64utos(a) {
    return BAtos(b64toBA(b64utob64(a)));
}
function b64tob64u(a) {
    a = a.replace(/\=/g, "");
    a = a.replace(/\+/g, "-");
    a = a.replace(/\//g, "_");
    return a;
}
function b64utob64(a) {
    if (a.length % 4 == 2) a = a + "==";
    else if (a.length % 4 == 3) a = a + "=";
    a = a.replace(/-/g, "+");
    a = a.replace(/_/g, "/");
    return a;
}
function hextob64u(a) {
    if (a.length % 2 == 1) a = "0" + a;
    return b64tob64u(hex2b64(a));
}
function b64utohex(a) {
    return b64tohex(b64utob64(a));
}
var utf8tob64u, b64utoutf8;
if (typeof Buffer === "function") {
    utf8tob64u = function(a) {
        return b64tob64u(Buffer.from(a, "utf8").toString("base64"));
    };
    b64utoutf8 = function(a) {
        return Buffer.from(b64utob64(a), "base64").toString("utf8");
    };
} else {
    utf8tob64u = function(a) {
        return hextob64u(uricmptohex(encodeURIComponentAll(a)));
    };
    b64utoutf8 = function(a) {
        return decodeURIComponent(hextouricmp(b64utohex(a)));
    };
}
function utf8tob64(a) {
    return hex2b64(uricmptohex(encodeURIComponentAll(a)));
}
function b64toutf8(a) {
    return decodeURIComponent(hextouricmp(b64tohex(a)));
}
function utf8tohex(a) {
    return uricmptohex(encodeURIComponentAll(a)).toLowerCase();
}
function hextoutf8(b) {
    try {
        return decodeURIComponent(hextouricmp(b));
    } catch (a) {
        return null;
    }
}
function iso88591hextoutf8(a) {
    return hextoutf8(iso88591hextoutf8hex(a));
}
function utf8toiso88591hex(a) {
    return utf8hextoiso88591hex(utf8tohex(a));
}
function iso88591hextoutf8hex(e) {
    var c = e.match(/.{1,2}/g);
    var b = [];
    for(var d = 0; d < c.length; d++){
        var f = parseInt(c[d], 16);
        if (161 <= f && f <= 191) {
            b.push("c2");
            b.push(c[d]);
        } else if (192 <= f && f <= 255) {
            b.push("c3");
            b.push((f - 64).toString(16));
        } else b.push(c[d]);
    }
    return b.join("");
}
function utf8hextoiso88591hex(f) {
    var c = f.match(/.{1,2}/g);
    var b = [];
    for(var e = 0; e < c.length; e++){
        if (c[e] == "c2") {
            e++;
            b.push(c[e]);
        } else if (c[e] == "c3") {
            e++;
            var d = c[e];
            var g = parseInt(c[e], 16) + 64;
            b.push(g.toString(16));
        } else b.push(c[e]);
    }
    return b.join("");
}
function hextorstr(c) {
    var b = "";
    for(var a = 0; a < c.length - 1; a += 2)b += String.fromCharCode(parseInt(c.substr(a, 2), 16));
    return b;
}
function rstrtohex(c) {
    var a = "";
    for(var b = 0; b < c.length; b++)a += ("0" + c.charCodeAt(b).toString(16)).slice(-2);
    return a;
}
function hextob64(a) {
    return hex2b64(a);
}
function hextob64nl(a) {
    return foldnl(hextob64(a), 64);
}
function foldnl(a, b) {
    a = a.replace(new RegExp("(.{" + b + "})", "g"), "$1\r\n");
    a = a.replace(/\s+$/, "");
    return a;
}
function b64nltohex(b) {
    var a = b.replace(/[^0-9A-Za-z\/+=]*/g, "");
    var c = b64tohex(a);
    return c;
}
function b64topem(b, a) {
    return "-----BEGIN " + a + "-----\r\n" + foldnl(b, 64) + "\r\n-----END " + a + "-----\r\n";
}
function hextopem(a, b) {
    return "-----BEGIN " + b + "-----\r\n" + foldnl(hextob64(a), 64) + "\r\n-----END " + b + "-----\r\n";
}
function pemtohex(a, b) {
    if (a.indexOf("-----BEGIN ") == -1) throw new Error("can't find PEM header");
    if (b !== undefined) {
        a = a.replace(new RegExp("^[^]*-----BEGIN " + b + "-----"), "");
        a = a.replace(new RegExp("-----END " + b + "-----[^]*$"), "");
    } else {
        a = a.replace(/^[^]*-----BEGIN [^-]+-----/, "");
        a = a.replace(/-----END [^-]+-----[^]*$/, "");
    }
    return b64nltohex(a);
}
function pemtob64(a) {
    if (a.indexOf("-----BEGIN ") == -1 || a.indexOf("-----END ") == -1) return null;
    a = a.replace(/^[\s\S]*?-----BEGIN [^-]+-----/m, "");
    a = a.replace(/-----END [\s\S]+$/m, "");
    a = a.replace(/\s+/g, "");
    return a.match(/^[0-9a-zA-Z+/=]+$/) ? a : null;
}
function hextoArrayBuffer(d) {
    if (d.length % 2 != 0) throw "input is not even length";
    if (d.match(/^[0-9A-Fa-f]+$/) == null) throw "input is not hexadecimal";
    var b = new ArrayBuffer(d.length / 2);
    var a = new DataView(b);
    for(var c = 0; c < d.length / 2; c++)a.setUint8(c, parseInt(d.substr(c * 2, 2), 16));
    return b;
}
function ArrayBuffertohex(b) {
    var d = "";
    var a = new DataView(b);
    for(var c = 0; c < b.byteLength; c++)d += ("00" + a.getUint8(c).toString(16)).slice(-2);
    return d;
}
function zulutomsec(n) {
    var l, j, m, e, f, i, b, k;
    var a, h, g, c;
    n = timetogen(n);
    c = n.match(/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/);
    if (c) {
        l = parseInt(c[1]);
        j = parseInt(c[2]) - 1;
        m = parseInt(c[3]);
        e = parseInt(c[4]);
        f = parseInt(c[5]);
        i = parseInt(c[6]);
        b = 0;
        h = c[7];
        if (h !== "") {
            g = (h.substr(1) + "00").substr(0, 3);
            b = parseInt(g);
        }
        return Date.UTC(l, j, m, e, f, i, b);
    }
    throw new Error("unsupported zulu format: " + n);
}
function msectozulu(b) {
    var h = new Date(b), i = ("0000" + h.getUTCFullYear()).slice(-4), c = ("00" + (h.getUTCMonth() + 1)).slice(-2), j = ("00" + h.getUTCDate()).slice(-2), e = ("00" + h.getUTCHours()).slice(-2), f = ("00" + h.getUTCMinutes()).slice(-2), g = ("00" + h.getUTCSeconds()).slice(-2), a = ("000" + h.getUTCMilliseconds()).slice(-3);
    a = a.replace(/0+$/, "");
    a = a != "" ? "." + a : a;
    return i + c + j + e + f + g + a + "Z";
}
function zulutosec(a) {
    return Math.round(zulutomsec(a) / 1000);
}
function zulutodate(a) {
    return new Date(zulutomsec(a));
}
function datetozulu(g, e, f) {
    var b;
    var a = g.getUTCFullYear();
    if (e) {
        if (a < 1950 || 2049 < a) throw "not proper year for UTCTime: " + a;
        b = ("" + a).slice(-2);
    } else b = ("000" + a).slice(-4);
    b += ("0" + (g.getUTCMonth() + 1)).slice(-2);
    b += ("0" + g.getUTCDate()).slice(-2);
    b += ("0" + g.getUTCHours()).slice(-2);
    b += ("0" + g.getUTCMinutes()).slice(-2);
    b += ("0" + g.getUTCSeconds()).slice(-2);
    if (f) {
        var c = g.getUTCMilliseconds();
        if (c !== 0) {
            c = ("00" + c).slice(-3);
            c = c.replace(/0+$/g, "");
            b += "." + c;
        }
    }
    b += "Z";
    return b;
}
function timetogen(a) {
    if (a.match(/^[0-9]{12}Z$/) || a.match(/^[0-9]{12}[.][0-9]*Z$/)) return a.match(/^[0-4]/) ? "20" + a : "19" + a;
    return a;
}
function uricmptohex(a) {
    return a.replace(/%/g, "");
}
function hextouricmp(a) {
    return a.replace(/(..)/g, "%$1");
}
function ipv6tohex(g) {
    var b = "malformed IPv6 address";
    if (!g.match(/^[0-9A-Fa-f:]+$/)) throw b;
    g = g.toLowerCase();
    var d = g.split(":").length - 1;
    if (d < 2) throw b;
    var e = ":".repeat(7 - d + 2);
    g = g.replace("::", e);
    var c = g.split(":");
    if (c.length != 8) throw b;
    for(var f = 0; f < 8; f++)c[f] = ("0000" + c[f]).slice(-4);
    return c.join("");
}
function hextoipv6(d) {
    if (!d.match(/^[0-9A-Fa-f]{32}$/)) throw new Error("malformed IPv6 address: " + d);
    d = d.toLowerCase();
    var b = d.match(/.{1,4}/g);
    b = b.map(function(a) {
        return a.replace(/^0+/, "");
    });
    b = b.map(function(a) {
        return a == "" ? "0" : a;
    });
    d = ":" + b.join(":") + ":";
    var c = d.match(/:(0:){2,}/g);
    if (c == null) return d.slice(1, -1);
    var e = c.sort().slice(-1)[0];
    d = d.replace(e.substr(0, e.length - 1), ":");
    if (d.substr(0, 2) != "::") d = d.substr(1);
    if (d.substr(-2, 2) != "::") d = d.substr(0, d.length - 1);
    return d;
}
function hextoip(b) {
    var c = new Error("malformed hex value");
    if (!b.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) throw c;
    if (b.length == 8) {
        var d;
        try {
            d = parseInt(b.substr(0, 2), 16) + "." + parseInt(b.substr(2, 2), 16) + "." + parseInt(b.substr(4, 2), 16) + "." + parseInt(b.substr(6, 2), 16);
            return d;
        } catch (a) {
            throw c;
        }
    } else {
        if (b.length == 16) try {
            return hextoip(b.substr(0, 8)) + "/" + ipprefixlen(b.substr(8));
        } catch (a) {
            throw c;
        }
        else {
            if (b.length == 32) return hextoipv6(b);
            else {
                if (b.length == 64) {
                    try {
                        return hextoipv6(b.substr(0, 32)) + "/" + ipprefixlen(b.substr(32));
                    } catch (a) {
                        throw c;
                    }
                    return;
                } else return b;
            }
        }
    }
}
function ipprefixlen(c) {
    var d = new Error("malformed mask");
    var a;
    try {
        a = new BigInteger(c, 16).toString(2);
    } catch (b) {
        throw d;
    }
    if (!a.match(/^1*0*$/)) throw d;
    return a.replace(/0+$/, "").length;
}
function iptohex(g) {
    var j = new Error("malformed IP address");
    g = g.toLowerCase(g);
    if (!g.match(/^[0-9a-f.:/]+$/)) throw j;
    if (g.match(/^[0-9.]+$/)) {
        var b = g.split(".");
        if (b.length !== 4) throw j;
        var h = "";
        try {
            for(var f = 0; f < 4; f++){
                var k = parseInt(b[f]);
                h += ("0" + k.toString(16)).slice(-2);
            }
            return h;
        } catch (e) {
            throw j;
        }
    } else if (g.match(/^[0-9.]+\/[0-9]+$/)) {
        var c = g.split("/");
        return iptohex(c[0]) + ipnetmask(parseInt(c[1]), 32);
    } else {
        if (g.match(/^[0-9a-f:]+$/) && g.indexOf(":") !== -1) return ipv6tohex(g);
        else {
            if (g.match(/^[0-9a-f:]+\/[0-9]+$/) && g.indexOf(":") !== -1) {
                var c = g.split("/");
                return ipv6tohex(c[0]) + ipnetmask(parseInt(c[1]), 128);
            } else throw j;
        }
    }
}
function ipnetmask(d, c) {
    if (c == 32 && d == 0) return "00000000";
    if (c == 128 && d == 0) return "00000000000000000000000000000000";
    var a = Array(d + 1).join("1") + Array(c - d + 1).join("0");
    return new BigInteger(a, 2).toString(16);
}
function ucs2hextoutf8(d) {
    function e(f) {
        var h = parseInt(f.substr(0, 2), 16);
        var a = parseInt(f.substr(2), 16);
        if (h == 0 & a < 128) return String.fromCharCode(a);
        if (h < 8) {
            var j = 192 | (h & 7) << 3 | (a & 192) >> 6;
            var i = 128 | a & 63;
            return hextoutf8(j.toString(16) + i.toString(16));
        }
        var j = 224 | (h & 240) >> 4;
        var i = 128 | (h & 15) << 2 | (a & 192) >> 6;
        var g = 128 | a & 63;
        return hextoutf8(j.toString(16) + i.toString(16) + g.toString(16));
    }
    var c = d.match(/.{4}/g);
    var b = c.map(e);
    return b.join("");
}
function encodeURIComponentAll(a) {
    var d = encodeURIComponent(a);
    var b = "";
    for(var c = 0; c < d.length; c++)if (d[c] == "%") {
        b = b + d.substr(c, 3);
        c = c + 2;
    } else b = b + "%" + stohex(d[c]);
    return b;
}
function newline_toUnix(a) {
    a = a.replace(/\r\n/mg, "\n");
    return a;
}
function newline_toDos(a) {
    a = a.replace(/\r\n/mg, "\n");
    a = a.replace(/\n/mg, "\r\n");
    return a;
}
KJUR.lang.String.isInteger = function(a) {
    if (a.match(/^[0-9]+$/)) return true;
    else {
        if (a.match(/^-[0-9]+$/)) return true;
        else return false;
    }
};
KJUR.lang.String.isHex = function(a) {
    return ishex(a);
};
function ishex(a) {
    if (a.length % 2 == 0 && (a.match(/^[0-9a-f]+$/) || a.match(/^[0-9A-F]+$/))) return true;
    else return false;
}
KJUR.lang.String.isBase64 = function(a) {
    a = a.replace(/\s+/g, "");
    if (a.match(/^[0-9A-Za-z+\/]+={0,3}$/) && a.length % 4 == 0) return true;
    else return false;
};
KJUR.lang.String.isBase64URL = function(a) {
    if (a.match(/[+/=]/)) return false;
    a = b64utob64(a);
    return KJUR.lang.String.isBase64(a);
};
function isBase64URLDot(a) {
    if (a.match(/^[0-9A-Za-z-_.]+$/)) return true;
    return false;
}
KJUR.lang.String.isIntegerArray = function(a) {
    a = a.replace(/\s+/g, "");
    if (a.match(/^\[[0-9,]+\]$/)) return true;
    else return false;
};
KJUR.lang.String.isPrintable = function(a) {
    if (a.match(/^[0-9A-Za-z '()+,-./:=?]*$/) !== null) return true;
    return false;
};
KJUR.lang.String.isIA5 = function(a) {
    if (a.match(/^[\x20-\x21\x23-\x7f]*$/) !== null) return true;
    return false;
};
KJUR.lang.String.isMail = function(a) {
    if (a.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/) !== null) return true;
    return false;
};
function hextoposhex(a) {
    if (a.length % 2 == 1) return "0" + a;
    if (a.substr(0, 1) > "7") return "00" + a;
    return a;
}
function intarystrtohex(b) {
    b = b.replace(/^\s*\[\s*/, "");
    b = b.replace(/\s*\]\s*$/, "");
    b = b.replace(/\s*/g, "");
    try {
        var c = b.split(/,/).map(function(g, e, h) {
            var f = parseInt(g);
            if (f < 0 || 255 < f) throw "integer not in range 0-255";
            var d = ("00" + f.toString(16)).slice(-2);
            return d;
        }).join("");
        return c;
    } catch (a) {
        throw "malformed integer array string: " + a;
    }
}
var strdiffidx = function(c, a) {
    var d = c.length;
    if (c.length > a.length) d = a.length;
    for(var b = 0; b < d; b++){
        if (c.charCodeAt(b) != a.charCodeAt(b)) return b;
    }
    if (c.length != a.length) return d;
    return -1;
};
function oidtohex(g) {
    var f = function(a) {
        var l = a.toString(16);
        if (l.length == 1) l = "0" + l;
        return l;
    };
    var e = function(p) {
        var o = "";
        var l = parseInt(p, 10);
        var a = l.toString(2);
        var m = 7 - a.length % 7;
        if (m == 7) m = 0;
        var r = "";
        for(var n = 0; n < m; n++)r += "0";
        a = r + a;
        for(var n = 0; n < a.length - 1; n += 7){
            var q = a.substr(n, 7);
            if (n != a.length - 7) q = "1" + q;
            o += f(parseInt(q, 2));
        }
        return o;
    };
    try {
        if (!g.match(/^[0-9.]+$/)) return null;
        var j = "";
        var b = g.split(".");
        var k = parseInt(b[0], 10) * 40 + parseInt(b[1], 10);
        j += f(k);
        b.splice(0, 2);
        for(var d = 0; d < b.length; d++)j += e(b[d]);
        return j;
    } catch (c) {
        return null;
    }
}
function hextooid(g) {
    if (!ishex(g)) return null;
    try {
        var m = [];
        var p = g.substr(0, 2);
        var e = parseInt(p, 16);
        m[0] = new String(Math.floor(e / 40));
        m[1] = new String(e % 40);
        var n = g.substr(2);
        var l = [];
        for(var f = 0; f < n.length / 2; f++)l.push(parseInt(n.substr(f * 2, 2), 16));
        var k = [];
        var d = "";
        for(var f = 0; f < l.length; f++)if (l[f] & 128) d = d + strpad((l[f] & 127).toString(2), 7);
        else {
            d = d + strpad((l[f] & 127).toString(2), 7);
            k.push(new String(parseInt(d, 2)));
            d = "";
        }
        var o = m.join(".");
        if (k.length > 0) o = o + "." + k.join(".");
        return o;
    } catch (j) {
        return null;
    }
}
function inttohex(b) {
    var a = new BigInteger(String(b), 10);
    return twoscompl(a);
}
function twoscompl(b) {
    var g = b.toString(16);
    if (g.substr(0, 1) != "-") {
        if (g.length % 2 == 1) g = "0" + g;
        else if (!g.match(/^[0-7]/)) g = "00" + g;
        return g;
    }
    var a = g.substr(1);
    var f = a.length;
    if (f % 2 == 1) f += 1;
    else if (!g.match(/^[0-7]/)) f += 2;
    var j = "";
    for(var e = 0; e < f; e++)j += "f";
    var d = new BigInteger(j, 16);
    var c = d.xor(b).add(BigInteger.ONE);
    g = c.toString(16).replace(/^-/, "");
    return g;
}
var strpad = function(c, b, a) {
    if (a == undefined) a = "0";
    if (c.length >= b) return c;
    return new Array(b - c.length + 1).join(a) + c;
};
function bitstrtoint(e) {
    if (e.length % 2 != 0) return -1;
    e = e.toLowerCase();
    if (e.match(/^[0-9a-f]+$/) == null) return -1;
    try {
        var a = e.substr(0, 2);
        if (a == "00") return parseInt(e.substr(2), 16);
        var b = parseInt(a, 16);
        if (b > 7) return -1;
        var g = e.substr(2);
        var d = parseInt(g, 16).toString(2);
        if (d == "0") d = "00000000";
        d = d.slice(0, 0 - b);
        var f = parseInt(d, 2);
        if (f == NaN) return -1;
        return f;
    } catch (c) {
        return -1;
    }
}
function inttobitstr(e) {
    if (typeof e != "number") return null;
    if (e < 0) return null;
    var c = Number(e).toString(2);
    var b = 8 - c.length % 8;
    if (b == 8) b = 0;
    c = c + strpad("", b, "0");
    var d = parseInt(c, 2).toString(16);
    if (d.length % 2 == 1) d = "0" + d;
    var a = "0" + b;
    return a + d;
}
function bitstrtobinstr(g) {
    if (typeof g != "string") return null;
    if (g.length % 2 != 0) return null;
    if (!g.match(/^[0-9a-f]+$/)) return null;
    try {
        var c = parseInt(g.substr(0, 2), 16);
        if (c < 0 || 7 < c) return null;
        var j = g.substr(2);
        var f = "";
        for(var e = 0; e < j.length; e += 2){
            var b = j.substr(e, 2);
            var a = parseInt(b, 16).toString(2);
            a = ("0000000" + a).slice(-8);
            f += a;
        }
        return f.substr(0, f.length - c);
    } catch (d) {
        return null;
    }
}
function binstrtobitstr(b) {
    if (typeof b != "string") return null;
    if (b.match(/^[01]+$/) == null) return null;
    try {
        var c = parseInt(b, 2);
        return inttobitstr(c);
    } catch (a) {
        return null;
    }
}
function namearraytobinstr(e, g) {
    var f = 0;
    for(var a = 0; a < e.length; a++)f |= 1 << g[e[a]];
    var b = f.toString(2);
    var c = "";
    for(var a = b.length - 1; a >= 0; a--)c += b[a];
    return c;
}
function aryval(e, c, d) {
    if (typeof e != "object") return undefined;
    var c = String(c).split(".");
    for(var b = 0; b < c.length && e; b++){
        var a = c[b];
        if (a.match(/^[0-9]+$/)) a = parseInt(a);
        e = e[a];
    }
    return e || e === false ? e : d;
}
function extendClass(c, a) {
    var b = function() {};
    b.prototype = a.prototype;
    c.prototype = new b();
    c.prototype.constructor = c;
    c.superclass = a.prototype;
    if (a.prototype.constructor == Object.prototype.constructor) a.prototype.constructor = a;
}
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};
KJUR.crypto.Util = new function() {
    this.DIGESTINFOHEAD = {
        sha1: "3021300906052b0e03021a05000414",
        sha224: "302d300d06096086480165030402040500041c",
        sha256: "3031300d060960864801650304020105000420",
        sha384: "3041300d060960864801650304020205000430",
        sha512: "3051300d060960864801650304020305000440",
        md2: "3020300c06082a864886f70d020205000410",
        md5: "3020300c06082a864886f70d020505000410",
        ripemd160: "3021300906052b2403020105000414"
    };
    this.DEFAULTPROVIDER = {
        md5: "cryptojs",
        sha1: "cryptojs",
        sha224: "cryptojs",
        sha256: "cryptojs",
        sha384: "cryptojs",
        sha512: "cryptojs",
        ripemd160: "cryptojs",
        hmacmd5: "cryptojs",
        hmacsha1: "cryptojs",
        hmacsha224: "cryptojs",
        hmacsha256: "cryptojs",
        hmacsha384: "cryptojs",
        hmacsha512: "cryptojs",
        hmacripemd160: "cryptojs",
        MD5withRSA: "cryptojs/jsrsa",
        SHA1withRSA: "cryptojs/jsrsa",
        SHA224withRSA: "cryptojs/jsrsa",
        SHA256withRSA: "cryptojs/jsrsa",
        SHA384withRSA: "cryptojs/jsrsa",
        SHA512withRSA: "cryptojs/jsrsa",
        RIPEMD160withRSA: "cryptojs/jsrsa",
        MD5withECDSA: "cryptojs/jsrsa",
        SHA1withECDSA: "cryptojs/jsrsa",
        SHA224withECDSA: "cryptojs/jsrsa",
        SHA256withECDSA: "cryptojs/jsrsa",
        SHA384withECDSA: "cryptojs/jsrsa",
        SHA512withECDSA: "cryptojs/jsrsa",
        RIPEMD160withECDSA: "cryptojs/jsrsa",
        SHA1withDSA: "cryptojs/jsrsa",
        SHA224withDSA: "cryptojs/jsrsa",
        SHA256withDSA: "cryptojs/jsrsa",
        MD5withRSAandMGF1: "cryptojs/jsrsa",
        SHAwithRSAandMGF1: "cryptojs/jsrsa",
        SHA1withRSAandMGF1: "cryptojs/jsrsa",
        SHA224withRSAandMGF1: "cryptojs/jsrsa",
        SHA256withRSAandMGF1: "cryptojs/jsrsa",
        SHA384withRSAandMGF1: "cryptojs/jsrsa",
        SHA512withRSAandMGF1: "cryptojs/jsrsa",
        RIPEMD160withRSAandMGF1: "cryptojs/jsrsa"
    };
    this.CRYPTOJSMESSAGEDIGESTNAME = {
        md5: CryptoJS.algo.MD5,
        sha1: CryptoJS.algo.SHA1,
        sha224: CryptoJS.algo.SHA224,
        sha256: CryptoJS.algo.SHA256,
        sha384: CryptoJS.algo.SHA384,
        sha512: CryptoJS.algo.SHA512,
        ripemd160: CryptoJS.algo.RIPEMD160
    };
    this.getDigestInfoHex = function(a, b) {
        if (typeof this.DIGESTINFOHEAD[b] == "undefined") throw "alg not supported in Util.DIGESTINFOHEAD: " + b;
        return this.DIGESTINFOHEAD[b] + a;
    };
    this.getPaddedDigestInfoHex = function(h, a, j) {
        var c = this.getDigestInfoHex(h, a);
        var d = j / 4;
        if (c.length + 22 > d) throw "key is too short for SigAlg: keylen=" + j + "," + a;
        var b = "0001";
        var k = "00" + c;
        var g = "";
        var l = d - b.length - k.length;
        for(var f = 0; f < l; f += 2)g += "ff";
        var e = b + g + k;
        return e;
    };
    this.hashString = function(a, c) {
        var b = new KJUR.crypto.MessageDigest({
            alg: c
        });
        return b.digestString(a);
    };
    this.hashHex = function(b, c) {
        var a = new KJUR.crypto.MessageDigest({
            alg: c
        });
        return a.digestHex(b);
    };
    this.sha1 = function(a) {
        return this.hashString(a, "sha1");
    };
    this.sha256 = function(a) {
        return this.hashString(a, "sha256");
    };
    this.sha256Hex = function(a) {
        return this.hashHex(a, "sha256");
    };
    this.sha512 = function(a) {
        return this.hashString(a, "sha512");
    };
    this.sha512Hex = function(a) {
        return this.hashHex(a, "sha512");
    };
    this.isKey = function(a) {
        if (a instanceof RSAKey || a instanceof KJUR.crypto.DSA || a instanceof KJUR.crypto.ECDSA) return true;
        else return false;
    };
};
KJUR.crypto.Util.md5 = function(a) {
    var b = new KJUR.crypto.MessageDigest({
        alg: "md5",
        prov: "cryptojs"
    });
    return b.digestString(a);
};
KJUR.crypto.Util.ripemd160 = function(a) {
    var b = new KJUR.crypto.MessageDigest({
        alg: "ripemd160",
        prov: "cryptojs"
    });
    return b.digestString(a);
};
KJUR.crypto.Util.SECURERANDOMGEN = new SecureRandom();
KJUR.crypto.Util.getRandomHexOfNbytes = function(b) {
    var a = new Array(b);
    KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(a);
    return BAtohex(a);
};
KJUR.crypto.Util.getRandomBigIntegerOfNbytes = function(a) {
    return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbytes(a), 16);
};
KJUR.crypto.Util.getRandomHexOfNbits = function(d) {
    var c = d % 8;
    var a = (d - c) / 8;
    var b = new Array(a + 1);
    KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(b);
    b[0] = (255 << c & 255 ^ 255) & b[0];
    return BAtohex(b);
};
KJUR.crypto.Util.getRandomBigIntegerOfNbits = function(a) {
    return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbits(a), 16);
};
KJUR.crypto.Util.getRandomBigIntegerZeroToMax = function(b) {
    var a = b.bitLength();
    while(true){
        var c = KJUR.crypto.Util.getRandomBigIntegerOfNbits(a);
        if (b.compareTo(c) != -1) return c;
    }
};
KJUR.crypto.Util.getRandomBigIntegerMinToMax = function(e, b) {
    var c = e.compareTo(b);
    if (c == 1) throw "biMin is greater than biMax";
    if (c == 0) return e;
    var a = b.subtract(e);
    var d = KJUR.crypto.Util.getRandomBigIntegerZeroToMax(a);
    return d.add(e);
};
KJUR.crypto.MessageDigest = function(c) {
    var b = null;
    var a = null;
    var d = null;
    this.setAlgAndProvider = function(g, f) {
        g = KJUR.crypto.MessageDigest.getCanonicalAlgName(g);
        if (g !== null && f === undefined) f = KJUR.crypto.Util.DEFAULTPROVIDER[g];
        if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && f == "cryptojs") {
            try {
                this.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create();
            } catch (e) {
                throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e;
            }
            this.updateString = function(h) {
                this.md.update(h);
            };
            this.updateHex = function(h) {
                var i = CryptoJS.enc.Hex.parse(h);
                this.md.update(i);
            };
            this.digest = function() {
                var h = this.md.finalize();
                return h.toString(CryptoJS.enc.Hex);
            };
            this.digestString = function(h) {
                this.updateString(h);
                return this.digest();
            };
            this.digestHex = function(h) {
                this.updateHex(h);
                return this.digest();
            };
        }
        if (":sha256:".indexOf(g) != -1 && f == "sjcl") {
            try {
                this.md = new sjcl.hash.sha256();
            } catch (e) {
                throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e;
            }
            this.updateString = function(h) {
                this.md.update(h);
            };
            this.updateHex = function(i) {
                var h = sjcl.codec.hex.toBits(i);
                this.md.update(h);
            };
            this.digest = function() {
                var h = this.md.finalize();
                return sjcl.codec.hex.fromBits(h);
            };
            this.digestString = function(h) {
                this.updateString(h);
                return this.digest();
            };
            this.digestHex = function(h) {
                this.updateHex(h);
                return this.digest();
            };
        }
    };
    this.updateString = function(e) {
        throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };
    this.updateHex = function(e) {
        throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };
    this.digest = function() {
        throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };
    this.digestString = function(e) {
        throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };
    this.digestHex = function(e) {
        throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName;
    };
    if (c !== undefined) {
        if (c.alg !== undefined) {
            this.algName = c.alg;
            if (c.prov === undefined) this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
            this.setAlgAndProvider(this.algName, this.provName);
        }
    }
};
KJUR.crypto.MessageDigest.getCanonicalAlgName = function(a) {
    if (typeof a === "string") {
        a = a.toLowerCase();
        a = a.replace(/-/, "");
    }
    return a;
};
KJUR.crypto.MessageDigest.getHashLength = function(c) {
    var b = KJUR.crypto.MessageDigest;
    var a = b.getCanonicalAlgName(c);
    if (b.HASHLENGTH[a] === undefined) throw "not supported algorithm: " + c;
    return b.HASHLENGTH[a];
};
KJUR.crypto.MessageDigest.HASHLENGTH = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    ripemd160: 20
};
KJUR.crypto.Mac = function(d) {
    var f = null;
    var c = null;
    var a = null;
    var e = null;
    var b = null;
    this.setAlgAndProvider = function(k, i) {
        k = k.toLowerCase();
        if (k == null) k = "hmacsha1";
        k = k.toLowerCase();
        if (k.substr(0, 4) != "hmac") throw "setAlgAndProvider unsupported HMAC alg: " + k;
        if (i === undefined) i = KJUR.crypto.Util.DEFAULTPROVIDER[k];
        this.algProv = k + "/" + i;
        var g = k.substr(4);
        if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && i == "cryptojs") {
            try {
                var j = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g];
                this.mac = CryptoJS.algo.HMAC.create(j, this.pass);
            } catch (h) {
                throw "setAlgAndProvider hash alg set fail hashAlg=" + g + "/" + h;
            }
            this.updateString = function(l) {
                this.mac.update(l);
            };
            this.updateHex = function(l) {
                var m = CryptoJS.enc.Hex.parse(l);
                this.mac.update(m);
            };
            this.doFinal = function() {
                var l = this.mac.finalize();
                return l.toString(CryptoJS.enc.Hex);
            };
            this.doFinalString = function(l) {
                this.updateString(l);
                return this.doFinal();
            };
            this.doFinalHex = function(l) {
                this.updateHex(l);
                return this.doFinal();
            };
        }
    };
    this.updateString = function(g) {
        throw "updateString(str) not supported for this alg/prov: " + this.algProv;
    };
    this.updateHex = function(g) {
        throw "updateHex(hex) not supported for this alg/prov: " + this.algProv;
    };
    this.doFinal = function() {
        throw "digest() not supported for this alg/prov: " + this.algProv;
    };
    this.doFinalString = function(g) {
        throw "digestString(str) not supported for this alg/prov: " + this.algProv;
    };
    this.doFinalHex = function(g) {
        throw "digestHex(hex) not supported for this alg/prov: " + this.algProv;
    };
    this.setPassword = function(h) {
        if (typeof h == "string") {
            var g = h;
            if (h.length % 2 == 1 || !h.match(/^[0-9A-Fa-f]+$/)) g = rstrtohex(h);
            this.pass = CryptoJS.enc.Hex.parse(g);
            return;
        }
        if (typeof h != "object") throw "KJUR.crypto.Mac unsupported password type: " + h;
        var g = null;
        if (h.hex !== undefined) {
            if (h.hex.length % 2 != 0 || !h.hex.match(/^[0-9A-Fa-f]+$/)) throw "Mac: wrong hex password: " + h.hex;
            g = h.hex;
        }
        if (h.utf8 !== undefined) g = utf8tohex(h.utf8);
        if (h.rstr !== undefined) g = rstrtohex(h.rstr);
        if (h.b64 !== undefined) g = b64tohex(h.b64);
        if (h.b64u !== undefined) g = b64utohex(h.b64u);
        if (g == null) throw "KJUR.crypto.Mac unsupported password type: " + h;
        this.pass = CryptoJS.enc.Hex.parse(g);
    };
    if (d !== undefined) {
        if (d.pass !== undefined) this.setPassword(d.pass);
        if (d.alg !== undefined) {
            this.algName = d.alg;
            if (d.prov === undefined) this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
            this.setAlgAndProvider(this.algName, this.provName);
        }
    }
};
KJUR.crypto.Signature = function(o) {
    var q = null;
    var n = null;
    var r = null;
    var c = null;
    var l = null;
    var d = null;
    var k = null;
    var h = null;
    var p = null;
    var e = null;
    var b = -1;
    var g = null;
    var j = null;
    var a = null;
    var i = null;
    var f = null;
    this._setAlgNames = function() {
        var s = this.algName.match(/^(.+)with(.+)$/);
        if (s) {
            this.mdAlgName = s[1].toLowerCase();
            this.pubkeyAlgName = s[2].toLowerCase();
            if (this.pubkeyAlgName == "rsaandmgf1" && this.mdAlgName == "sha") this.mdAlgName = "sha1";
        }
    };
    this._zeroPaddingOfSignature = function(x, w) {
        var v = "";
        var t = w / 4 - x.length;
        for(var u = 0; u < t; u++)v = v + "0";
        return v + x;
    };
    this.setAlgAndProvider = function(u, t) {
        this._setAlgNames();
        if (t != "cryptojs/jsrsa") throw new Error("provider not supported: " + t);
        if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName) != -1) {
            try {
                this.md = new KJUR.crypto.MessageDigest({
                    alg: this.mdAlgName
                });
            } catch (s) {
                throw new Error("setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + s);
            }
            this.init = function(w, x) {
                var y = null;
                try {
                    if (x === undefined) y = KEYUTIL.getKey(w);
                    else y = KEYUTIL.getKey(w, x);
                } catch (v) {
                    throw "init failed:" + v;
                }
                if (y.isPrivate === true) {
                    this.prvKey = y;
                    this.state = "SIGN";
                } else {
                    if (y.isPublic === true) {
                        this.pubKey = y;
                        this.state = "VERIFY";
                    } else throw "init failed.:" + y;
                }
            };
            this.updateString = function(v) {
                this.md.updateString(v);
            };
            this.updateHex = function(v) {
                this.md.updateHex(v);
            };
            this.sign = function() {
                this.sHashHex = this.md.digest();
                if (this.prvKey === undefined && this.ecprvhex !== undefined && this.eccurvename !== undefined && KJUR.crypto.ECDSA !== undefined) this.prvKey = new KJUR.crypto.ECDSA({
                    curve: this.eccurvename,
                    prv: this.ecprvhex
                });
                if (this.prvKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1") this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex, this.mdAlgName, this.pssSaltLen);
                else {
                    if (this.prvKey instanceof RSAKey && this.pubkeyAlgName === "rsa") this.hSign = this.prvKey.signWithMessageHash(this.sHashHex, this.mdAlgName);
                    else if (this.prvKey instanceof KJUR.crypto.ECDSA) this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                    else {
                        if (this.prvKey instanceof KJUR.crypto.DSA) this.hSign = this.prvKey.signWithMessageHash(this.sHashHex);
                        else throw "Signature: unsupported private key alg: " + this.pubkeyAlgName;
                    }
                }
                return this.hSign;
            };
            this.signString = function(v) {
                this.updateString(v);
                return this.sign();
            };
            this.signHex = function(v) {
                this.updateHex(v);
                return this.sign();
            };
            this.verify = function(v) {
                this.sHashHex = this.md.digest();
                if (this.pubKey === undefined && this.ecpubhex !== undefined && this.eccurvename !== undefined && KJUR.crypto.ECDSA !== undefined) this.pubKey = new KJUR.crypto.ECDSA({
                    curve: this.eccurvename,
                    pub: this.ecpubhex
                });
                if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1") return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, v, this.mdAlgName, this.pssSaltLen);
                else {
                    if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsa") return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
                    else {
                        if (KJUR.crypto.ECDSA !== undefined && this.pubKey instanceof KJUR.crypto.ECDSA) return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
                        else {
                            if (KJUR.crypto.DSA !== undefined && this.pubKey instanceof KJUR.crypto.DSA) return this.pubKey.verifyWithMessageHash(this.sHashHex, v);
                            else throw "Signature: unsupported public key alg: " + this.pubkeyAlgName;
                        }
                    }
                }
            };
        }
    };
    this.init = function(s, t) {
        throw "init(key, pass) not supported for this alg:prov=" + this.algProvName;
    };
    this.updateString = function(s) {
        throw "updateString(str) not supported for this alg:prov=" + this.algProvName;
    };
    this.updateHex = function(s) {
        throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName;
    };
    this.sign = function() {
        throw "sign() not supported for this alg:prov=" + this.algProvName;
    };
    this.signString = function(s) {
        throw "digestString(str) not supported for this alg:prov=" + this.algProvName;
    };
    this.signHex = function(s) {
        throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName;
    };
    this.verify = function(s) {
        throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName;
    };
    this.initParams = o;
    if (o !== undefined) {
        if (o.alg !== undefined) {
            this.algName = o.alg;
            if (o.prov === undefined) this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName];
            else this.provName = o.prov;
            this.algProvName = this.algName + ":" + this.provName;
            this.setAlgAndProvider(this.algName, this.provName);
            this._setAlgNames();
        }
        if (o.psssaltlen !== undefined) this.pssSaltLen = o.psssaltlen;
        if (o.prvkeypem !== undefined) {
            if (o.prvkeypas !== undefined) throw "both prvkeypem and prvkeypas parameters not supported";
            else try {
                var q = KEYUTIL.getKey(o.prvkeypem);
                this.init(q);
            } catch (m) {
                throw "fatal error to load pem private key: " + m;
            }
        }
    }
};
KJUR.crypto.OID = new function() {
    this.oidhex2name = {
        "2a864886f70d010101": "rsaEncryption",
        "2a8648ce3d0201": "ecPublicKey",
        "2a8648ce380401": "dsa",
        "2a8648ce3d030107": "secp256r1",
        "2b8104001f": "secp192k1",
        "2b81040021": "secp224r1",
        "2b8104000a": "secp256k1",
        "2b81040022": "secp384r1",
        "2b81040023": "secp521r1",
        "2a8648ce380403": "SHA1withDSA",
        "608648016503040301": "SHA224withDSA",
        "608648016503040302": "SHA256withDSA"
    };
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};
KJUR.crypto.ECDSA = function(e) {
    var g = "secp256r1";
    var p = null;
    var b = null;
    var i = null;
    var j = Error, f = BigInteger, h = ECPointFp, m = KJUR.crypto.ECDSA, c = KJUR.crypto.ECParameterDB, d = m.getName, q = ASN1HEX, n = q.getVbyListEx, k = q.isASN1HEX;
    var a = new SecureRandom();
    var o = null;
    this.type = "EC";
    this.isPrivate = false;
    this.isPublic = false;
    function l(x, t, w, s) {
        var r = Math.max(t.bitLength(), s.bitLength());
        var y = x.add2D(w);
        var v = x.curve.getInfinity();
        for(var u = r - 1; u >= 0; --u){
            v = v.twice2D();
            v.z = f.ONE;
            if (t.testBit(u)) {
                if (s.testBit(u)) v = v.add2D(y);
                else v = v.add2D(x);
            } else if (s.testBit(u)) v = v.add2D(w);
        }
        return v;
    }
    this.getBigRandom = function(r) {
        return new f(r.bitLength(), a).mod(r.subtract(f.ONE)).add(f.ONE);
    };
    this.setNamedCurve = function(r) {
        this.ecparams = c.getByName(r);
        this.prvKeyHex = null;
        this.pubKeyHex = null;
        this.curveName = r;
    };
    this.setPrivateKeyHex = function(r) {
        this.isPrivate = true;
        this.prvKeyHex = r;
    };
    this.setPublicKeyHex = function(r) {
        this.isPublic = true;
        this.pubKeyHex = r;
    };
    this.getPublicKeyXYHex = function() {
        var t = this.pubKeyHex;
        if (t.substr(0, 2) !== "04") throw "this method supports uncompressed format(04) only";
        var s = this.ecparams.keycharlen;
        if (t.length !== 2 + s * 2) throw "malformed public key hex length";
        var r = {};
        r.x = t.substr(2, s);
        r.y = t.substr(2 + s);
        return r;
    };
    this.getShortNISTPCurveName = function() {
        var r = this.curveName;
        if (r === "secp256r1" || r === "NIST P-256" || r === "P-256" || r === "prime256v1") return "P-256";
        if (r === "secp384r1" || r === "NIST P-384" || r === "P-384") return "P-384";
        if (r === "secp521r1" || r === "NIST P-521" || r === "P-521") return "P-521";
        return null;
    };
    this.generateKeyPairHex = function() {
        var s = this.ecparams.n;
        var u = this.getBigRandom(s);
        var r = this.ecparams.keycharlen;
        var t = ("0000000000" + u.toString(16)).slice(-r);
        this.setPrivateKeyHex(t);
        var v = this.generatePublicKeyHex();
        return {
            ecprvhex: t,
            ecpubhex: v
        };
    };
    this.generatePublicKeyHex = function() {
        var u = new f(this.prvKeyHex, 16);
        var w = this.ecparams.G.multiply(u);
        var t = w.getX().toBigInteger();
        var s = w.getY().toBigInteger();
        var r = this.ecparams.keycharlen;
        var y = ("0000000000" + t.toString(16)).slice(-r);
        var v = ("0000000000" + s.toString(16)).slice(-r);
        var x = "04" + y + v;
        this.setPublicKeyHex(x);
        return x;
    };
    this.signWithMessageHash = function(r) {
        return this.signHex(r, this.prvKeyHex);
    };
    this.signHex = function(x, u) {
        var A = new f(u, 16);
        var v = this.ecparams.n;
        var z = new f(x.substring(0, this.ecparams.keycharlen), 16);
        do {
            var w = this.getBigRandom(v);
            var B = this.ecparams.G;
            var y = B.multiply(w);
            var t = y.getX().toBigInteger().mod(v);
        }while (t.compareTo(f.ZERO) <= 0);
        var C = w.modInverse(v).multiply(z.add(A.multiply(t))).mod(v);
        return m.biRSSigToASN1Sig(t, C);
    };
    this.sign = function(w, B) {
        var z = B;
        var u = this.ecparams.n;
        var y = f.fromByteArrayUnsigned(w);
        do {
            var v = this.getBigRandom(u);
            var A = this.ecparams.G;
            var x = A.multiply(v);
            var t = x.getX().toBigInteger().mod(u);
        }while (t.compareTo(BigInteger.ZERO) <= 0);
        var C = v.modInverse(u).multiply(y.add(z.multiply(t))).mod(u);
        return this.serializeSig(t, C);
    };
    this.verifyWithMessageHash = function(s, r) {
        return this.verifyHex(s, r, this.pubKeyHex);
    };
    this.verifyHex = function(v, y, u) {
        try {
            var t, B;
            var w = m.parseSigHex(y);
            t = w.r;
            B = w.s;
            var x = h.decodeFromHex(this.ecparams.curve, u);
            var z = new f(v.substring(0, this.ecparams.keycharlen), 16);
            return this.verifyRaw(z, t, B, x);
        } catch (A) {
            return false;
        }
    };
    this.verify = function(z, A, u) {
        var w, t;
        if (Bitcoin.Util.isArray(A)) {
            var y = this.parseSig(A);
            w = y.r;
            t = y.s;
        } else {
            if ("object" === typeof A && A.r && A.s) {
                w = A.r;
                t = A.s;
            } else throw "Invalid value for signature";
        }
        var v;
        if (u instanceof ECPointFp) v = u;
        else {
            if (Bitcoin.Util.isArray(u)) v = h.decodeFrom(this.ecparams.curve, u);
            else throw "Invalid format for pubkey value, must be byte array or ECPointFp";
        }
        var x = f.fromByteArrayUnsigned(z);
        return this.verifyRaw(x, w, t, v);
    };
    this.verifyRaw = function(z, t, E, y) {
        var x = this.ecparams.n;
        var D = this.ecparams.G;
        if (t.compareTo(f.ONE) < 0 || t.compareTo(x) >= 0) return false;
        if (E.compareTo(f.ONE) < 0 || E.compareTo(x) >= 0) return false;
        var A = E.modInverse(x);
        var w = z.multiply(A).mod(x);
        var u = t.multiply(A).mod(x);
        var B = D.multiply(w).add(y.multiply(u));
        var C = B.getX().toBigInteger().mod(x);
        return C.equals(t);
    };
    this.serializeSig = function(v, u) {
        var w = v.toByteArraySigned();
        var t = u.toByteArraySigned();
        var x = [];
        x.push(2);
        x.push(w.length);
        x = x.concat(w);
        x.push(2);
        x.push(t.length);
        x = x.concat(t);
        x.unshift(x.length);
        x.unshift(48);
        return x;
    };
    this.parseSig = function(y) {
        var x;
        if (y[0] != 48) throw new Error("Signature not a valid DERSequence");
        x = 2;
        if (y[x] != 2) throw new Error("First element in signature must be a DERInteger");
        var w = y.slice(x + 2, x + 2 + y[x + 1]);
        x += 2 + y[x + 1];
        if (y[x] != 2) throw new Error("Second element in signature must be a DERInteger");
        var t = y.slice(x + 2, x + 2 + y[x + 1]);
        x += 2 + y[x + 1];
        var v = f.fromByteArrayUnsigned(w);
        var u = f.fromByteArrayUnsigned(t);
        return {
            r: v,
            s: u
        };
    };
    this.parseSigCompact = function(w) {
        if (w.length !== 65) throw "Signature has the wrong length";
        var t = w[0] - 27;
        if (t < 0 || t > 7) throw "Invalid signature type";
        var x = this.ecparams.n;
        var v = f.fromByteArrayUnsigned(w.slice(1, 33)).mod(x);
        var u = f.fromByteArrayUnsigned(w.slice(33, 65)).mod(x);
        return {
            r: v,
            s: u,
            i: t
        };
    };
    this.readPKCS5PrvKeyHex = function(u) {
        if (k(u) === false) throw new Error("not ASN.1 hex string");
        var r, t, v;
        try {
            r = n(u, 0, [
                "[0]",
                0
            ], "06");
            t = n(u, 0, [
                1
            ], "04");
            try {
                v = n(u, 0, [
                    "[1]",
                    0
                ], "03");
            } catch (s) {}
        } catch (s) {
            throw new Error("malformed PKCS#1/5 plain ECC private key");
        }
        this.curveName = d(r);
        if (this.curveName === undefined) throw "unsupported curve name";
        this.setNamedCurve(this.curveName);
        this.setPublicKeyHex(v);
        this.setPrivateKeyHex(t);
        this.isPublic = false;
    };
    this.readPKCS8PrvKeyHex = function(v) {
        if (k(v) === false) throw new j("not ASN.1 hex string");
        var t, r, u, w;
        try {
            t = n(v, 0, [
                1,
                0
            ], "06");
            r = n(v, 0, [
                1,
                1
            ], "06");
            u = n(v, 0, [
                2,
                0,
                1
            ], "04");
            try {
                w = n(v, 0, [
                    2,
                    0,
                    "[1]",
                    0
                ], "03");
            } catch (s) {}
        } catch (s) {
            throw new j("malformed PKCS#8 plain ECC private key");
        }
        this.curveName = d(r);
        if (this.curveName === undefined) throw new j("unsupported curve name");
        this.setNamedCurve(this.curveName);
        this.setPublicKeyHex(w);
        this.setPrivateKeyHex(u);
        this.isPublic = false;
    };
    this.readPKCS8PubKeyHex = function(u) {
        if (k(u) === false) throw new j("not ASN.1 hex string");
        var t, r, v;
        try {
            t = n(u, 0, [
                0,
                0
            ], "06");
            r = n(u, 0, [
                0,
                1
            ], "06");
            v = n(u, 0, [
                1
            ], "03");
        } catch (s) {
            throw new j("malformed PKCS#8 ECC public key");
        }
        this.curveName = d(r);
        if (this.curveName === null) throw new j("unsupported curve name");
        this.setNamedCurve(this.curveName);
        this.setPublicKeyHex(v);
    };
    this.readCertPubKeyHex = function(t, v) {
        if (k(t) === false) throw new j("not ASN.1 hex string");
        var r, u;
        try {
            r = n(t, 0, [
                0,
                5,
                0,
                1
            ], "06");
            u = n(t, 0, [
                0,
                5,
                1
            ], "03");
        } catch (s) {
            throw new j("malformed X.509 certificate ECC public key");
        }
        this.curveName = d(r);
        if (this.curveName === null) throw new j("unsupported curve name");
        this.setNamedCurve(this.curveName);
        this.setPublicKeyHex(u);
    };
    if (e !== undefined) {
        if (e.curve !== undefined) this.curveName = e.curve;
    }
    if (this.curveName === undefined) this.curveName = g;
    this.setNamedCurve(this.curveName);
    if (e !== undefined) {
        if (e.prv !== undefined) this.setPrivateKeyHex(e.prv);
        if (e.pub !== undefined) this.setPublicKeyHex(e.pub);
    }
};
KJUR.crypto.ECDSA.parseSigHex = function(a) {
    var b = KJUR.crypto.ECDSA.parseSigHexInHexRS(a);
    var d = new BigInteger(b.r, 16);
    var c = new BigInteger(b.s, 16);
    return {
        r: d,
        s: c
    };
};
KJUR.crypto.ECDSA.parseSigHexInHexRS = function(f) {
    var j = ASN1HEX, i = j.getChildIdx, g = j.getV;
    j.checkStrictDER(f, 0);
    if (f.substr(0, 2) != "30") throw new Error("signature is not a ASN.1 sequence");
    var h = i(f, 0);
    if (h.length != 2) throw new Error("signature shall have two elements");
    var e = h[0];
    var d = h[1];
    if (f.substr(e, 2) != "02") throw new Error("1st item not ASN.1 integer");
    if (f.substr(d, 2) != "02") throw new Error("2nd item not ASN.1 integer");
    var c = g(f, e);
    var b = g(f, d);
    return {
        r: c,
        s: b
    };
};
KJUR.crypto.ECDSA.asn1SigToConcatSig = function(d) {
    var e = KJUR.crypto.ECDSA.parseSigHexInHexRS(d);
    var b = e.r;
    var a = e.s;
    if (b.length >= 130 && b.length <= 134) {
        if (b.length % 2 != 0) throw Error("unknown ECDSA sig r length error");
        if (a.length % 2 != 0) throw Error("unknown ECDSA sig s length error");
        if (b.substr(0, 2) == "00") b = b.substr(2);
        if (a.substr(0, 2) == "00") a = a.substr(2);
        var c = Math.max(b.length, a.length);
        b = ("000000" + b).slice(-c);
        a = ("000000" + a).slice(-c);
        return b + a;
    }
    if (b.substr(0, 2) == "00" && b.length % 32 == 2) b = b.substr(2);
    if (a.substr(0, 2) == "00" && a.length % 32 == 2) a = a.substr(2);
    if (b.length % 32 == 30) b = "00" + b;
    if (a.length % 32 == 30) a = "00" + a;
    if (b.length % 32 != 0) throw Error("unknown ECDSA sig r length error");
    if (a.length % 32 != 0) throw Error("unknown ECDSA sig s length error");
    return b + a;
};
KJUR.crypto.ECDSA.concatSigToASN1Sig = function(a) {
    if (a.length % 4 != 0) throw Error("unknown ECDSA concatinated r-s sig length error");
    var c = a.substr(0, a.length / 2);
    var b = a.substr(a.length / 2);
    return KJUR.crypto.ECDSA.hexRSSigToASN1Sig(c, b);
};
KJUR.crypto.ECDSA.hexRSSigToASN1Sig = function(b, a) {
    var d = new BigInteger(b, 16);
    var c = new BigInteger(a, 16);
    return KJUR.crypto.ECDSA.biRSSigToASN1Sig(d, c);
};
KJUR.crypto.ECDSA.biRSSigToASN1Sig = function(f, d) {
    var c = KJUR.asn1;
    var b = new c.DERInteger({
        bigint: f
    });
    var a = new c.DERInteger({
        bigint: d
    });
    var e = new c.DERSequence({
        array: [
            b,
            a
        ]
    });
    return e.tohex();
};
KJUR.crypto.ECDSA.getName = function(a) {
    if (a === "2b8104001f") return "secp192k1";
    if (a === "2a8648ce3d030107") return "secp256r1";
    if (a === "2b8104000a") return "secp256k1";
    if (a === "2b81040021") return "secp224r1";
    if (a === "2b81040022") return "secp384r1";
    if (a === "2b81040023") return "secp521r1";
    if ("|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(a) !== -1) return "secp256r1";
    if ("|secp256k1|".indexOf(a) !== -1) return "secp256k1";
    if ("|secp224r1|NIST P-224|P-224|".indexOf(a) !== -1) return "secp224r1";
    if ("|secp384r1|NIST P-384|P-384|".indexOf(a) !== -1) return "secp384r1";
    if ("|secp521r1|NIST P-521|P-521|".indexOf(a) !== -1) return "secp521r1";
    return null;
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};
KJUR.crypto.ECParameterDB = new function() {
    var b = {};
    var c = {};
    function a(d) {
        return new BigInteger(d, 16);
    }
    this.getByName = function(e) {
        var d = e;
        if (typeof c[d] != "undefined") d = c[e];
        if (typeof b[d] != "undefined") return b[d];
        throw "unregistered EC curve name: " + d;
    };
    this.regist = function(A, l, o, g, m, e, j, f, k, u, d, x) {
        b[A] = {};
        var s = a(o);
        var z = a(g);
        var y = a(m);
        var t = a(e);
        var w = a(j);
        var r = new ECCurveFp(s, z, y);
        var q = r.decodePointHex("04" + f + k);
        b[A]["name"] = A;
        b[A]["keylen"] = l;
        b[A]["keycharlen"] = Math.ceil(l / 8) * 2;
        b[A]["curve"] = r;
        b[A]["G"] = q;
        b[A]["n"] = t;
        b[A]["h"] = w;
        b[A]["oid"] = d;
        b[A]["info"] = x;
        for(var v = 0; v < u.length; v++)c[u[v]] = A;
    };
};
KJUR.crypto.ECParameterDB.regist("secp128r1", 128, "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC", "E87579C11079F43DD824993C2CEE5ED3", "FFFFFFFE0000000075A30D1B9038A115", "1", "161FF7528B899B2D0C28607CA52C5B86", "CF5AC8395BAFEB13C02DA292DDED7A83", [], "", "secp128r1 : SECG curve over a 128 bit prime field");
KJUR.crypto.ECParameterDB.regist("secp160k1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", "0", "7", "0100000000000000000001B8FA16DFAB9ACA16B6B3", "1", "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB", "938CF935318FDCED6BC28286531733C3F03C4FEE", [], "", "secp160k1 : SECG curve over a 160 bit prime field");
KJUR.crypto.ECParameterDB.regist("secp160r1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC", "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45", "0100000000000000000001F4C8F927AED3CA752257", "1", "4A96B5688EF573284664698968C38BB913CBFC82", "23A628553168947D59DCC912042351377AC5FB32", [], "", "secp160r1 : SECG curve over a 160 bit prime field");
KJUR.crypto.ECParameterDB.regist("secp192k1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", "0", "3", "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", "1", "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", []);
KJUR.crypto.ECParameterDB.regist("secp192r1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", "1", "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811", []);
KJUR.crypto.ECParameterDB.regist("secp224r1", 224, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", "1", "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", []);
KJUR.crypto.ECParameterDB.regist("secp256k1", 256, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", "0", "7", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "1", "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", []);
KJUR.crypto.ECParameterDB.regist("secp256r1", 256, "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", "1", "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", [
    "NIST P-256",
    "P-256",
    "prime256v1"
]);
KJUR.crypto.ECParameterDB.regist("secp384r1", 384, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC", "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", "1", "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7", "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", [
    "NIST P-384",
    "P-384"
]);
KJUR.crypto.ECParameterDB.regist("secp521r1", 521, "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC", "051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409", "1", "00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66", "011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650", [
    "NIST P-521",
    "P-521"
]);
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) KJUR.crypto = {};
KJUR.crypto.DSA = function() {
    var b = ASN1HEX, e = b.getVbyList, d = b.getVbyListEx, a = b.isASN1HEX, c = BigInteger;
    this.p = null;
    this.q = null;
    this.g = null;
    this.y = null;
    this.x = null;
    this.type = "DSA";
    this.isPrivate = false;
    this.isPublic = false;
    this.setPrivate = function(j, i, h, k, f) {
        this.isPrivate = true;
        this.p = j;
        this.q = i;
        this.g = h;
        this.y = k;
        this.x = f;
    };
    this.setPrivateHex = function(i, g, k, n, o) {
        var h, f, j, l, m;
        h = new BigInteger(i, 16);
        f = new BigInteger(g, 16);
        j = new BigInteger(k, 16);
        if (typeof n === "string" && n.length > 1) l = new BigInteger(n, 16);
        else l = null;
        m = new BigInteger(o, 16);
        this.setPrivate(h, f, j, l, m);
    };
    this.setPublic = function(i, h, f, j) {
        this.isPublic = true;
        this.p = i;
        this.q = h;
        this.g = f;
        this.y = j;
        this.x = null;
    };
    this.setPublicHex = function(k, j, i, l) {
        var g, f, m, h;
        g = new BigInteger(k, 16);
        f = new BigInteger(j, 16);
        m = new BigInteger(i, 16);
        h = new BigInteger(l, 16);
        this.setPublic(g, f, m, h);
    };
    this.signWithMessageHash = function(j) {
        var i = this.p;
        var h = this.q;
        var m = this.g;
        var o = this.y;
        var t = this.x;
        var l = KJUR.crypto.Util.getRandomBigIntegerMinToMax(BigInteger.ONE.add(BigInteger.ONE), h.subtract(BigInteger.ONE));
        var u = j.substr(0, h.bitLength() / 4);
        var n = new BigInteger(u, 16);
        var f = m.modPow(l, i).mod(h);
        var w = l.modInverse(h).multiply(n.add(t.multiply(f))).mod(h);
        var v = KJUR.asn1.ASN1Util.jsonToASN1HEX({
            seq: [
                {
                    "int": {
                        bigint: f
                    }
                },
                {
                    "int": {
                        bigint: w
                    }
                }
            ]
        });
        return v;
    };
    this.verifyWithMessageHash = function(m, l) {
        var j = this.p;
        var h = this.q;
        var o = this.g;
        var u = this.y;
        var n = this.parseASN1Signature(l);
        var f = n[0];
        var C = n[1];
        var B = m.substr(0, h.bitLength() / 4);
        var t = new BigInteger(B, 16);
        if (BigInteger.ZERO.compareTo(f) > 0 || f.compareTo(h) > 0) throw "invalid DSA signature";
        if (BigInteger.ZERO.compareTo(C) >= 0 || C.compareTo(h) > 0) throw "invalid DSA signature";
        var x = C.modInverse(h);
        var k = t.multiply(x).mod(h);
        var i = f.multiply(x).mod(h);
        var A = o.modPow(k, j).multiply(u.modPow(i, j)).mod(j).mod(h);
        return A.compareTo(f) == 0;
    };
    this.parseASN1Signature = function(f) {
        try {
            var i = new c(d(f, 0, [
                0
            ], "02"), 16);
            var h = new c(d(f, 0, [
                1
            ], "02"), 16);
            return [
                i,
                h
            ];
        } catch (g) {
            throw new Error("malformed ASN.1 DSA signature");
        }
    };
    this.readPKCS5PrvKeyHex = function(j) {
        var k, i, g, l, m;
        if (a(j) === false) throw new Error("not ASN.1 hex string");
        try {
            k = d(j, 0, [
                1
            ], "02");
            i = d(j, 0, [
                2
            ], "02");
            g = d(j, 0, [
                3
            ], "02");
            l = d(j, 0, [
                4
            ], "02");
            m = d(j, 0, [
                5
            ], "02");
        } catch (f) {
            throw new Error("malformed PKCS#1/5 plain DSA private key");
        }
        this.setPrivateHex(k, i, g, l, m);
    };
    this.readPKCS8PrvKeyHex = function(j) {
        var k, i, g, l;
        if (a(j) === false) throw new Error("not ASN.1 hex string");
        try {
            k = d(j, 0, [
                1,
                1,
                0
            ], "02");
            i = d(j, 0, [
                1,
                1,
                1
            ], "02");
            g = d(j, 0, [
                1,
                1,
                2
            ], "02");
            l = d(j, 0, [
                2,
                0
            ], "02");
        } catch (f) {
            throw new Error("malformed PKCS#8 plain DSA private key");
        }
        this.setPrivateHex(k, i, g, null, l);
    };
    this.readPKCS8PubKeyHex = function(j) {
        var k, i, g, l;
        if (a(j) === false) throw new Error("not ASN.1 hex string");
        try {
            k = d(j, 0, [
                0,
                1,
                0
            ], "02");
            i = d(j, 0, [
                0,
                1,
                1
            ], "02");
            g = d(j, 0, [
                0,
                1,
                2
            ], "02");
            l = d(j, 0, [
                1,
                0
            ], "02");
        } catch (f) {
            throw new Error("malformed PKCS#8 DSA public key");
        }
        this.setPublicHex(k, i, g, l);
    };
    this.readCertPubKeyHex = function(j, m) {
        var k, i, g, l;
        if (a(j) === false) throw new Error("not ASN.1 hex string");
        try {
            k = d(j, 0, [
                0,
                5,
                0,
                1,
                0
            ], "02");
            i = d(j, 0, [
                0,
                5,
                0,
                1,
                1
            ], "02");
            g = d(j, 0, [
                0,
                5,
                0,
                1,
                2
            ], "02");
            l = d(j, 0, [
                0,
                5,
                1,
                0
            ], "02");
        } catch (f) {
            throw new Error("malformed X.509 certificate DSA public key");
        }
        this.setPublicHex(k, i, g, l);
    };
};
var KEYUTIL = function() {
    var d = function(p, r, q) {
        return k(CryptoJS.AES, p, r, q);
    };
    var e = function(p, r, q) {
        return k(CryptoJS.TripleDES, p, r, q);
    };
    var a = function(p, r, q) {
        return k(CryptoJS.DES, p, r, q);
    };
    var k = function(s, x, u, q) {
        var r = CryptoJS.enc.Hex.parse(x);
        var w = CryptoJS.enc.Hex.parse(u);
        var p = CryptoJS.enc.Hex.parse(q);
        var t = {};
        t.key = w;
        t.iv = p;
        t.ciphertext = r;
        var v = s.decrypt(t, w, {
            iv: p
        });
        return CryptoJS.enc.Hex.stringify(v);
    };
    var l = function(p, r, q) {
        return g(CryptoJS.AES, p, r, q);
    };
    var o = function(p, r, q) {
        return g(CryptoJS.TripleDES, p, r, q);
    };
    var f = function(p, r, q) {
        return g(CryptoJS.DES, p, r, q);
    };
    var g = function(t, y, v, q) {
        var s = CryptoJS.enc.Hex.parse(y);
        var x = CryptoJS.enc.Hex.parse(v);
        var p = CryptoJS.enc.Hex.parse(q);
        var w = t.encrypt(s, x, {
            iv: p
        });
        var r = CryptoJS.enc.Hex.parse(w.toString());
        var u = CryptoJS.enc.Base64.stringify(r);
        return u;
    };
    var i = {
        "AES-256-CBC": {
            proc: d,
            eproc: l,
            keylen: 32,
            ivlen: 16
        },
        "AES-192-CBC": {
            proc: d,
            eproc: l,
            keylen: 24,
            ivlen: 16
        },
        "AES-128-CBC": {
            proc: d,
            eproc: l,
            keylen: 16,
            ivlen: 16
        },
        "DES-EDE3-CBC": {
            proc: e,
            eproc: o,
            keylen: 24,
            ivlen: 8
        },
        "DES-CBC": {
            proc: a,
            eproc: f,
            keylen: 8,
            ivlen: 8
        }
    };
    var c = function(p) {
        return i[p]["proc"];
    };
    var m = function(p) {
        var r = CryptoJS.lib.WordArray.random(p);
        var q = CryptoJS.enc.Hex.stringify(r);
        return q;
    };
    var n = function(v) {
        var w = {};
        var q = v.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)", "m"));
        if (q) {
            w.cipher = q[1];
            w.ivsalt = q[2];
        }
        var p = v.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));
        if (p) w.type = p[1];
        var u = -1;
        var x = 0;
        if (v.indexOf("\r\n\r\n") != -1) {
            u = v.indexOf("\r\n\r\n");
            x = 2;
        }
        if (v.indexOf("\n\n") != -1) {
            u = v.indexOf("\n\n");
            x = 1;
        }
        var t = v.indexOf("-----END");
        if (u != -1 && t != -1) {
            var r = v.substring(u + x * 2, t - x);
            r = r.replace(/\s+/g, "");
            w.data = r;
        }
        return w;
    };
    var j = function(q, y, p) {
        var v = p.substring(0, 16);
        var t = CryptoJS.enc.Hex.parse(v);
        var r = CryptoJS.enc.Utf8.parse(y);
        var u = i[q]["keylen"] + i[q]["ivlen"];
        var x = "";
        var w = null;
        for(;;){
            var s = CryptoJS.algo.MD5.create();
            if (w != null) s.update(w);
            s.update(r);
            s.update(t);
            w = s.finalize();
            x = x + CryptoJS.enc.Hex.stringify(w);
            if (x.length >= u * 2) break;
        }
        var z = {};
        z.keyhex = x.substr(0, i[q]["keylen"] * 2);
        z.ivhex = x.substr(i[q]["keylen"] * 2, i[q]["ivlen"] * 2);
        return z;
    };
    var b = function(p, v, r, w) {
        var s = CryptoJS.enc.Base64.parse(p);
        var q = CryptoJS.enc.Hex.stringify(s);
        var u = i[v]["proc"];
        var t = u(q, r, w);
        return t;
    };
    var h = function(p, s, q, u) {
        var r = i[s]["eproc"];
        var t = r(p, q, u);
        return t;
    };
    return {
        version: "1.0.0",
        parsePKCS5PEM: function(p) {
            return n(p);
        },
        getKeyAndUnusedIvByPasscodeAndIvsalt: function(q, p, r) {
            return j(q, p, r);
        },
        decryptKeyB64: function(p, r, q, s) {
            return b(p, r, q, s);
        },
        getDecryptedKeyHex: function(y, x) {
            var q = n(y);
            var t = q.type;
            var r = q.cipher;
            var p = q.ivsalt;
            var s = q.data;
            var w = j(r, x, p);
            var v = w.keyhex;
            var u = b(s, r, v, p);
            return u;
        },
        getEncryptedPKCS5PEMFromPrvKeyHex: function(x, s, A, t, r) {
            var p = "";
            if (typeof t == "undefined" || t == null) t = "AES-256-CBC";
            if (typeof i[t] == "undefined") throw new Error("KEYUTIL unsupported algorithm: " + t);
            if (typeof r == "undefined" || r == null) {
                var v = i[t]["ivlen"];
                var u = m(v);
                r = u.toUpperCase();
            }
            var z = j(t, A, r);
            var y = z.keyhex;
            var w = h(s, t, y, r);
            var q = w.replace(/(.{64})/g, "$1\r\n");
            var p = "-----BEGIN " + x + " PRIVATE KEY-----\r\n";
            p += "Proc-Type: 4,ENCRYPTED\r\n";
            p += "DEK-Info: " + t + "," + r + "\r\n";
            p += "\r\n";
            p += q;
            p += "\r\n-----END " + x + " PRIVATE KEY-----\r\n";
            return p;
        },
        getEncryptedPKCS8PEM: function(r, p, s) {
            var q = this.getEncryptedPKCS8Hex(r, p, s);
            return hextopem(q, "ENCRYPTED PRIVATE KEY");
        },
        getEncryptedPKCS8Hex: function(r, p, t) {
            var q;
            if (t == undefined || t == null) q = {};
            else q = JSON.parse(JSON.stringify(t));
            q.plain = r;
            this.initPBES2Param(q);
            this.encryptPBES2Param(q, p);
            var s = this.generatePBES2ASN1Param(q);
            return KJUR.asn1.ASN1Util.newObject(s).tohex();
        },
        initPBES2Param: function(p) {
            if (aryval(p, "encalg") == undefined) p.encalg = "aes256-CBC";
            if (aryval(p, "iter") == undefined) p.iter = 2048;
            if (aryval(p, "prf") == undefined) p.prf = "hmacWithSHA256";
            if (aryval(p, "salt") == undefined) p.salt = CryptoJS.enc.Hex.stringify(CryptoJS.lib.WordArray.random(8));
            if (aryval(p, "enciv") == undefined) {
                var q;
                if (p.encalg == "des-EDE3-CBC") q = 8;
                if (p.encalg == "aes128-CBC") q = 16;
                if (p.encalg == "aes256-CBC") q = 16;
                p.enciv = CryptoJS.enc.Hex.stringify(CryptoJS.lib.WordArray.random(q));
            }
        },
        encryptPBES2Param: function(p, q) {
            var t = KEYUTIL.getDKFromPBES2Param(p, q);
            try {
                var s = KJUR.crypto.Cipher.encrypt(p.plain, t, p.encalg, {
                    iv: p.enciv
                });
            } catch (r) {
                throw new Error("encrypt error: " + p.plain + " " + t + " " + p.encalg + " " + p.enciv);
            }
            p.enc = s;
        },
        generatePBES2ASN1Param: function(p) {
            var q = {
                seq: [
                    {
                        seq: [
                            {
                                oid: "pkcs5PBES2"
                            },
                            {
                                seq: [
                                    {
                                        seq: [
                                            {
                                                oid: "pkcs5PBKDF2"
                                            },
                                            {
                                                seq: [
                                                    {
                                                        octstr: {
                                                            hex: p.salt
                                                        }
                                                    },
                                                    {
                                                        "int": {
                                                            hex: inttohex(p.iter)
                                                        }
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        seq: [
                                            {
                                                oid: p.encalg
                                            },
                                            {
                                                octstr: {
                                                    hex: p.enciv
                                                }
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        octstr: {
                            hex: p.enc
                        }
                    }
                ]
            };
            if (p.prf != "hmacWithSHA1") q.seq[0].seq[1].seq[0].seq[1].seq.push({
                seq: [
                    {
                        oid: p.prf
                    },
                    {
                        "null": ""
                    }
                ]
            });
            return q;
        },
        parseHexOfEncryptedPKCS8: function(y) {
            var B = ASN1HEX;
            var z = B.getChildIdx;
            var w = B.getV;
            var t = {};
            var r = z(y, 0);
            if (r.length != 2) throw new Error("malformed format: SEQUENCE(0).items != 2: " + r.length);
            t.ciphertext = w(y, r[1]);
            var A = z(y, r[0]);
            if (A.length != 2) throw new Error("malformed format: SEQUENCE(0.0).items != 2: " + A.length);
            if (w(y, A[0]) != "2a864886f70d01050d") throw new Error("this only supports pkcs5PBES2");
            var p = z(y, A[1]);
            if (A.length != 2) throw new Error("malformed format: SEQUENCE(0.0.1).items != 2: " + p.length);
            var q = z(y, p[1]);
            if (q.length != 2) throw new Error("malformed format: SEQUENCE(0.0.1.1).items != 2: " + q.length);
            if (w(y, q[0]) != "2a864886f70d0307") throw "this only supports TripleDES";
            t.encryptionSchemeAlg = "TripleDES";
            t.encryptionSchemeIV = w(y, q[1]);
            var s = z(y, p[0]);
            if (s.length != 2) throw new Error("malformed format: SEQUENCE(0.0.1.0).items != 2: " + s.length);
            if (w(y, s[0]) != "2a864886f70d01050c") throw new Error("this only supports pkcs5PBKDF2");
            var x = z(y, s[1]);
            if (x.length < 2) throw new Error("malformed format: SEQUENCE(0.0.1.0.1).items < 2: " + x.length);
            t.pbkdf2Salt = w(y, x[0]);
            var u = w(y, x[1]);
            try {
                t.pbkdf2Iter = parseInt(u, 16);
            } catch (v) {
                throw new Error("malformed format pbkdf2Iter: " + u);
            }
            return t;
        },
        getPBKDF2KeyHexFromParam: function(u, p) {
            var t = CryptoJS.enc.Hex.parse(u.pbkdf2Salt);
            var q = u.pbkdf2Iter;
            var s = CryptoJS.PBKDF2(p, t, {
                keySize: 6,
                iterations: q
            });
            var r = CryptoJS.enc.Hex.stringify(s);
            return r;
        },
        _getPlainPKCS8HexFromEncryptedPKCS8PEM: function(x, y) {
            var r = pemtohex(x, "ENCRYPTED PRIVATE KEY");
            var p = this.parseHexOfEncryptedPKCS8(r);
            var u = KEYUTIL.getPBKDF2KeyHexFromParam(p, y);
            var v = {};
            v.ciphertext = CryptoJS.enc.Hex.parse(p.ciphertext);
            var t = CryptoJS.enc.Hex.parse(u);
            var s = CryptoJS.enc.Hex.parse(p.encryptionSchemeIV);
            var w = CryptoJS.TripleDES.decrypt(v, t, {
                iv: s
            });
            var q = CryptoJS.enc.Hex.stringify(w);
            return q;
        },
        parsePBES2: function(z) {
            var v = ASN1HEX.parse(z);
            if (aryval(v, "seq.0.seq.0.oid") != "pkcs5PBES2" || aryval(v, "seq.0.seq.1.seq.0.seq.0.oid") != "pkcs5PBKDF2") throw new Error("not pkcs5PBES2 and pkcs5PBKDF2 used");
            var y = aryval(v, "seq.0.seq.1.seq.0.seq.1.seq");
            if (y == undefined) throw new Error("PBKDF2 parameter not found");
            var t = aryval(y, "0.octstr.hex");
            var p = aryval(y, "1.int.hex");
            var q = aryval(y, "2.seq.0.oid", "hmacWithSHA1");
            var x = -1;
            try {
                x = parseInt(p, 16);
            } catch (w) {
                throw new Error("iter not proper value");
            }
            var u = aryval(v, "seq.0.seq.1.seq.1.seq.0.oid");
            var s = aryval(v, "seq.0.seq.1.seq.1.seq.1.octstr.hex");
            var r = aryval(v, "seq.1.octstr.hex");
            if (u == undefined || s == undefined || r == undefined) throw new Error("encalg, enciv or enc is undefined");
            var A = {
                salt: t,
                iter: x,
                prf: q,
                encalg: u,
                enciv: s,
                enc: r
            };
            return A;
        },
        getDKFromPBES2Param: function(p, w) {
            var x = {
                hmacWithSHA1: CryptoJS.algo.SHA1,
                hmacWithSHA224: CryptoJS.algo.SHA224,
                hmacWithSHA256: CryptoJS.algo.SHA256,
                hmacWithSHA384: CryptoJS.algo.SHA384,
                hmacWithSHA512: CryptoJS.algo.SHA512
            };
            var q = {
                "des-EDE3-CBC": 6,
                "aes128-CBC": 4,
                "aes256-CBC": 8
            };
            var y = x[p.prf];
            if (y == undefined) throw new Error("unsupported prf");
            var r = q[p.encalg];
            if (r == undefined) throw new Error("unsupported encalg");
            var s = CryptoJS.enc.Hex.parse(p.salt);
            var u = p.iter;
            try {
                var v = CryptoJS.PBKDF2(w, s, {
                    keySize: r,
                    iterations: u,
                    hasher: y
                });
                return CryptoJS.enc.Hex.stringify(v);
            } catch (t) {
                throw new Error("PBKDF2 error: " + t + " " + JSON.stringify(p) + " " + w);
            }
        },
        getPlainHexFromEncryptedPKCS8PEM: function(t, q) {
            if (t.indexOf("BEGIN ENCRYPTED PRIVATE KEY") == -1) throw new Error("not Encrypted PKCS#8 PEM string");
            var u = pemtohex(t);
            var p;
            try {
                p = KEYUTIL.parsePBES2(u);
            } catch (r) {
                throw new Error("malformed PBES2 format: " + r.message);
            }
            var s = KEYUTIL.getDKFromPBES2Param(p, q);
            return KJUR.crypto.Cipher.decrypt(p.enc, s, p.encalg, {
                iv: p.enciv
            });
        },
        getKeyFromEncryptedPKCS8PEM: function(s, q) {
            var p = this.getPlainHexFromEncryptedPKCS8PEM(s, q);
            var r = this.getKeyFromPlainPrivatePKCS8Hex(p);
            return r;
        },
        parsePlainPrivatePKCS8Hex: function(s) {
            var v = ASN1HEX;
            var u = v.getChildIdx;
            var t = v.getV;
            var q = {};
            q.algparam = null;
            if (s.substr(0, 2) != "30") throw new Error("malformed plain PKCS8 private key(code:001)");
            var r = u(s, 0);
            if (r.length < 3) throw new Error("malformed plain PKCS8 private key(code:002)");
            if (s.substr(r[1], 2) != "30") throw new Error("malformed PKCS8 private key(code:003)");
            var p = u(s, r[1]);
            if (p.length != 2) throw new Error("malformed PKCS8 private key(code:004)");
            if (s.substr(p[0], 2) != "06") throw new Error("malformed PKCS8 private key(code:005)");
            q.algoid = t(s, p[0]);
            if (s.substr(p[1], 2) == "06") q.algparam = t(s, p[1]);
            if (s.substr(r[2], 2) != "04") throw new Error("malformed PKCS8 private key(code:006)");
            q.keyidx = v.getVidx(s, r[2]);
            return q;
        },
        getKeyFromPlainPrivatePKCS8PEM: function(q) {
            var p = pemtohex(q, "PRIVATE KEY");
            var r = this.getKeyFromPlainPrivatePKCS8Hex(p);
            return r;
        },
        getKeyFromPlainPrivatePKCS8Hex: function(p) {
            var q = this.parsePlainPrivatePKCS8Hex(p);
            var r;
            if (q.algoid == "2a864886f70d010101") r = new RSAKey();
            else if (q.algoid == "2a8648ce380401") r = new KJUR.crypto.DSA();
            else {
                if (q.algoid == "2a8648ce3d0201") r = new KJUR.crypto.ECDSA();
                else throw new Error("unsupported private key algorithm");
            }
            r.readPKCS8PrvKeyHex(p);
            return r;
        },
        _getKeyFromPublicPKCS8Hex: function(q) {
            var p;
            var r = ASN1HEX.getVbyList(q, 0, [
                0,
                0
            ], "06");
            if (r === "2a864886f70d010101") p = new RSAKey();
            else if (r === "2a8648ce380401") p = new KJUR.crypto.DSA();
            else {
                if (r === "2a8648ce3d0201") p = new KJUR.crypto.ECDSA();
                else throw new Error("unsupported PKCS#8 public key hex");
            }
            p.readPKCS8PubKeyHex(q);
            return p;
        },
        parsePublicRawRSAKeyHex: function(r) {
            var u = ASN1HEX;
            var t = u.getChildIdx;
            var s = u.getV;
            var p = {};
            if (r.substr(0, 2) != "30") throw new Error("malformed RSA key(code:001)");
            var q = t(r, 0);
            if (q.length != 2) throw new Error("malformed RSA key(code:002)");
            if (r.substr(q[0], 2) != "02") throw new Error("malformed RSA key(code:003)");
            p.n = s(r, q[0]);
            if (r.substr(q[1], 2) != "02") throw new Error("malformed RSA key(code:004)");
            p.e = s(r, q[1]);
            return p;
        },
        parsePublicPKCS8Hex: function(t) {
            var v = ASN1HEX;
            var u = v.getChildIdx;
            var s = v.getV;
            var q = {};
            q.algparam = null;
            var r = u(t, 0);
            if (r.length != 2) throw new Error("outer DERSequence shall have 2 elements: " + r.length);
            var w = r[0];
            if (t.substr(w, 2) != "30") throw new Error("malformed PKCS8 public key(code:001)");
            var p = u(t, w);
            if (p.length != 2) throw new Error("malformed PKCS8 public key(code:002)");
            if (t.substr(p[0], 2) != "06") throw new Error("malformed PKCS8 public key(code:003)");
            q.algoid = s(t, p[0]);
            if (t.substr(p[1], 2) == "06") q.algparam = s(t, p[1]);
            else if (t.substr(p[1], 2) == "30") {
                q.algparam = {};
                q.algparam.p = v.getVbyList(t, p[1], [
                    0
                ], "02");
                q.algparam.q = v.getVbyList(t, p[1], [
                    1
                ], "02");
                q.algparam.g = v.getVbyList(t, p[1], [
                    2
                ], "02");
            }
            if (t.substr(r[1], 2) != "03") throw new Error("malformed PKCS8 public key(code:004)");
            q.key = s(t, r[1]).substr(2);
            return q;
        }
    };
}();
KEYUTIL.getKey = function(l, k, n) {
    var G = ASN1HEX, L = G.getChildIdx, v = G.getV, d = G.getVbyList, c = KJUR.crypto, i = c.ECDSA, C = c.DSA, w = RSAKey, M = pemtohex, F = KEYUTIL;
    if (typeof w != "undefined" && l instanceof w) return l;
    if (typeof i != "undefined" && l instanceof i) return l;
    if (typeof C != "undefined" && l instanceof C) return l;
    if (l.curve !== undefined && l.xy !== undefined && l.d === undefined) return new i({
        pub: l.xy,
        curve: l.curve
    });
    if (l.curve !== undefined && l.d !== undefined) return new i({
        prv: l.d,
        curve: l.curve
    });
    if (l.kty === undefined && l.n !== undefined && l.e !== undefined && l.d === undefined) {
        var P = new w();
        P.setPublic(l.n, l.e);
        return P;
    }
    if (l.kty === undefined && l.n !== undefined && l.e !== undefined && l.d !== undefined && l.p !== undefined && l.q !== undefined && l.dp !== undefined && l.dq !== undefined && l.co !== undefined && l.qi === undefined) {
        var P = new w();
        P.setPrivateEx(l.n, l.e, l.d, l.p, l.q, l.dp, l.dq, l.co);
        return P;
    }
    if (l.kty === undefined && l.n !== undefined && l.e !== undefined && l.d !== undefined && l.p === undefined) {
        var P = new w();
        P.setPrivate(l.n, l.e, l.d);
        return P;
    }
    if (l.p !== undefined && l.q !== undefined && l.g !== undefined && l.y !== undefined && l.x === undefined) {
        var P = new C();
        P.setPublic(l.p, l.q, l.g, l.y);
        return P;
    }
    if (l.p !== undefined && l.q !== undefined && l.g !== undefined && l.y !== undefined && l.x !== undefined) {
        var P = new C();
        P.setPrivate(l.p, l.q, l.g, l.y, l.x);
        return P;
    }
    if (l.kty === "RSA" && l.n !== undefined && l.e !== undefined && l.d === undefined) {
        var P = new w();
        P.setPublic(b64utohex(l.n), b64utohex(l.e));
        return P;
    }
    if (l.kty === "RSA" && l.n !== undefined && l.e !== undefined && l.d !== undefined && l.p !== undefined && l.q !== undefined && l.dp !== undefined && l.dq !== undefined && l.qi !== undefined) {
        var P = new w();
        P.setPrivateEx(b64utohex(l.n), b64utohex(l.e), b64utohex(l.d), b64utohex(l.p), b64utohex(l.q), b64utohex(l.dp), b64utohex(l.dq), b64utohex(l.qi));
        return P;
    }
    if (l.kty === "RSA" && l.n !== undefined && l.e !== undefined && l.d !== undefined) {
        var P = new w();
        P.setPrivate(b64utohex(l.n), b64utohex(l.e), b64utohex(l.d));
        return P;
    }
    if (l.kty === "EC" && l.crv !== undefined && l.x !== undefined && l.y !== undefined && l.d === undefined) {
        var j = new i({
            curve: l.crv
        });
        var t = j.ecparams.keycharlen;
        var B = ("0000000000" + b64utohex(l.x)).slice(-t);
        var z = ("0000000000" + b64utohex(l.y)).slice(-t);
        var u = "04" + B + z;
        j.setPublicKeyHex(u);
        return j;
    }
    if (l.kty === "EC" && l.crv !== undefined && l.x !== undefined && l.y !== undefined && l.d !== undefined) {
        var j = new i({
            curve: l.crv
        });
        var t = j.ecparams.keycharlen;
        var B = ("0000000000" + b64utohex(l.x)).slice(-t);
        var z = ("0000000000" + b64utohex(l.y)).slice(-t);
        var u = "04" + B + z;
        var b = ("0000000000" + b64utohex(l.d)).slice(-t);
        j.setPublicKeyHex(u);
        j.setPrivateKeyHex(b);
        return j;
    }
    if (n === "pkcs5prv") {
        var J = l, G = ASN1HEX, N, P;
        N = L(J, 0);
        if (N.length === 9) {
            P = new w();
            P.readPKCS5PrvKeyHex(J);
        } else if (N.length === 6) {
            P = new C();
            P.readPKCS5PrvKeyHex(J);
        } else {
            if (N.length > 2 && J.substr(N[1], 2) === "04") {
                P = new i();
                P.readPKCS5PrvKeyHex(J);
            } else throw new Error("unsupported PKCS#1/5 hexadecimal key");
        }
        return P;
    }
    if (n === "pkcs8prv") {
        var P = F.getKeyFromPlainPrivatePKCS8Hex(l);
        return P;
    }
    if (n === "pkcs8pub") return F._getKeyFromPublicPKCS8Hex(l);
    if (n === "x509pub") return X509.getPublicKeyFromCertHex(l);
    if (l.indexOf("-END CERTIFICATE-", 0) != -1 || l.indexOf("-END X509 CERTIFICATE-", 0) != -1 || l.indexOf("-END TRUSTED CERTIFICATE-", 0) != -1) return X509.getPublicKeyFromCertPEM(l);
    if (l.indexOf("-END PUBLIC KEY-") != -1) {
        var O = pemtohex(l, "PUBLIC KEY");
        return F._getKeyFromPublicPKCS8Hex(O);
    }
    if (l.indexOf("-END RSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
        var m = M(l, "RSA PRIVATE KEY");
        return F.getKey(m, null, "pkcs5prv");
    }
    if (l.indexOf("-END DSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
        var I = M(l, "DSA PRIVATE KEY");
        var E = d(I, 0, [
            1
        ], "02");
        var D = d(I, 0, [
            2
        ], "02");
        var K = d(I, 0, [
            3
        ], "02");
        var r = d(I, 0, [
            4
        ], "02");
        var s = d(I, 0, [
            5
        ], "02");
        var P = new C();
        P.setPrivate(new BigInteger(E, 16), new BigInteger(D, 16), new BigInteger(K, 16), new BigInteger(r, 16), new BigInteger(s, 16));
        return P;
    }
    if (l.indexOf("-END EC PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
        var m = M(l, "EC PRIVATE KEY");
        return F.getKey(m, null, "pkcs5prv");
    }
    if (l.indexOf("-END PRIVATE KEY-") != -1) return F.getKeyFromPlainPrivatePKCS8PEM(l);
    if (l.indexOf("-END RSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
        var o = F.getDecryptedKeyHex(l, k);
        var H = new RSAKey();
        H.readPKCS5PrvKeyHex(o);
        return H;
    }
    if (l.indexOf("-END EC PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
        var I = F.getDecryptedKeyHex(l, k);
        var P = d(I, 0, [
            1
        ], "04");
        var f = d(I, 0, [
            2,
            0
        ], "06");
        var A = d(I, 0, [
            3,
            0
        ], "03").substr(2);
        var e = "";
        if (KJUR.crypto.OID.oidhex2name[f] !== undefined) e = KJUR.crypto.OID.oidhex2name[f];
        else throw new Error("undefined OID(hex) in KJUR.crypto.OID: " + f);
        var j = new i({
            curve: e
        });
        j.setPublicKeyHex(A);
        j.setPrivateKeyHex(P);
        j.isPublic = false;
        return j;
    }
    if (l.indexOf("-END DSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
        var I = F.getDecryptedKeyHex(l, k);
        var E = d(I, 0, [
            1
        ], "02");
        var D = d(I, 0, [
            2
        ], "02");
        var K = d(I, 0, [
            3
        ], "02");
        var r = d(I, 0, [
            4
        ], "02");
        var s = d(I, 0, [
            5
        ], "02");
        var P = new C();
        P.setPrivate(new BigInteger(E, 16), new BigInteger(D, 16), new BigInteger(K, 16), new BigInteger(r, 16), new BigInteger(s, 16));
        return P;
    }
    if (l.indexOf("-END ENCRYPTED PRIVATE KEY-") != -1) return F.getKeyFromEncryptedPKCS8PEM(l, k);
    throw new Error("not supported argument");
};
KEYUTIL.generateKeypair = function(a, c) {
    if (a == "RSA") {
        var b = c;
        var h = new RSAKey();
        h.generate(b, "10001");
        h.isPrivate = true;
        h.isPublic = true;
        var f = new RSAKey();
        var e = h.n.toString(16);
        var i = h.e.toString(16);
        f.setPublic(e, i);
        f.isPrivate = false;
        f.isPublic = true;
        var k = {};
        k.prvKeyObj = h;
        k.pubKeyObj = f;
        return k;
    } else {
        if (a == "EC") {
            var d = c;
            var g = new KJUR.crypto.ECDSA({
                curve: d
            });
            var j = g.generateKeyPairHex();
            var h = new KJUR.crypto.ECDSA({
                curve: d
            });
            h.setPublicKeyHex(j.ecpubhex);
            h.setPrivateKeyHex(j.ecprvhex);
            h.isPrivate = true;
            h.isPublic = false;
            var f = new KJUR.crypto.ECDSA({
                curve: d
            });
            f.setPublicKeyHex(j.ecpubhex);
            f.isPrivate = false;
            f.isPublic = true;
            var k = {};
            k.prvKeyObj = h;
            k.pubKeyObj = f;
            return k;
        } else throw new Error("unknown algorithm: " + a);
    }
};
KEYUTIL.getPEM = function(b, C, x, m, p, j) {
    var E = KJUR, k = E.asn1, y = k.DERObjectIdentifier, e = k.DERInteger, l = k.ASN1Util.newObject, a = k.x509, B = a.SubjectPublicKeyInfo, d = E.crypto, t = d.DSA, q = d.ECDSA, n = RSAKey;
    function z(s) {
        var G = l({
            seq: [
                {
                    "int": 0
                },
                {
                    "int": {
                        bigint: s.n
                    }
                },
                {
                    "int": s.e
                },
                {
                    "int": {
                        bigint: s.d
                    }
                },
                {
                    "int": {
                        bigint: s.p
                    }
                },
                {
                    "int": {
                        bigint: s.q
                    }
                },
                {
                    "int": {
                        bigint: s.dmp1
                    }
                },
                {
                    "int": {
                        bigint: s.dmq1
                    }
                },
                {
                    "int": {
                        bigint: s.coeff
                    }
                }
            ]
        });
        return G;
    }
    function A(G) {
        var s = l({
            seq: [
                {
                    "int": 1
                },
                {
                    octstr: {
                        hex: G.prvKeyHex
                    }
                },
                {
                    tag: [
                        "a0",
                        true,
                        {
                            oid: {
                                name: G.curveName
                            }
                        }
                    ]
                },
                {
                    tag: [
                        "a1",
                        true,
                        {
                            bitstr: {
                                hex: "00" + G.pubKeyHex
                            }
                        }
                    ]
                }
            ]
        });
        return s;
    }
    function w(s) {
        var G = l({
            seq: [
                {
                    "int": 0
                },
                {
                    "int": {
                        bigint: s.p
                    }
                },
                {
                    "int": {
                        bigint: s.q
                    }
                },
                {
                    "int": {
                        bigint: s.g
                    }
                },
                {
                    "int": {
                        bigint: s.y
                    }
                },
                {
                    "int": {
                        bigint: s.x
                    }
                }
            ]
        });
        return G;
    }
    if ((n !== undefined && b instanceof n || t !== undefined && b instanceof t || q !== undefined && b instanceof q) && b.isPublic == true && (C === undefined || C == "PKCS8PUB")) {
        var D = new B(b);
        var v = D.tohex();
        return hextopem(v, "PUBLIC KEY");
    }
    if (C == "PKCS1PRV" && n !== undefined && b instanceof n && (x === undefined || x == null) && b.isPrivate == true) {
        var D = z(b);
        var v = D.tohex();
        return hextopem(v, "RSA PRIVATE KEY");
    }
    if (C == "PKCS1PRV" && q !== undefined && b instanceof q && (x === undefined || x == null) && b.isPrivate == true) {
        var i = new y({
            name: b.curveName
        });
        var u = i.tohex();
        var h = A(b);
        var r = h.tohex();
        var o = "";
        o += hextopem(u, "EC PARAMETERS");
        o += hextopem(r, "EC PRIVATE KEY");
        return o;
    }
    if (C == "PKCS1PRV" && t !== undefined && b instanceof t && (x === undefined || x == null) && b.isPrivate == true) {
        var D = w(b);
        var v = D.tohex();
        return hextopem(v, "DSA PRIVATE KEY");
    }
    if (C == "PKCS5PRV" && n !== undefined && b instanceof n && x !== undefined && x != null && b.isPrivate == true) {
        var D = z(b);
        var v = D.tohex();
        if (m === undefined) m = "DES-EDE3-CBC";
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA", v, x, m, j);
    }
    if (C == "PKCS5PRV" && q !== undefined && b instanceof q && x !== undefined && x != null && b.isPrivate == true) {
        var D = A(b);
        var v = D.tohex();
        if (m === undefined) m = "DES-EDE3-CBC";
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("EC", v, x, m, j);
    }
    if (C == "PKCS5PRV" && t !== undefined && b instanceof t && x !== undefined && x != null && b.isPrivate == true) {
        var D = w(b);
        var v = D.tohex();
        if (m === undefined) m = "DES-EDE3-CBC";
        return this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA", v, x, m, j);
    }
    var f = function(G, H) {
        if (typeof H == "string") return KEYUTIL.getEncryptedPKCS8PEM(G, H);
        else if (typeof H == "object" && aryval(H, "passcode") != undefined) {
            var I = JSON.parse(JSON.stringify(H));
            var s = I.passcode;
            delete I.passcode;
            return KEYUTIL.getEncryptedPKCS8PEM(G, s, I);
        }
    };
    if (C == "PKCS8PRV" && n != undefined && b instanceof n && b.isPrivate == true) {
        var g = z(b);
        var c = g.tohex();
        var D = l({
            seq: [
                {
                    "int": 0
                },
                {
                    seq: [
                        {
                            oid: {
                                name: "rsaEncryption"
                            }
                        },
                        {
                            "null": true
                        }
                    ]
                },
                {
                    octstr: {
                        hex: c
                    }
                }
            ]
        });
        var v = D.tohex();
        if (x === undefined || x == null) return hextopem(v, "PRIVATE KEY");
        else return f(v, x);
    }
    if (C == "PKCS8PRV" && q !== undefined && b instanceof q && b.isPrivate == true) {
        var F = {
            seq: [
                {
                    "int": 1
                },
                {
                    octstr: {
                        hex: b.prvKeyHex
                    }
                }
            ]
        };
        if (typeof b.pubKeyHex == "string") F.seq.push({
            tag: [
                "a1",
                true,
                {
                    bitstr: {
                        hex: "00" + b.pubKeyHex
                    }
                }
            ]
        });
        var g = new l(F);
        var c = g.tohex();
        var D = l({
            seq: [
                {
                    "int": 0
                },
                {
                    seq: [
                        {
                            oid: {
                                name: "ecPublicKey"
                            }
                        },
                        {
                            oid: {
                                name: b.curveName
                            }
                        }
                    ]
                },
                {
                    octstr: {
                        hex: c
                    }
                }
            ]
        });
        var v = D.tohex();
        if (x === undefined || x == null) return hextopem(v, "PRIVATE KEY");
        else return f(v, x);
    }
    if (C == "PKCS8PRV" && t !== undefined && b instanceof t && b.isPrivate == true) {
        var g = new e({
            bigint: b.x
        });
        var c = g.tohex();
        var D = l({
            seq: [
                {
                    "int": 0
                },
                {
                    seq: [
                        {
                            oid: {
                                name: "dsa"
                            }
                        },
                        {
                            seq: [
                                {
                                    "int": {
                                        bigint: b.p
                                    }
                                },
                                {
                                    "int": {
                                        bigint: b.q
                                    }
                                },
                                {
                                    "int": {
                                        bigint: b.g
                                    }
                                }
                            ]
                        }
                    ]
                },
                {
                    octstr: {
                        hex: c
                    }
                }
            ]
        });
        var v = D.tohex();
        if (x === undefined || x == null) return hextopem(v, "PRIVATE KEY");
        else return f(v, x);
    }
    throw new Error("unsupported object nor format");
};
KEYUTIL.getKeyFromCSRPEM = function(b) {
    var a = pemtohex(b, "CERTIFICATE REQUEST");
    var c = KEYUTIL.getKeyFromCSRHex(a);
    return c;
};
KEYUTIL.getKeyFromCSRHex = function(a) {
    var c = KEYUTIL.parseCSRHex(a);
    var b = KEYUTIL.getKey(c.p8pubkeyhex, null, "pkcs8pub");
    return b;
};
KEYUTIL.parseCSRHex = function(d) {
    var i = ASN1HEX;
    var f = i.getChildIdx;
    var c = i.getTLV;
    var b = {};
    var g = d;
    if (g.substr(0, 2) != "30") throw new Error("malformed CSR(code:001)");
    var e = f(g, 0);
    if (e.length < 1) throw new Error("malformed CSR(code:002)");
    if (g.substr(e[0], 2) != "30") throw new Error("malformed CSR(code:003)");
    var a = f(g, e[0]);
    if (a.length < 3) throw new Error("malformed CSR(code:004)");
    b.p8pubkeyhex = c(g, a[2]);
    return b;
};
KEYUTIL.getKeyID = function(f) {
    var c = KEYUTIL;
    var e = ASN1HEX;
    if (typeof f === "string" && f.indexOf("BEGIN ") != -1) f = c.getKey(f);
    var d = pemtohex(c.getPEM(f));
    var b = e.getIdxbyList(d, 0, [
        1
    ]);
    var a = e.getV(d, b).substring(2);
    return KJUR.crypto.Util.hashHex(a, "sha1");
};
KEYUTIL.getJWK = function(d, h, g, b, f) {
    var i;
    var k = {};
    var e;
    var c = KJUR.crypto.Util.hashHex;
    if (typeof d == "string") {
        i = KEYUTIL.getKey(d);
        if (d.indexOf("CERTIFICATE") != -1) e = pemtohex(d);
    } else {
        if (typeof d == "object") {
            if (d instanceof X509) {
                i = d.getPublicKey();
                e = d.hex;
            } else i = d;
        } else throw new Error("unsupported keyinfo type");
    }
    if (i instanceof RSAKey && i.isPrivate) {
        k.kty = "RSA";
        k.n = hextob64u(i.n.toString(16));
        k.e = hextob64u(i.e.toString(16));
        k.d = hextob64u(i.d.toString(16));
        k.p = hextob64u(i.p.toString(16));
        k.q = hextob64u(i.q.toString(16));
        k.dp = hextob64u(i.dmp1.toString(16));
        k.dq = hextob64u(i.dmq1.toString(16));
        k.qi = hextob64u(i.coeff.toString(16));
    } else if (i instanceof RSAKey && i.isPublic) {
        k.kty = "RSA";
        k.n = hextob64u(i.n.toString(16));
        k.e = hextob64u(i.e.toString(16));
    } else {
        if (i instanceof KJUR.crypto.ECDSA && i.isPrivate) {
            var a = i.getShortNISTPCurveName();
            if (a !== "P-256" && a !== "P-384" && a !== "P-521") throw new Error("unsupported curve name for JWT: " + a);
            var j = i.getPublicKeyXYHex();
            k.kty = "EC";
            k.crv = a;
            k.x = hextob64u(j.x);
            k.y = hextob64u(j.y);
            k.d = hextob64u(i.prvKeyHex);
        } else if (i instanceof KJUR.crypto.ECDSA && i.isPublic) {
            var a = i.getShortNISTPCurveName();
            if (a !== "P-256" && a !== "P-384" && a !== "P-521") throw new Error("unsupported curve name for JWT: " + a);
            var j = i.getPublicKeyXYHex();
            k.kty = "EC";
            k.crv = a;
            k.x = hextob64u(j.x);
            k.y = hextob64u(j.y);
        }
    }
    if (k.kty == undefined) throw new Error("unsupported keyinfo");
    if (!i.isPrivate && h != true) k.kid = KJUR.jws.JWS.getJWKthumbprint(k);
    if (e != undefined && g != true) k.x5c = [
        hex2b64(e)
    ];
    if (e != undefined && b != true) k.x5t = b64tob64u(hex2b64(c(e, "sha1")));
    if (e != undefined && f != true) k["x5t#S256"] = b64tob64u(hex2b64(c(e, "sha256")));
    return k;
};
KEYUTIL.getJWKFromKey = function(a) {
    return KEYUTIL.getJWK(a, true, true, true, true);
};
RSAKey.getPosArrayOfChildrenFromHex = function(a) {
    return ASN1HEX.getChildIdx(a, 0);
};
RSAKey.getHexValueArrayOfChildrenFromHex = function(f) {
    var n = ASN1HEX;
    var i = n.getV;
    var k = RSAKey.getPosArrayOfChildrenFromHex(f);
    var e = i(f, k[0]);
    var j = i(f, k[1]);
    var b = i(f, k[2]);
    var c = i(f, k[3]);
    var h = i(f, k[4]);
    var g = i(f, k[5]);
    var m = i(f, k[6]);
    var l = i(f, k[7]);
    var d = i(f, k[8]);
    var k = new Array();
    k.push(e, j, b, c, h, g, m, l, d);
    return k;
};
RSAKey.prototype.readPrivateKeyFromPEMString = function(d) {
    var c = pemtohex(d);
    var b = RSAKey.getHexValueArrayOfChildrenFromHex(c);
    this.setPrivateEx(b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
};
RSAKey.prototype.readPKCS5PrvKeyHex = function(c) {
    var b = RSAKey.getHexValueArrayOfChildrenFromHex(c);
    this.setPrivateEx(b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8]);
};
RSAKey.prototype.readPKCS8PrvKeyHex = function(e) {
    var c, i, k, b, a, f, d, j;
    var m = ASN1HEX;
    var l = m.getVbyListEx;
    if (m.isASN1HEX(e) === false) throw new Error("not ASN.1 hex string");
    try {
        c = l(e, 0, [
            2,
            0,
            1
        ], "02");
        i = l(e, 0, [
            2,
            0,
            2
        ], "02");
        k = l(e, 0, [
            2,
            0,
            3
        ], "02");
        b = l(e, 0, [
            2,
            0,
            4
        ], "02");
        a = l(e, 0, [
            2,
            0,
            5
        ], "02");
        f = l(e, 0, [
            2,
            0,
            6
        ], "02");
        d = l(e, 0, [
            2,
            0,
            7
        ], "02");
        j = l(e, 0, [
            2,
            0,
            8
        ], "02");
    } catch (g) {
        throw new Error("malformed PKCS#8 plain RSA private key");
    }
    this.setPrivateEx(c, i, k, b, a, f, d, j);
};
RSAKey.prototype.readPKCS5PubKeyHex = function(c) {
    var e = ASN1HEX;
    var b = e.getV;
    if (e.isASN1HEX(c) === false) throw new Error("keyHex is not ASN.1 hex string");
    var a = e.getChildIdx(c, 0);
    if (a.length !== 2 || c.substr(a[0], 2) !== "02" || c.substr(a[1], 2) !== "02") throw new Error("wrong hex for PKCS#5 public key");
    var f = b(c, a[0]);
    var d = b(c, a[1]);
    this.setPublic(f, d);
};
RSAKey.prototype.readPKCS8PubKeyHex = function(b) {
    var c = ASN1HEX;
    if (c.isASN1HEX(b) === false) throw new Error("not ASN.1 hex string");
    if (c.getTLVbyListEx(b, 0, [
        0,
        0
    ]) !== "06092a864886f70d010101") throw new Error("not PKCS8 RSA public key");
    var a = c.getTLVbyListEx(b, 0, [
        1,
        0
    ]);
    this.readPKCS5PubKeyHex(a);
};
RSAKey.prototype.readCertPubKeyHex = function(b, d) {
    var a, c;
    a = new X509();
    a.readCertHex(b);
    c = a.getPublicKeyHex();
    this.readPKCS8PubKeyHex(c);
};
var _RE_HEXDECONLY = new RegExp("[^0-9a-f]", "gi");
function _rsasign_getHexPaddedDigestInfoForString(d, e, a) {
    var b = function(f) {
        return KJUR.crypto.Util.hashString(f, a);
    };
    var c = b(d);
    return KJUR.crypto.Util.getPaddedDigestInfoHex(c, a, e);
}
function _zeroPaddingOfSignature(e, d) {
    var c = "";
    var a = d / 4 - e.length;
    for(var b = 0; b < a; b++)c = c + "0";
    return c + e;
}
RSAKey.prototype.sign = function(d, a) {
    var b = function(e) {
        return KJUR.crypto.Util.hashString(e, a);
    };
    var c = b(d);
    return this.signWithMessageHash(c, a);
};
RSAKey.prototype.signWithMessageHash = function(e, c) {
    var f = KJUR.crypto.Util.getPaddedDigestInfoHex(e, c, this.n.bitLength());
    var b = parseBigInt(f, 16);
    var d = this.doPrivate(b);
    var a = d.toString(16);
    return _zeroPaddingOfSignature(a, this.n.bitLength());
};
function pss_mgf1_str(c, a, e) {
    var b = "", d = 0;
    while(b.length < a){
        b += hextorstr(e(rstrtohex(c + String.fromCharCode.apply(String, [
            (d & 4278190080) >> 24,
            (d & 16711680) >> 16,
            (d & 65280) >> 8,
            d & 255
        ]))));
        d += 1;
    }
    return b;
}
RSAKey.prototype.signPSS = function(e, a, d) {
    var c = function(f) {
        return KJUR.crypto.Util.hashHex(f, a);
    };
    var b = c(rstrtohex(e));
    if (d === undefined) d = -1;
    return this.signWithMessageHashPSS(b, a, d);
};
RSAKey.prototype.signWithMessageHashPSS = function(l, a, k) {
    var b = hextorstr(l);
    var g = b.length;
    var m = this.n.bitLength() - 1;
    var c = Math.ceil(m / 8);
    var d;
    var o = function(i) {
        return KJUR.crypto.Util.hashHex(i, a);
    };
    if (k === -1 || k === undefined) k = g;
    else if (k === -2) k = c - g - 2;
    else {
        if (k < -2) throw new Error("invalid salt length");
    }
    if (c < g + k + 2) throw new Error("data too long");
    var f = "";
    if (k > 0) {
        f = new Array(k);
        new SecureRandom().nextBytes(f);
        f = String.fromCharCode.apply(String, f);
    }
    var n = hextorstr(o(rstrtohex("\0\0\0\0\0\0\0\0" + b + f)));
    var j = [];
    for(d = 0; d < c - k - g - 2; d += 1)j[d] = 0;
    var e = String.fromCharCode.apply(String, j) + "\x01" + f;
    var h = pss_mgf1_str(n, e.length, o);
    var q = [];
    for(d = 0; d < e.length; d += 1)q[d] = e.charCodeAt(d) ^ h.charCodeAt(d);
    var p = 65280 >> 8 * c - m & 255;
    q[0] &= ~p;
    for(d = 0; d < g; d++)q.push(n.charCodeAt(d));
    q.push(188);
    return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16), this.n.bitLength());
};
function _rsasign_getDecryptSignatureBI(a, d, c) {
    var b = new RSAKey();
    b.setPublic(d, c);
    var e = b.doPublic(a);
    return e;
}
function _rsasign_getHexDigestInfoFromSig(a, c, b) {
    var e = _rsasign_getDecryptSignatureBI(a, c, b);
    var d = e.toString(16).replace(/^1f+00/, "");
    return d;
}
function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f) {
    for(var e in KJUR.crypto.Util.DIGESTINFOHEAD){
        var d = KJUR.crypto.Util.DIGESTINFOHEAD[e];
        var b = d.length;
        if (f.substring(0, b) == d) {
            var c = [
                e,
                f.substring(b)
            ];
            return c;
        }
    }
    return [];
}
RSAKey.prototype.verify = function(f, l) {
    l = l.toLowerCase();
    if (l.match(/^[0-9a-f]+$/) == null) return false;
    var b = parseBigInt(l, 16);
    var k = this.n.bitLength();
    if (b.bitLength() > k) return false;
    var j = this.doPublic(b);
    var i = j.toString(16);
    if (i.length + 3 != k / 4) return false;
    var e = i.replace(/^1f+00/, "");
    var g = _rsasign_getAlgNameAndHashFromHexDisgestInfo(e);
    if (g.length == 0) return false;
    var d = g[0];
    var h = g[1];
    var a = function(m) {
        return KJUR.crypto.Util.hashString(m, d);
    };
    var c = a(f);
    return h == c;
};
RSAKey.prototype.verifyWithMessageHash = function(e, a) {
    if (a.length != Math.ceil(this.n.bitLength() / 4)) return false;
    var b = parseBigInt(a, 16);
    if (b.bitLength() > this.n.bitLength()) return 0;
    var h = this.doPublic(b);
    var g = h.toString(16).replace(/^1f+00/, "");
    var c = _rsasign_getAlgNameAndHashFromHexDisgestInfo(g);
    if (c.length == 0) return false;
    var d = c[0];
    var f = c[1];
    return f == e;
};
RSAKey.prototype.verifyPSS = function(c, b, a, f) {
    var e = function(g) {
        return KJUR.crypto.Util.hashHex(g, a);
    };
    var d = e(rstrtohex(c));
    if (f === undefined) f = -1;
    return this.verifyWithMessageHashPSS(d, b, a, f);
};
RSAKey.prototype.verifyWithMessageHashPSS = function(f, s, l, c) {
    if (s.length != Math.ceil(this.n.bitLength() / 4)) return false;
    var k = new BigInteger(s, 16);
    var r = function(i) {
        return KJUR.crypto.Util.hashHex(i, l);
    };
    var j = hextorstr(f);
    var h = j.length;
    var g = this.n.bitLength() - 1;
    var m = Math.ceil(g / 8);
    var q;
    if (c === -1 || c === undefined) c = h;
    else if (c === -2) c = m - h - 2;
    else {
        if (c < -2) throw new Error("invalid salt length");
    }
    if (m < h + c + 2) throw new Error("data too long");
    var a = this.doPublic(k).toByteArray();
    for(q = 0; q < a.length; q += 1)a[q] &= 255;
    while(a.length < m)a.unshift(0);
    if (a[m - 1] !== 188) throw new Error("encoded message does not end in 0xbc");
    a = String.fromCharCode.apply(String, a);
    var d = a.substr(0, m - h - 1);
    var e = a.substr(d.length, h);
    var p = 65280 >> 8 * m - g & 255;
    if ((d.charCodeAt(0) & p) !== 0) throw new Error("bits beyond keysize not zero");
    var n = pss_mgf1_str(e, d.length, r);
    var o = [];
    for(q = 0; q < d.length; q += 1)o[q] = d.charCodeAt(q) ^ n.charCodeAt(q);
    o[0] &= ~p;
    var b = m - h - c - 2;
    for(q = 0; q < b; q += 1){
        if (o[q] !== 0) throw new Error("leftmost octets not zero");
    }
    if (o[b] !== 1) throw new Error("0x01 marker not found");
    return e === hextorstr(r(rstrtohex("\0\0\0\0\0\0\0\0" + j + String.fromCharCode.apply(String, o.slice(-c)))));
};
RSAKey.SALT_LEN_HLEN = -1;
RSAKey.SALT_LEN_MAX = -2;
RSAKey.SALT_LEN_RECOVER = -2;
function X509(v) {
    var o = ASN1HEX, s = o.getChildIdx, k = o.getV, y = o.dump, j = o.parse, b = o.getTLV, c = o.getVbyList, p = o.getVbyListEx, a = o.getTLVbyList, q = o.getTLVbyListEx, l = o.getIdxbyList, f = o.getIdxbyListEx, n = o.getVidx, x = o.getInt, u = o.oidname, r = o.hextooidstr, d = X509, w = pemtohex, g, m = Error;
    try {
        g = KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
    } catch (t) {}
    this.HEX2STAG = {
        "0c": "utf8",
        "13": "prn",
        "16": "ia5",
        "1a": "vis",
        "1e": "bmp"
    };
    this.hex = null;
    this.version = 0;
    this.foffset = 0;
    this.aExtInfo = null;
    this.getVersion = function() {
        if (this.hex === null || this.version !== 0) return this.version;
        var A = a(this.hex, 0, [
            0,
            0
        ]);
        if (A.substr(0, 2) == "a0") {
            var B = a(A, 0, [
                0
            ]);
            var z = x(B, 0);
            if (z < 0 || 2 < z) throw new Error("malformed version field");
            this.version = z + 1;
            return this.version;
        } else {
            this.version = 1;
            this.foffset = -1;
            return 1;
        }
    };
    this.getSerialNumberHex = function() {
        return p(this.hex, 0, [
            0,
            0
        ], "02");
    };
    this.getSignatureAlgorithmField = function() {
        var z = q(this.hex, 0, [
            0,
            1
        ]);
        return this.getAlgorithmIdentifierName(z);
    };
    this.getAlgorithmIdentifierName = function(z) {
        for(var A in g){
            if (z === g[A]) return A;
        }
        return u(p(z, 0, [
            0
        ], "06"));
    };
    this.getIssuer = function(A, z) {
        return this.getX500Name(this.getIssuerHex(), A, z);
    };
    this.getIssuerHex = function() {
        return a(this.hex, 0, [
            0,
            3 + this.foffset
        ], "30");
    };
    this.getIssuerString = function() {
        var z = this.getIssuer();
        return z.str;
    };
    this.getSubject = function(A, z) {
        return this.getX500Name(this.getSubjectHex(), A, z);
    };
    this.getSubjectHex = function() {
        return a(this.hex, 0, [
            0,
            5 + this.foffset
        ], "30");
    };
    this.getSubjectString = function() {
        var z = this.getSubject();
        return z.str;
    };
    this.getNotBefore = function() {
        var z = c(this.hex, 0, [
            0,
            4 + this.foffset,
            0
        ]);
        z = z.replace(/(..)/g, "%$1");
        z = decodeURIComponent(z);
        return z;
    };
    this.getNotAfter = function() {
        var z = c(this.hex, 0, [
            0,
            4 + this.foffset,
            1
        ]);
        z = z.replace(/(..)/g, "%$1");
        z = decodeURIComponent(z);
        return z;
    };
    this.getPublicKeyHex = function() {
        return this.getSPKI();
    };
    this.getSPKI = function() {
        return a(this.hex, 0, [
            0,
            6 + this.foffset
        ], "30");
    };
    this.getSPKIValue = function() {
        var z = this.getSPKI();
        if (z == null) return null;
        return c(z, 0, [
            1
        ], "03", true);
    };
    this.getPublicKeyIdx = function() {
        return l(this.hex, 0, [
            0,
            6 + this.foffset
        ], "30");
    };
    this.getPublicKeyContentIdx = function() {
        var z = this.getPublicKeyIdx();
        return l(this.hex, z, [
            1,
            0
        ], "30");
    };
    this.getPublicKey = function() {
        return KEYUTIL.getKey(this.getPublicKeyHex(), null, "pkcs8pub");
    };
    this.getSignatureAlgorithmName = function() {
        var z = a(this.hex, 0, [
            1
        ], "30");
        return this.getAlgorithmIdentifierName(z);
    };
    this.getSignatureValueHex = function() {
        return c(this.hex, 0, [
            2
        ], "03", true);
    };
    this.verifySignature = function(B) {
        var C = this.getSignatureAlgorithmField();
        var z = this.getSignatureValueHex();
        var A = a(this.hex, 0, [
            0
        ], "30");
        var D = new KJUR.crypto.Signature({
            alg: C
        });
        D.init(B);
        D.updateHex(A);
        return D.verify(z);
    };
    this.parseExt = function(I) {
        var B, z, D;
        if (I === undefined) {
            D = this.hex;
            if (this.version !== 3) return -1;
            B = l(D, 0, [
                0,
                7,
                0
            ], "30");
            z = s(D, B);
        } else {
            D = pemtohex(I);
            var E = l(D, 0, [
                0,
                3,
                0,
                0
            ], "06");
            if (k(D, E) != "2a864886f70d01090e") {
                this.aExtInfo = new Array();
                return;
            }
            B = l(D, 0, [
                0,
                3,
                0,
                1,
                0
            ], "30");
            z = s(D, B);
            this.hex = D;
        }
        this.aExtInfo = new Array();
        for(var C = 0; C < z.length; C++){
            var G = {};
            G.critical = false;
            var F = s(D, z[C]);
            var A = 0;
            if (F.length === 3) {
                G.critical = true;
                A = 1;
            }
            G.oid = o.hextooidstr(c(D, z[C], [
                0
            ], "06"));
            var H = l(D, z[C], [
                1 + A
            ]);
            G.vidx = n(D, H);
            this.aExtInfo.push(G);
        }
    };
    this.getExtInfo = function(B) {
        var z = this.aExtInfo;
        var C = B;
        if (!B.match(/^[0-9.]+$/)) C = KJUR.asn1.x509.OID.name2oid(B);
        if (C === "") return undefined;
        for(var A = 0; A < z.length; A++){
            if (z[A].oid === C) return z[A];
        }
        return undefined;
    };
    this.getCriticalExtV = function(C, z, B) {
        if (z != undefined) return [
            z,
            B
        ];
        var A = this.getExtInfo(C);
        if (A == undefined) return [
            null,
            null
        ];
        return [
            b(this.hex, A.vidx),
            A.critical
        ];
    };
    this.getExtBasicConstraints = function(A, E) {
        if (A === undefined && E === undefined) {
            var C = this.getExtInfo("basicConstraints");
            if (C === undefined) return undefined;
            A = b(this.hex, C.vidx);
            E = C.critical;
        }
        var z = {
            extname: "basicConstraints"
        };
        if (E) z.critical = true;
        if (A === "3000") return z;
        if (A === "30030101ff") {
            z.cA = true;
            return z;
        }
        if (A.substr(0, 12) === "30060101ff02") {
            var D = k(A, 10);
            var B = parseInt(D, 16);
            z.cA = true;
            z.pathLen = B;
            return z;
        }
        throw new Error("hExtV parse error: " + A);
    };
    this.getExtNameConstraints = function(I, G) {
        var A = this.getCriticalExtV("nameConstraints", I, G);
        I = A[0];
        G = A[1];
        if (I == null) return undefined;
        var K = {
            extname: "nameConstraints"
        };
        if (G) K.critical = true;
        var F = s(I, 0);
        for(var D = 0; D < F.length; D++){
            var E = [];
            var B = s(I, F[D]);
            for(var C = 0; C < B.length; C++){
                var H = b(I, B[C]);
                var z = this.getGeneralSubtree(H);
                E.push(z);
            }
            var J = I.substr(F[D], 2);
            if (J == "a0") K.permit = E;
            else if (J == "a1") K.exclude = E;
        }
        return K;
    };
    this.getGeneralSubtree = function(F) {
        var D = s(F, 0);
        var C = D.length;
        if (C < 1 || 2 < C) throw new Error("wrong num elements");
        var B = this.getGeneralName(b(F, D[0]));
        for(var E = 1; E < C; E++){
            var A = F.substr(D[E], 2);
            var z = k(F, D[E]);
            var G = parseInt(z, 16);
            if (A == "80") B.min = G;
            if (A == "81") B.max = G;
        }
        return B;
    };
    this.getExtKeyUsage = function(A, C) {
        var B = this.getCriticalExtV("keyUsage", A, C);
        A = B[0];
        C = B[1];
        if (A == null) return undefined;
        var z = {
            extname: "keyUsage"
        };
        if (C) z.critical = true;
        z.names = this.getExtKeyUsageString(A).split(",");
        return z;
    };
    this.getExtKeyUsageBin = function(A) {
        if (A === undefined) {
            var B = this.getExtInfo("keyUsage");
            if (B === undefined) return "";
            A = b(this.hex, B.vidx);
        }
        if (A.length != 8 && A.length != 10) throw new Error("malformed key usage value: " + A);
        var z = "000000000000000" + parseInt(A.substr(6), 16).toString(2);
        if (A.length == 8) z = z.slice(-8);
        if (A.length == 10) z = z.slice(-16);
        z = z.replace(/0+$/, "");
        if (z == "") z = "0";
        return z;
    };
    this.getExtKeyUsageString = function(B) {
        var C = this.getExtKeyUsageBin(B);
        var z = new Array();
        for(var A = 0; A < C.length; A++)if (C.substr(A, 1) == "1") z.push(X509.KEYUSAGE_NAME[A]);
        return z.join(",");
    };
    this.getExtSubjectKeyIdentifier = function(B, D) {
        if (B === undefined && D === undefined) {
            var C = this.getExtInfo("subjectKeyIdentifier");
            if (C === undefined) return undefined;
            B = b(this.hex, C.vidx);
            D = C.critical;
        }
        var z = {
            extname: "subjectKeyIdentifier"
        };
        if (D) z.critical = true;
        var A = k(B, 0);
        z.kid = {
            hex: A
        };
        return z;
    };
    this.getExtAuthorityKeyIdentifier = function(F, D) {
        if (F === undefined && D === undefined) {
            var z = this.getExtInfo("authorityKeyIdentifier");
            if (z === undefined) return undefined;
            F = b(this.hex, z.vidx);
            D = z.critical;
        }
        var G = {
            extname: "authorityKeyIdentifier"
        };
        if (D) G.critical = true;
        var E = s(F, 0);
        for(var A = 0; A < E.length; A++){
            var H = F.substr(E[A], 2);
            if (H === "80") G.kid = {
                hex: k(F, E[A])
            };
            if (H === "a1") {
                var C = b(F, E[A]);
                var B = this.getGeneralNames(C);
                G.issuer = B[0]["dn"];
            }
            if (H === "82") G.sn = {
                hex: k(F, E[A])
            };
        }
        return G;
    };
    this.getExtExtKeyUsage = function(C, E) {
        if (C === undefined && E === undefined) {
            var D = this.getExtInfo("extKeyUsage");
            if (D === undefined) return undefined;
            C = b(this.hex, D.vidx);
            E = D.critical;
        }
        var z = {
            extname: "extKeyUsage",
            array: []
        };
        if (E) z.critical = true;
        var A = s(C, 0);
        for(var B = 0; B < A.length; B++)z.array.push(u(k(C, A[B])));
        return z;
    };
    this.getExtExtKeyUsageName = function() {
        var D = this.getExtInfo("extKeyUsage");
        if (D === undefined) return D;
        var z = new Array();
        var C = b(this.hex, D.vidx);
        if (C === "") return z;
        var A = s(C, 0);
        for(var B = 0; B < A.length; B++)z.push(u(k(C, A[B])));
        return z;
    };
    this.getExtSubjectAltName = function(A, C) {
        if (A === undefined && C === undefined) {
            var B = this.getExtInfo("subjectAltName");
            if (B === undefined) return undefined;
            A = b(this.hex, B.vidx);
            C = B.critical;
        }
        var z = {
            extname: "subjectAltName",
            array: []
        };
        if (C) z.critical = true;
        z.array = this.getGeneralNames(A);
        return z;
    };
    this.getExtIssuerAltName = function(A, C) {
        if (A === undefined && C === undefined) {
            var B = this.getExtInfo("issuerAltName");
            if (B === undefined) return undefined;
            A = b(this.hex, B.vidx);
            C = B.critical;
        }
        var z = {
            extname: "issuerAltName",
            array: []
        };
        if (C) z.critical = true;
        z.array = this.getGeneralNames(A);
        return z;
    };
    this.getGeneralNames = function(D) {
        var B = s(D, 0);
        var z = [];
        for(var C = 0; C < B.length; C++){
            var A = this.getGeneralName(b(D, B[C]));
            if (A !== undefined) z.push(A);
        }
        return z;
    };
    this.getGeneralName = function(A) {
        var z = A.substr(0, 2);
        var C = k(A, 0);
        var B = hextorstr(C);
        if (z == "81") return {
            rfc822: B
        };
        if (z == "82") return {
            dns: B
        };
        if (z == "86") return {
            uri: B
        };
        if (z == "87") return {
            ip: hextoip(C)
        };
        if (z == "a4") return {
            dn: this.getX500Name(C)
        };
        if (z == "a0") return {
            other: this.getOtherName(A)
        };
        return undefined;
    };
    this.getExtSubjectAltName2 = function() {
        var D, G, F;
        var E = this.getExtInfo("subjectAltName");
        if (E === undefined) return E;
        var z = new Array();
        var C = b(this.hex, E.vidx);
        var A = s(C, 0);
        for(var B = 0; B < A.length; B++){
            F = C.substr(A[B], 2);
            D = k(C, A[B]);
            if (F === "81") {
                G = hextoutf8(D);
                z.push([
                    "MAIL",
                    G
                ]);
            }
            if (F === "82") {
                G = hextoutf8(D);
                z.push([
                    "DNS",
                    G
                ]);
            }
            if (F === "84") {
                G = X509.hex2dn(D, 0);
                z.push([
                    "DN",
                    G
                ]);
            }
            if (F === "86") {
                G = hextoutf8(D);
                z.push([
                    "URI",
                    G
                ]);
            }
            if (F === "87") {
                G = hextoip(D);
                z.push([
                    "IP",
                    G
                ]);
            }
        }
        return z;
    };
    this.getExtCRLDistributionPoints = function(D, F) {
        if (D === undefined && F === undefined) {
            var E = this.getExtInfo("cRLDistributionPoints");
            if (E === undefined) return undefined;
            D = b(this.hex, E.vidx);
            F = E.critical;
        }
        var A = {
            extname: "cRLDistributionPoints",
            array: []
        };
        if (F) A.critical = true;
        var B = s(D, 0);
        for(var C = 0; C < B.length; C++){
            var z = b(D, B[C]);
            A.array.push(this.getDistributionPoint(z));
        }
        return A;
    };
    this.getDistributionPoint = function(E) {
        var B = {};
        var C = s(E, 0);
        for(var D = 0; D < C.length; D++){
            var A = E.substr(C[D], 2);
            var z = b(E, C[D]);
            if (A == "a0") B.dpname = this.getDistributionPointName(z);
        }
        return B;
    };
    this.getDistributionPointName = function(E) {
        var B = {};
        var C = s(E, 0);
        for(var D = 0; D < C.length; D++){
            var A = E.substr(C[D], 2);
            var z = b(E, C[D]);
            if (A == "a0") B.full = this.getGeneralNames(z);
        }
        return B;
    };
    this.getExtCRLDistributionPointsURI = function() {
        var D = this.getExtCRLDistributionPoints();
        if (D == undefined) return D;
        var A = D.array;
        var z = [];
        for(var C = 0; C < A.length; C++)try {
            if (A[C].dpname.full[0].uri != undefined) z.push(A[C].dpname.full[0].uri);
        } catch (B) {}
        return z;
    };
    this.getExtAIAInfo = function() {
        var D = this.getExtInfo("authorityInfoAccess");
        if (D === undefined) return D;
        var z = {
            ocsp: [],
            caissuer: []
        };
        var A = s(this.hex, D.vidx);
        for(var B = 0; B < A.length; B++){
            var E = c(this.hex, A[B], [
                0
            ], "06");
            var C = c(this.hex, A[B], [
                1
            ], "86");
            if (E === "2b06010505073001") z.ocsp.push(hextoutf8(C));
            if (E === "2b06010505073002") z.caissuer.push(hextoutf8(C));
        }
        return z;
    };
    this.getExtAuthorityInfoAccess = function(G, E) {
        if (G === undefined && E === undefined) {
            var z = this.getExtInfo("authorityInfoAccess");
            if (z === undefined) return undefined;
            G = b(this.hex, z.vidx);
            E = z.critical;
        }
        var H = {
            extname: "authorityInfoAccess",
            array: []
        };
        if (E) H.critical = true;
        var F = s(G, 0);
        for(var A = 0; A < F.length; A++){
            var D = p(G, F[A], [
                0
            ], "06");
            var B = c(G, F[A], [
                1
            ], "86");
            var C = hextoutf8(B);
            if (D == "2b06010505073001") H.array.push({
                ocsp: C
            });
            else {
                if (D == "2b06010505073002") H.array.push({
                    caissuer: C
                });
                else throw new Error("unknown method: " + D);
            }
        }
        return H;
    };
    this.getExtCertificatePolicies = function(D, G) {
        if (D === undefined && G === undefined) {
            var F = this.getExtInfo("certificatePolicies");
            if (F === undefined) return undefined;
            D = b(this.hex, F.vidx);
            G = F.critical;
        }
        var z = {
            extname: "certificatePolicies",
            array: []
        };
        if (G) z.critical = true;
        var A = s(D, 0);
        for(var B = 0; B < A.length; B++){
            var E = b(D, A[B]);
            var C = this.getPolicyInformation(E);
            z.array.push(C);
        }
        return z;
    };
    this.getPolicyInformation = function(D) {
        var z = {};
        var F = c(D, 0, [
            0
        ], "06");
        z.policyoid = u(F);
        var G = f(D, 0, [
            1
        ], "30");
        if (G != -1) {
            z.array = [];
            var A = s(D, G);
            for(var B = 0; B < A.length; B++){
                var E = b(D, A[B]);
                var C = this.getPolicyQualifierInfo(E);
                z.array.push(C);
            }
        }
        return z;
    };
    this.getOtherName = function(B) {
        var z = {};
        var A = s(B, 0);
        var D = c(B, A[0], [], "06");
        var C = c(B, A[1], []);
        z.oid = u(D);
        z.value = j(C);
        return z;
    };
    this.getPolicyQualifierInfo = function(A) {
        var z = {};
        var B = c(A, 0, [
            0
        ], "06");
        if (B === "2b06010505070201") {
            var D = p(A, 0, [
                1
            ], "16");
            z.cps = hextorstr(D);
        } else if (B === "2b06010505070202") {
            var C = a(A, 0, [
                1
            ], "30");
            z.unotice = this.getUserNotice(C);
        }
        return z;
    };
    this.getUserNotice = function(B) {
        var D = null;
        var z = {};
        try {
            D = o.parse(B);
            var C = this._asn1ToUnotice(D);
            return C;
        } catch (A) {
            return undefined;
        }
    };
    this._asn1ToUnotice = function(E) {
        try {
            var z = {};
            var A = aryval(E, "seq");
            for(var C = 0; C < A.length; C++){
                var D = this._asn1ToNoticeRef(A[C]);
                if (D != undefined) z.noticeref = D;
                var F = this.asn1ToDisplayText(A[C]);
                if (F != undefined) z.exptext = F;
            }
            if (Object.keys(z).length > 0) return z;
            return undefined;
        } catch (B) {
            return undefined;
        }
    };
    this._asn1ToNoticeRef = function(F) {
        try {
            var A = {};
            var B = aryval(F, "seq");
            for(var D = 0; D < B.length; D++){
                var E = this._asn1ToNoticeNum(B[D]);
                if (E != undefined) A.noticenum = E;
                var z = this.asn1ToDisplayText(B[D]);
                if (z != undefined) A.org = z;
            }
            if (Object.keys(A).length > 0) return A;
            return undefined;
        } catch (C) {
            return undefined;
        }
    };
    this._asn1ToNoticeNum = function(E) {
        try {
            var A = aryval(E, "seq");
            var z = [];
            for(var C = 0; C < A.length; C++){
                var D = A[C];
                z.push(parseInt(aryval(D, "int.hex"), 16));
            }
            return z;
        } catch (B) {
            return undefined;
        }
    };
    this.getDisplayText = function(A) {
        var B = {
            "0c": "utf8",
            "16": "ia5",
            "1a": "vis",
            "1e": "bmp"
        };
        var z = {};
        z.type = B[A.substr(0, 2)];
        z.str = hextorstr(k(A, 0));
        return z;
    };
    this.asn1ToDisplayText = function(z) {
        if (z.utf8str != undefined) return {
            type: "utf8",
            str: z.utf8str.str
        };
        if (z.ia5str != undefined) return {
            type: "ia5",
            str: z.ia5str.str
        };
        if (z.visstr != undefined) return {
            type: "vis",
            str: z.visstr.str
        };
        if (z.bmpstr != undefined) return {
            type: "bmp",
            str: z.bmpstr.str
        };
        if (z.prnstr != undefined) return {
            type: "prn",
            str: z.prnstr.str
        };
        return undefined;
    };
    this.getExtPolicyMappings = function(G, E) {
        var z = this.getCriticalExtV("policyMappings", G, E);
        G = z[0];
        E = z[1];
        if (G == null) return undefined;
        var I = {
            extname: "policyMappings"
        };
        if (E) I.critical = true;
        try {
            var A = j(G);
            var B = A.seq;
            var F = [];
            for(var C = 0; C < B.length; C++){
                var H = B[C].seq;
                F.push([
                    H[0].oid,
                    H[1].oid
                ]);
            }
            I.array = F;
        } catch (D) {
            throw new m("malformed policyMappings");
        }
        return I;
    };
    this.getExtPolicyConstraints = function(G, D) {
        var z = this.getCriticalExtV("policyConstraints", G, D);
        G = z[0];
        D = z[1];
        if (G == null) return undefined;
        var H = {
            extname: "policyConstraints"
        };
        if (D) H.critical = true;
        var A = j(G);
        try {
            var F = A.seq;
            for(var B = 0; B < F.length; B++){
                var E = F[B].tag;
                if (E.explicit != false) continue;
                if (E.tag == "80") H.reqexp = parseInt(E.hex, 16);
                if (E.tag == "81") H.inhibit = parseInt(E.hex, 16);
            }
        } catch (C) {
            return new m("malformed policyConstraints value");
        }
        return H;
    };
    this.getExtInhibitAnyPolicy = function(A, D) {
        var C = this.getCriticalExtV("inhibitAnyPolicy", A, D);
        A = C[0];
        D = C[1];
        if (A == null) return undefined;
        var z = {
            extname: "inhibitAnyPolicy"
        };
        if (D) z.critical = true;
        var B = x(A, 0);
        if (B == -1) return new m("wrong value");
        z.skip = B;
        return z;
    };
    this.getExtCRLNumber = function(A, B) {
        var z = {
            extname: "cRLNumber"
        };
        if (B) z.critical = true;
        if (A.substr(0, 2) == "02") {
            z.num = {
                hex: k(A, 0)
            };
            return z;
        }
        throw new m("hExtV parse error: " + A);
    };
    this.getExtCRLReason = function(A, B) {
        var z = {
            extname: "cRLReason"
        };
        if (B) z.critical = true;
        if (A.substr(0, 2) == "0a") {
            z.code = parseInt(k(A, 0), 16);
            return z;
        }
        throw new Error("hExtV parse error: " + A);
    };
    this.getExtOcspNonce = function(A, C) {
        var z = {
            extname: "ocspNonce"
        };
        if (C) z.critical = true;
        var B = k(A, 0);
        z.hex = B;
        return z;
    };
    this.getExtOcspNoCheck = function(A, B) {
        var z = {
            extname: "ocspNoCheck"
        };
        if (B) z.critical = true;
        return z;
    };
    this.getExtAdobeTimeStamp = function(C, F) {
        if (C === undefined && F === undefined) {
            var E = this.getExtInfo("adobeTimeStamp");
            if (E === undefined) return undefined;
            C = b(this.hex, E.vidx);
            F = E.critical;
        }
        var z = {
            extname: "adobeTimeStamp"
        };
        if (F) z.critical = true;
        var B = s(C, 0);
        if (B.length > 1) {
            var G = b(C, B[1]);
            var A = this.getGeneralName(G);
            if (A.uri != undefined) z.uri = A.uri;
        }
        if (B.length > 2) {
            var D = b(C, B[2]);
            if (D == "0101ff") z.reqauth = true;
            if (D == "010100") z.reqauth = false;
        }
        return z;
    };
    this.getExtSubjectDirectoryAttributes = function(I, H) {
        if (I === undefined && H === undefined) {
            var B = this.getExtInfo("subjectDirectoryAttributes");
            if (B === undefined) return undefined;
            I = b(this.hex, B.vidx);
            H = B.critical;
        }
        var J = {
            extname: "subjectDirectoryAttributes"
        };
        if (H) J.critical = true;
        try {
            var z = j(I);
            var D = [];
            for(var E = 0; E < z.seq.length; E++){
                var A = z.seq[E];
                var C = aryval(A, "seq.0.oid");
                var F = aryval(A, "seq.1.set");
                if (C == undefined || F == undefined) throw "error";
                D.push({
                    attr: C,
                    array: F
                });
            }
            J.array = D;
            return J;
        } catch (G) {
            throw new Error("malformed subjectDirectoryAttributes extension value");
        }
    };
    var e = function(E) {
        var z = {};
        try {
            var B = E.seq[0].oid;
            var D = KJUR.asn1.x509.OID.name2oid(B);
            z.type = KJUR.asn1.x509.OID.oid2atype(D);
            var A = E.seq[1];
            if (A.utf8str != undefined) {
                z.ds = "utf8";
                z.value = A.utf8str.str;
            } else if (A.numstr != undefined) {
                z.ds = "num";
                z.value = A.numstr.str;
            } else {
                if (A.telstr != undefined) {
                    z.ds = "tel";
                    z.value = A.telstr.str;
                } else if (A.prnstr != undefined) {
                    z.ds = "prn";
                    z.value = A.prnstr.str;
                } else {
                    if (A.ia5str != undefined) {
                        z.ds = "ia5";
                        z.value = A.ia5str.str;
                    } else if (A.visstr != undefined) {
                        z.ds = "vis";
                        z.value = A.visstr.str;
                    } else {
                        if (A.bmpstr != undefined) {
                            z.ds = "bmp";
                            z.value = A.bmpstr.str;
                        } else throw "error";
                    }
                }
            }
            return z;
        } catch (C) {
            throw new Erorr("improper ASN.1 parsed AttrTypeAndValue");
        }
    };
    var i = function(A) {
        try {
            return A.set.map(function(B) {
                return e(B);
            });
        } catch (z) {
            throw new Error("improper ASN.1 parsed RDN: " + z);
        }
    };
    var h = function(A) {
        try {
            return A.seq.map(function(B) {
                return i(B);
            });
        } catch (z) {
            throw new Error("improper ASN.1 parsed X500Name: " + z);
        }
    };
    this.getX500NameRule = function(z) {
        var G = true;
        var K = true;
        var J = false;
        var A = "";
        var D = "";
        var M = null;
        var H = [];
        for(var C = 0; C < z.length; C++){
            var E = z[C];
            for(var B = 0; B < E.length; B++)H.push(E[B]);
        }
        for(var C = 0; C < H.length; C++){
            var L = H[C];
            var N = L.ds;
            var I = L.value;
            var F = L.type;
            A += ":" + N;
            if (N != "prn" && N != "utf8" && N != "ia5") return "mixed";
            if (N == "ia5") {
                if (F != "CN") return "mixed";
                else {
                    if (!KJUR.lang.String.isMail(I)) return "mixed";
                    else continue;
                }
            }
            if (F == "C") {
                if (N == "prn") continue;
                else return "mixed";
            }
            D += ":" + N;
            if (M == null) M = N;
            else {
                if (M !== N) return "mixed";
            }
        }
        if (M == null) return "prn";
        else return M;
    };
    this.getAttrTypeAndValue = function(z) {
        var A = j(z);
        return e(A);
    };
    this.getRDN = function(z) {
        var A = j(z);
        return i(A);
    };
    this.getX500NameArray = function(z) {
        var A = j(z);
        return h(A);
    };
    this.getX500Name = function(C, E, D) {
        var A = this.getX500NameArray(C);
        var B = this.dnarraytostr(A);
        var z = {
            str: B
        };
        z.array = A;
        if (D == true) z.hex = C;
        if (E == true) z.canon = this.c14nRDNArray(A);
        return z;
    };
    this.readCertPEM = function(z) {
        this.readCertHex(w(z));
    };
    this.readCertHex = function(z) {
        this.hex = z;
        this.getVersion();
        try {
            l(this.hex, 0, [
                0,
                7
            ], "a3");
            this.parseExt();
        } catch (A) {}
    };
    this.getParam = function(A) {
        var z = {};
        if (A == undefined) A = {};
        z.version = this.getVersion();
        z.serial = {
            hex: this.getSerialNumberHex()
        };
        z.sigalg = this.getSignatureAlgorithmField();
        z.issuer = this.getIssuer(A.dncanon, A.dnhex);
        z.notbefore = this.getNotBefore();
        z.notafter = this.getNotAfter();
        z.subject = this.getSubject(A.dncanon, A.dnhex);
        z.sbjpubkey = hextopem(this.getPublicKeyHex(), "PUBLIC KEY");
        if (this.aExtInfo != undefined && this.aExtInfo.length > 0) z.ext = this.getExtParamArray();
        z.sighex = this.getSignatureValueHex();
        if (A.tbshex == true) z.tbshex = a(this.hex, 0, [
            0
        ]);
        if (A.nodnarray == true) {
            delete z.issuer.array;
            delete z.subject.array;
        }
        return z;
    };
    this.getExtParamArray = function(A) {
        if (A == undefined) {
            var C = f(this.hex, 0, [
                0,
                "[3]"
            ]);
            if (C != -1) A = q(this.hex, 0, [
                0,
                "[3]",
                0
            ], "30");
        }
        var z = [];
        var B = s(A, 0);
        for(var D = 0; D < B.length; D++){
            var F = b(A, B[D]);
            var E = this.getExtParam(F);
            if (E != null) z.push(E);
        }
        return z;
    };
    this.getExtParam = function(A) {
        var I = {};
        var C = s(A, 0);
        var E = C.length;
        if (E != 2 && E != 3) throw new Error("wrong number elements in Extension: " + E + " " + A);
        var B = r(c(A, 0, [
            0
        ], "06"));
        var G = false;
        if (E == 3 && a(A, 0, [
            1
        ]) == "0101ff") G = true;
        var H = a(A, 0, [
            E - 1,
            0
        ]);
        var F = undefined;
        if (B == "2.5.29.14") F = this.getExtSubjectKeyIdentifier(H, G);
        else {
            if (B == "2.5.29.15") F = this.getExtKeyUsage(H, G);
            else if (B == "2.5.29.17") F = this.getExtSubjectAltName(H, G);
            else {
                if (B == "2.5.29.18") F = this.getExtIssuerAltName(H, G);
                else if (B == "2.5.29.19") F = this.getExtBasicConstraints(H, G);
                else {
                    if (B == "2.5.29.30") F = this.getExtNameConstraints(H, G);
                    else if (B == "2.5.29.31") F = this.getExtCRLDistributionPoints(H, G);
                    else {
                        if (B == "2.5.29.32") F = this.getExtCertificatePolicies(H, G);
                        else if (B == "2.5.29.33") F = this.getExtPolicyMappings(H, G);
                        else {
                            if (B == "2.5.29.35") F = this.getExtAuthorityKeyIdentifier(H, G);
                            else if (B == "2.5.29.36") F = this.getExtPolicyConstraints(H, G);
                            else {
                                if (B == "2.5.29.37") F = this.getExtExtKeyUsage(H, G);
                                else if (B == "2.5.29.54") F = this.getExtInhibitAnyPolicy(H, G);
                                else {
                                    if (B == "1.3.6.1.5.5.7.1.1") F = this.getExtAuthorityInfoAccess(H, G);
                                    else if (B == "2.5.29.20") F = this.getExtCRLNumber(H, G);
                                    else {
                                        if (B == "2.5.29.21") F = this.getExtCRLReason(H, G);
                                        else if (B == "2.5.29.9") F = this.getExtSubjectDirectoryAttributes(H, G);
                                        else {
                                            if (B == "1.3.6.1.5.5.7.48.1.2") F = this.getExtOcspNonce(H, G);
                                            else if (B == "1.3.6.1.5.5.7.48.1.5") F = this.getExtOcspNoCheck(H, G);
                                            else {
                                                if (B == "1.2.840.113583.1.1.9.1") F = this.getExtAdobeTimeStamp(H, G);
                                                else if (X509.EXT_PARSER[B] != undefined) F = X509.EXT_PARSER[B](B, G, H);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (F != undefined) return F;
        var z = {
            extname: B,
            extn: H
        };
        try {
            z.extn = j(H);
        } catch (D) {}
        if (G) z.critical = true;
        return z;
    };
    this.findExt = function(A, B) {
        for(var z = 0; z < A.length; z++){
            if (A[z].extname == B) return A[z];
        }
        return null;
    };
    this.updateExtCDPFullURI = function(D, z) {
        var C = this.findExt(D, "cRLDistributionPoints");
        if (C == null) return;
        if (C.array == undefined) return;
        var F = C.array;
        for(var B = 0; B < F.length; B++){
            if (F[B].dpname == undefined) continue;
            if (F[B].dpname.full == undefined) continue;
            var G = F[B].dpname.full;
            for(var A = 0; A < G.length; A++){
                var E = G[B];
                if (E.uri == undefined) continue;
                E.uri = z;
            }
        }
    };
    this.updateExtAIAOCSP = function(D, A) {
        var C = this.findExt(D, "authorityInfoAccess");
        if (C == null) return;
        if (C.array == undefined) return;
        var z = C.array;
        for(var B = 0; B < z.length; B++)if (z[B].ocsp != undefined) z[B].ocsp = A;
    };
    this.updateExtAIACAIssuer = function(D, A) {
        var C = this.findExt(D, "authorityInfoAccess");
        if (C == null) return;
        if (C.array == undefined) return;
        var z = C.array;
        for(var B = 0; B < z.length; B++)if (z[B].caissuer != undefined) z[B].caissuer = A;
    };
    this.dnarraytostr = function(B) {
        function z(C) {
            return C.map(function(D) {
                return A(D).replace(/\+/, "\\+");
            }).join("+");
        }
        function A(C) {
            return C.type + "=" + C.value;
        }
        return "/" + B.map(function(C) {
            return z(C).replace(/\//, "\\/");
        }).join("/");
    };
    this.setCanonicalizedDN = function(A) {
        var C;
        if (A.str != undefined && A.array == undefined) {
            var B = new KJUR.asn1.x509.X500Name({
                str: A.str
            });
            var z = B.tohex();
            C = this.getX500NameArray(z);
        } else C = A.array;
        if (A.canon == undefined) A.canon = this.c14nRDNArray(C);
    };
    this.c14nRDNArray = function(G) {
        var A = [];
        for(var C = 0; C < G.length; C++){
            var E = G[C];
            var z = [];
            for(var B = 0; B < E.length; B++){
                var D = E[B];
                var F = D.value;
                F = F.replace(/^\s*/, "");
                F = F.replace(/\s*$/, "");
                F = F.replace(/\s+/g, " ");
                F = F.toLowerCase();
                z.push(D.type.toLowerCase() + "=" + F);
            }
            A.push(z.join("+"));
        }
        return "/" + A.join("/");
    };
    this.getInfo = function() {
        var A = function(W) {
            var ac = "";
            var U = "    ";
            var Y = "\n";
            var Z = W.array;
            for(var X = 0; X < Z.length; X++){
                var V = Z[X];
                if (V.dn != undefined) ac += U + "dn: " + V.dn.str + Y;
                if (V.ip != undefined) ac += U + "ip: " + V.ip + Y;
                if (V.rfc822 != undefined) ac += U + "rfc822: " + V.rfc822 + Y;
                if (V.dns != undefined) ac += U + "dns: " + V.dns + Y;
                if (V.uri != undefined) ac += U + "uri: " + V.uri + Y;
                if (V.other != undefined) {
                    var ab = V.other.oid;
                    var aa = JSON.stringify(V.other.value).replace(/\"/g, "");
                    ac += U + "other: " + ab + "=" + aa + Y;
                }
            }
            ac = ac.replace(/\n$/, "");
            return ac;
        };
        var H = function(aa) {
            var Y = "";
            var U = aa.array;
            for(var X = 0; X < U.length; X++){
                var Z = U[X];
                Y += "    policy oid: " + Z.policyoid + "\n";
                if (Z.array === undefined) continue;
                for(var W = 0; W < Z.array.length; W++){
                    var V = Z.array[W];
                    if (V.cps !== undefined) Y += "    cps: " + V.cps + "\n";
                }
            }
            return Y;
        };
        var K = function(Y) {
            var X = "";
            var U = Y.array;
            for(var W = 0; W < U.length; W++){
                var Z = U[W];
                try {
                    if (Z.dpname.full[0].uri !== undefined) X += "    " + Z.dpname.full[0].uri + "\n";
                } catch (V) {}
                try {
                    if (Z.dname.full[0].dn.hex !== undefined) X += "    " + X509.hex2dn(Z.dpname.full[0].dn.hex) + "\n";
                } catch (V) {}
            }
            return X;
        };
        var I = function(Y) {
            var X = "";
            var U = Y.array;
            for(var V = 0; V < U.length; V++){
                var W = U[V];
                if (W.caissuer !== undefined) X += "    caissuer: " + W.caissuer + "\n";
                if (W.ocsp !== undefined) X += "    ocsp: " + W.ocsp + "\n";
            }
            return X;
        };
        var B = X509;
        var M, L, T;
        M = "Basic Fields\n";
        M += "  serial number: " + this.getSerialNumberHex() + "\n";
        M += "  signature algorithm: " + this.getSignatureAlgorithmField() + "\n";
        M += "  issuer: " + this.getIssuerString() + "\n";
        M += "  notBefore: " + this.getNotBefore() + "\n";
        M += "  notAfter: " + this.getNotAfter() + "\n";
        M += "  subject: " + this.getSubjectString() + "\n";
        M += "  subject public key info: \n";
        L = this.getPublicKey();
        M += "    key algorithm: " + L.type + "\n";
        if (L.type === "RSA") {
            M += "    n=" + hextoposhex(L.n.toString(16)).substr(0, 16) + "...\n";
            M += "    e=" + hextoposhex(L.e.toString(16)) + "\n";
        }
        T = this.aExtInfo;
        if (T !== undefined && T !== null) {
            M += "X509v3 Extensions:\n";
            for(var P = 0; P < T.length; P++){
                var R = T[P];
                var z = KJUR.asn1.x509.OID.oid2name(R.oid);
                if (z === "") z = R.oid;
                var O = "";
                if (R.critical === true) O = "CRITICAL";
                M += "  " + z + " " + O + ":\n";
                if (z === "basicConstraints") {
                    var C = this.getExtBasicConstraints();
                    if (C.cA === undefined) M += "    {}\n";
                    else {
                        M += "    cA=true";
                        if (C.pathLen !== undefined) M += ", pathLen=" + C.pathLen;
                        M += "\n";
                    }
                } else if (z == "policyMappings") {
                    var S = this.getExtPolicyMappings().array;
                    var G = S.map(function(U) {
                        var V = U;
                        return V[0] + ":" + V[1];
                    }).join(", ");
                    M += "    " + G + "\n";
                } else {
                    if (z == "policyConstraints") {
                        var N = this.getExtPolicyConstraints();
                        M += "    ";
                        if (N.reqexp != undefined) M += " reqexp=" + N.reqexp;
                        if (N.inhibit != undefined) M += " inhibit=" + N.inhibit;
                        M += "\n";
                    } else if (z == "inhibitAnyPolicy") {
                        var N = this.getExtInhibitAnyPolicy();
                        M += "    skip=" + N.skip + "\n";
                    } else {
                        if (z == "keyUsage") M += "    " + this.getExtKeyUsageString() + "\n";
                        else if (z == "subjectKeyIdentifier") M += "    " + this.getExtSubjectKeyIdentifier().kid.hex + "\n";
                        else {
                            if (z == "authorityKeyIdentifier") {
                                var D = this.getExtAuthorityKeyIdentifier();
                                if (D.kid !== undefined) M += "    kid=" + D.kid.hex + "\n";
                            } else if (z == "extKeyUsage") {
                                var Q = this.getExtExtKeyUsage().array;
                                M += "    " + Q.join(", ") + "\n";
                            } else {
                                if (z == "subjectAltName") {
                                    var E = A(this.getExtSubjectAltName());
                                    M += E + "\n";
                                } else if (z == "cRLDistributionPoints") {
                                    var J = this.getExtCRLDistributionPoints();
                                    M += K(J);
                                } else {
                                    if (z == "authorityInfoAccess") {
                                        var F = this.getExtAuthorityInfoAccess();
                                        M += I(F);
                                    } else if (z == "certificatePolicies") M += H(this.getExtCertificatePolicies());
                                }
                            }
                        }
                    }
                }
            }
        }
        M += "signature algorithm: " + this.getSignatureAlgorithmName() + "\n";
        M += "signature: " + this.getSignatureValueHex().substr(0, 16) + "...\n";
        return M;
    };
    if (typeof v == "string") {
        if (v.indexOf("-----BEGIN") != -1) this.readCertPEM(v);
        else if (KJUR.lang.String.isHex(v)) this.readCertHex(v);
    }
}
X509.EXT_PARSER = {};
X509.registExtParser = function(b, a) {
    X509.EXT_PARSER[b] = a;
};
X509.hex2dn = function(e, b) {
    if (b === undefined) b = 0;
    var a = new X509();
    var c = ASN1HEX.getTLV(e, b);
    var d = a.getX500Name(e);
    return d.str;
};
X509.hex2rdn = function(f, b) {
    if (b === undefined) b = 0;
    if (f.substr(b, 2) !== "31") throw new Error("malformed RDN");
    var c = new Array();
    var d = ASN1HEX.getChildIdx(f, b);
    for(var e = 0; e < d.length; e++)c.push(X509.hex2attrTypeValue(f, d[e]));
    c = c.map(function(a) {
        return a.replace("+", "\\+");
    });
    return c.join("+");
};
X509.hex2attrTypeValue = function(d, i) {
    var j = ASN1HEX;
    var h = j.getV;
    if (i === undefined) i = 0;
    if (d.substr(i, 2) !== "30") throw new Error("malformed attribute type and value");
    var g = j.getChildIdx(d, i);
    if (g.length !== 2 || d.substr(g[0], 2) !== "06") "malformed attribute type and value";
    var b = h(d, g[0]);
    var f = KJUR.asn1.ASN1Util.oidHexToInt(b);
    var e = KJUR.asn1.x509.OID.oid2atype(f);
    var a = h(d, g[1]);
    var c = hextorstr(a);
    return e + "=" + c;
};
X509.getPublicKeyFromCertHex = function(b) {
    var a = new X509();
    a.readCertHex(b);
    return a.getPublicKey();
};
X509.getPublicKeyFromCertPEM = function(b) {
    var a = new X509();
    a.readCertPEM(b);
    return a.getPublicKey();
};
X509.getPublicKeyInfoPropOfCertPEM = function(c) {
    var e = ASN1HEX;
    var g = e.getVbyList;
    var b = {};
    var a, f, d;
    b.algparam = null;
    a = new X509();
    a.readCertPEM(c);
    f = a.getPublicKeyHex();
    b.keyhex = g(f, 0, [
        1
    ], "03").substr(2);
    b.algoid = g(f, 0, [
        0,
        0
    ], "06");
    if (b.algoid === "2a8648ce3d0201") b.algparam = g(f, 0, [
        0,
        1
    ], "06");
    return b;
};
X509.KEYUSAGE_NAME = [
    "digitalSignature",
    "nonRepudiation",
    "keyEncipherment",
    "dataEncipherment",
    "keyAgreement",
    "keyCertSign",
    "cRLSign",
    "encipherOnly",
    "decipherOnly"
];
var X509CRL = function(e) {
    var a = KJUR, f = a.lang.String.isHex, m = ASN1HEX, k = m.getV, b = m.getTLV, h = m.getVbyList, c = m.getTLVbyList, d = m.getTLVbyListEx, i = m.getIdxbyList, g = m.getIdxbyListEx, l = m.getChildIdx, j = new X509();
    this.hex = null;
    this.posSigAlg = null;
    this.posRevCert = null;
    this.parsed = null;
    this._setPos = function() {
        var o = i(this.hex, 0, [
            0,
            0
        ]);
        var n = this.hex.substr(o, 2);
        if (n == "02") this.posSigAlg = 1;
        else {
            if (n == "30") this.posSigAlg = 0;
            else throw new Error("malformed 1st item of TBSCertList: " + n);
        }
        var s = i(this.hex, 0, [
            0,
            this.posSigAlg + 3
        ]);
        var r = this.hex.substr(s, 2);
        if (r == "17" || r == "18") {
            var q, p;
            q = i(this.hex, 0, [
                0,
                this.posSigAlg + 4
            ]);
            this.posRevCert = null;
            if (q != -1) {
                p = this.hex.substr(q, 2);
                if (p == "30") this.posRevCert = this.posSigAlg + 4;
            }
        } else if (r == "30") this.posRevCert = this.posSigAlg + 3;
        else {
            if (r == "a0") this.posRevCert = null;
            else throw new Error("malformed nextUpdate or revCert tag: " + r);
        }
    };
    this.getVersion = function() {
        if (this.posSigAlg == 0) return null;
        return parseInt(h(this.hex, 0, [
            0,
            0
        ], "02"), 16) + 1;
    };
    this.getSignatureAlgorithmField = function() {
        var n = c(this.hex, 0, [
            0,
            this.posSigAlg
        ], "30");
        return j.getAlgorithmIdentifierName(n);
    };
    this.getIssuer = function() {
        return j.getX500Name(this.getIssuerHex());
    };
    this.getIssuerHex = function() {
        return c(this.hex, 0, [
            0,
            this.posSigAlg + 1
        ], "30");
    };
    this.getThisUpdate = function() {
        var n = h(this.hex, 0, [
            0,
            this.posSigAlg + 2
        ]);
        return result = hextorstr(n);
    };
    this.getNextUpdate = function() {
        var o = i(this.hex, 0, [
            0,
            this.posSigAlg + 3
        ]);
        var n = this.hex.substr(o, 2);
        if (n != "17" && n != "18") return null;
        return hextorstr(k(this.hex, o));
    };
    this.getRevCertArray = function() {
        if (this.posRevCert == null) return null;
        var o = [];
        var n = i(this.hex, 0, [
            0,
            this.posRevCert
        ]);
        var p = l(this.hex, n);
        for(var q = 0; q < p.length; q++){
            var r = b(this.hex, p[q]);
            o.push(this.getRevCert(r));
        }
        return o;
    };
    this.getRevCert = function(p) {
        var o = {};
        var n = l(p, 0);
        o.sn = {
            hex: h(p, 0, [
                0
            ], "02")
        };
        o.date = hextorstr(h(p, 0, [
            1
        ]));
        if (n.length == 3) o.ext = j.getExtParamArray(c(p, 0, [
            2
        ]));
        return o;
    };
    this.findRevCert = function(p) {
        var n = new X509(p);
        var o = n.getSerialNumberHex();
        return this.findRevCertBySN(o);
    };
    this.findRevCertBySN = function(o) {
        if (this.parsed == null) this.getParam();
        if (this.parsed.revcert == null) return null;
        var n = this.parsed.revcert;
        for(var p = 0; p < n.length; p++){
            if (o == n[p].sn.hex) return n[p];
        }
        return null;
    };
    this.getSignatureValueHex = function() {
        return h(this.hex, 0, [
            2
        ], "03", true);
    };
    this.verifySignature = function(o) {
        var p = this.getSignatureAlgorithmField();
        var n = this.getSignatureValueHex();
        var q = c(this.hex, 0, [
            0
        ], "30");
        var r = new KJUR.crypto.Signature({
            alg: p
        });
        r.init(o);
        r.updateHex(q);
        return r.verify(n);
    };
    this.getParam = function(r) {
        var n = {};
        var p = this.getVersion();
        if (p != null) n.version = p;
        n.sigalg = this.getSignatureAlgorithmField();
        n.issuer = this.getIssuer();
        n.thisupdate = this.getThisUpdate();
        var q = this.getNextUpdate();
        if (q != null) n.nextupdate = q;
        var t = this.getRevCertArray();
        if (t != null) n.revcert = t;
        var s = g(this.hex, 0, [
            0,
            "[0]"
        ]);
        if (s != -1) {
            var o = d(this.hex, 0, [
                0,
                "[0]",
                0
            ]);
            n.ext = j.getExtParamArray(o);
        }
        n.sighex = this.getSignatureValueHex();
        this.parsed = n;
        if (typeof r == "object") {
            if (r.tbshex == true) n.tbshex = c(this.hex, 0, [
                0
            ]);
            if (r.nodnarray == true) delete n.issuer.array;
        }
        return n;
    };
    if (typeof e == "string") {
        if (f(e)) this.hex = e;
        else if (e.match(/-----BEGIN X509 CRL/)) this.hex = pemtohex(e);
        this._setPos();
    }
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.jws == "undefined" || !KJUR.jws) KJUR.jws = {};
KJUR.jws.JWS = function() {
    var b = KJUR, a = b.jws.JWS, c = a.isSafeJSONString;
    this.parseJWS = function(g, j) {
        if (this.parsedJWS !== undefined && (j || this.parsedJWS.sigvalH !== undefined)) return;
        var i = g.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);
        if (i == null) throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
        var k = i[1];
        var e = i[2];
        var l = i[3];
        var n = k + "." + e;
        this.parsedJWS = {};
        this.parsedJWS.headB64U = k;
        this.parsedJWS.payloadB64U = e;
        this.parsedJWS.sigvalB64U = l;
        this.parsedJWS.si = n;
        if (!j) {
            var h = b64utohex(l);
            var f = parseBigInt(h, 16);
            this.parsedJWS.sigvalH = h;
            this.parsedJWS.sigvalBI = f;
        }
        var d = b64utoutf8(k);
        var m = b64utoutf8(e);
        this.parsedJWS.headS = d;
        this.parsedJWS.payloadS = m;
        if (!c(d, this.parsedJWS, "headP")) throw "malformed JSON string for JWS Head: " + d;
    };
};
KJUR.jws.JWS.sign = function(j, w, z, A, a) {
    var x = KJUR, n = x.jws, r = n.JWS, h = r.readSafeJSONString, q = r.isSafeJSONString, d = x.crypto, l = d.ECDSA, p = d.Mac, c = d.Signature, u = JSON;
    var t, k, o;
    if (typeof w != "string" && typeof w != "object") throw "spHeader must be JSON string or object: " + w;
    if (typeof w == "object") {
        k = w;
        t = u.stringify(k);
    }
    if (typeof w == "string") {
        t = w;
        if (!q(t)) throw "JWS Head is not safe JSON string: " + t;
        k = h(t);
    }
    o = z;
    if (typeof z == "object") o = u.stringify(z);
    if ((j == "" || j == null) && k.alg !== undefined) j = k.alg;
    if (j != "" && j != null && k.alg === undefined) {
        k.alg = j;
        t = u.stringify(k);
    }
    if (j !== k.alg) throw "alg and sHeader.alg doesn't match: " + j + "!=" + k.alg;
    var s = null;
    if (r.jwsalg2sigalg[j] === undefined) throw "unsupported alg name: " + j;
    else s = r.jwsalg2sigalg[j];
    var e = utf8tob64u(t);
    var m = utf8tob64u(o);
    var b = e + "." + m;
    var y = "";
    if (s.substr(0, 4) == "Hmac") {
        if (A === undefined) throw "mac key shall be specified for HS* alg";
        var i = new p({
            alg: s,
            prov: "cryptojs",
            pass: A
        });
        i.updateString(b);
        y = i.doFinal();
    } else {
        if (s.indexOf("withECDSA") != -1) {
            var f = new c({
                alg: s
            });
            f.init(A, a);
            f.updateString(b);
            var g = f.sign();
            y = KJUR.crypto.ECDSA.asn1SigToConcatSig(g);
        } else if (s != "none") {
            var f = new c({
                alg: s
            });
            f.init(A, a);
            f.updateString(b);
            y = f.sign();
        }
    }
    var v = hextob64u(y);
    return b + "." + v;
};
KJUR.jws.JWS.verify = function(w, B, n) {
    var x = KJUR, q = x.jws, t = q.JWS, i = t.readSafeJSONString, e = x.crypto, p = e.ECDSA, s = e.Mac, d = e.Signature, m;
    m = RSAKey;
    if (!isBase64URLDot(w)) return false;
    var y = w.split(".");
    if (y.length !== 3) return false;
    var f = y[0];
    var r = y[1];
    var c = f + "." + r;
    var A = b64utohex(y[2]);
    var l = i(b64utoutf8(y[0]));
    var k = null;
    var z = null;
    if (l.alg === undefined) throw "algorithm not specified in header";
    else {
        k = l.alg;
        z = k.substr(0, 2);
    }
    if (n != null && Object.prototype.toString.call(n) === "[object Array]" && n.length > 0) {
        var b = ":" + n.join(":") + ":";
        if (b.indexOf(":" + k + ":") == -1) throw "algorithm '" + k + "' not accepted in the list";
    }
    if (k != "none" && B === null) throw "key shall be specified to verify.";
    if (typeof B == "string" && B.indexOf("-----BEGIN ") != -1) B = KEYUTIL.getKey(B);
    if (z == "RS" || z == "PS") {
        if (!(B instanceof m)) throw "key shall be a RSAKey obj for RS* and PS* algs";
    }
    if (z == "ES") {
        if (!(B instanceof p)) throw "key shall be a ECDSA obj for ES* algs";
    }
    k;
    var u = null;
    if (t.jwsalg2sigalg[l.alg] === undefined) throw "unsupported alg name: " + k;
    else u = t.jwsalg2sigalg[k];
    if (u == "none") throw "not supported";
    else {
        if (u.substr(0, 4) == "Hmac") {
            var o = null;
            if (B === undefined) throw "hexadecimal key shall be specified for HMAC";
            var j = new s({
                alg: u,
                pass: B
            });
            j.updateString(c);
            o = j.doFinal();
            return A == o;
        } else if (u.indexOf("withECDSA") != -1) {
            var h = null;
            try {
                h = p.concatSigToASN1Sig(A);
            } catch (v) {
                return false;
            }
            var g = new d({
                alg: u
            });
            g.init(B);
            g.updateString(c);
            return g.verify(h);
        } else {
            var g = new d({
                alg: u
            });
            g.init(B);
            g.updateString(c);
            return g.verify(A);
        }
    }
};
KJUR.jws.JWS.parse = function(g) {
    var c = g.split(".");
    var b = {};
    var f, e, d;
    if (c.length != 2 && c.length != 3) throw "malformed sJWS: wrong number of '.' splitted elements";
    f = c[0];
    e = c[1];
    if (c.length == 3) d = c[2];
    b.headerObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(f));
    b.payloadObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(e));
    b.headerPP = JSON.stringify(b.headerObj, null, "  ");
    if (b.payloadObj == null) b.payloadPP = b64utoutf8(e);
    else b.payloadPP = JSON.stringify(b.payloadObj, null, "  ");
    if (d !== undefined) b.sigHex = b64utohex(d);
    return b;
};
KJUR.jws.JWS.verifyJWT = function(e, l, r) {
    var d = KJUR, j = d.jws, o = j.JWS, n = o.readSafeJSONString, p = o.inArray, f = o.includedArray;
    if (!isBase64URLDot(e)) return false;
    var k = e.split(".");
    if (k.length != 3) return false;
    var c = k[0];
    var i = k[1];
    var q = c + "." + i;
    var m = b64utohex(k[2]);
    var h = n(b64utoutf8(c));
    var g = n(b64utoutf8(i));
    if (h.alg === undefined) return false;
    if (r.alg === undefined) throw "acceptField.alg shall be specified";
    if (!p(h.alg, r.alg)) return false;
    if (g.iss !== undefined && typeof r.iss === "object") {
        if (!p(g.iss, r.iss)) return false;
    }
    if (g.sub !== undefined && typeof r.sub === "object") {
        if (!p(g.sub, r.sub)) return false;
    }
    if (g.aud !== undefined && typeof r.aud === "object") {
        if (typeof g.aud == "string") {
            if (!p(g.aud, r.aud)) return false;
        } else if (typeof g.aud == "object") {
            if (!f(g.aud, r.aud)) return false;
        }
    }
    var b = j.IntDate.getNow();
    if (r.verifyAt !== undefined && typeof r.verifyAt === "number") b = r.verifyAt;
    if (r.gracePeriod === undefined || typeof r.gracePeriod !== "number") r.gracePeriod = 0;
    if (g.exp !== undefined && typeof g.exp == "number") {
        if (g.exp + r.gracePeriod < b) return false;
    }
    if (g.nbf !== undefined && typeof g.nbf == "number") {
        if (b < g.nbf - r.gracePeriod) return false;
    }
    if (g.iat !== undefined && typeof g.iat == "number") {
        if (b < g.iat - r.gracePeriod) return false;
    }
    if (g.jti !== undefined && r.jti !== undefined) {
        if (g.jti !== r.jti) return false;
    }
    if (!o.verify(e, l, r.alg)) return false;
    return true;
};
KJUR.jws.JWS.includedArray = function(b, a) {
    var c = KJUR.jws.JWS.inArray;
    if (b === null) return false;
    if (typeof b !== "object") return false;
    if (typeof b.length !== "number") return false;
    for(var d = 0; d < b.length; d++){
        if (!c(b[d], a)) return false;
    }
    return true;
};
KJUR.jws.JWS.inArray = function(d, b) {
    if (b === null) return false;
    if (typeof b !== "object") return false;
    if (typeof b.length !== "number") return false;
    for(var c = 0; c < b.length; c++){
        if (b[c] == d) return true;
    }
    return false;
};
KJUR.jws.JWS.jwsalg2sigalg = {
    HS256: "HmacSHA256",
    HS384: "HmacSHA384",
    HS512: "HmacSHA512",
    RS256: "SHA256withRSA",
    RS384: "SHA384withRSA",
    RS512: "SHA512withRSA",
    ES256: "SHA256withECDSA",
    ES384: "SHA384withECDSA",
    ES512: "SHA512withECDSA",
    PS256: "SHA256withRSAandMGF1",
    PS384: "SHA384withRSAandMGF1",
    PS512: "SHA512withRSAandMGF1",
    none: "none"
};
KJUR.jws.JWS.isSafeJSONString = function(c, b, d) {
    var e = null;
    try {
        e = jsonParse(c);
        if (typeof e != "object") return 0;
        if (e.constructor === Array) return 0;
        if (b) b[d] = e;
        return 1;
    } catch (a) {
        return 0;
    }
};
KJUR.jws.JWS.readSafeJSONString = function(b) {
    var c = null;
    try {
        c = jsonParse(b);
        if (typeof c != "object") return null;
        if (c.constructor === Array) return null;
        return c;
    } catch (a) {
        return null;
    }
};
KJUR.jws.JWS.getEncodedSignatureValueFromJWS = function(b) {
    var a = b.match(/^[^.]+\.[^.]+\.([^.]+)$/);
    if (a == null) throw "JWS signature is not a form of 'Head.Payload.SigValue'.";
    return a[1];
};
KJUR.jws.JWS.getJWKthumbprint = function(d) {
    if (d.kty !== "RSA" && d.kty !== "EC" && d.kty !== "oct") throw "unsupported algorithm for JWK Thumprint";
    var a = "{";
    if (d.kty === "RSA") {
        if (typeof d.n != "string" || typeof d.e != "string") throw "wrong n and e value for RSA key";
        a += '"e":"' + d.e + '",';
        a += '"kty":"' + d.kty + '",';
        a += '"n":"' + d.n + '"}';
    } else {
        if (d.kty === "EC") {
            if (typeof d.crv != "string" || typeof d.x != "string" || typeof d.y != "string") throw "wrong crv, x and y value for EC key";
            a += '"crv":"' + d.crv + '",';
            a += '"kty":"' + d.kty + '",';
            a += '"x":"' + d.x + '",';
            a += '"y":"' + d.y + '"}';
        } else if (d.kty === "oct") {
            if (typeof d.k != "string") throw "wrong k value for oct(symmetric) key";
            a += '"kty":"' + d.kty + '",';
            a += '"k":"' + d.k + '"}';
        }
    }
    var b = rstrtohex(a);
    var c = KJUR.crypto.Util.hashHex(b, "sha256");
    var e = hextob64u(c);
    return e;
};
KJUR.jws.IntDate = {};
KJUR.jws.IntDate.get = function(c) {
    var b = KJUR.jws.IntDate, d = b.getNow, a = b.getZulu;
    if (c == "now") return d();
    else {
        if (c == "now + 1hour") return d() + 3600;
        else {
            if (c == "now + 1day") return d() + 86400;
            else {
                if (c == "now + 1month") return d() + 2592000;
                else {
                    if (c == "now + 1year") return d() + 31536000;
                    else {
                        if (c.match(/Z$/)) return a(c);
                        else {
                            if (c.match(/^[0-9]+$/)) return parseInt(c);
                        }
                    }
                }
            }
        }
    }
    throw "unsupported format: " + c;
};
KJUR.jws.IntDate.getZulu = function(a) {
    return zulutosec(a);
};
KJUR.jws.IntDate.getNow = function() {
    var a = ~~(new Date() / 1000);
    return a;
};
KJUR.jws.IntDate.intDate2UTCString = function(a) {
    var b = new Date(a * 1000);
    return b.toUTCString();
};
KJUR.jws.IntDate.intDate2Zulu = function(e) {
    var i = new Date(e * 1000), h = ("0000" + i.getUTCFullYear()).slice(-4), g = ("00" + (i.getUTCMonth() + 1)).slice(-2), b = ("00" + i.getUTCDate()).slice(-2), a = ("00" + i.getUTCHours()).slice(-2), c = ("00" + i.getUTCMinutes()).slice(-2), f = ("00" + i.getUTCSeconds()).slice(-2);
    return h + g + b + a + c + f + "Z";
};
if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
if (typeof KJUR.jws == "undefined" || !KJUR.jws) KJUR.jws = {};
KJUR.jws.JWSJS = function() {
    var c = KJUR, b = c.jws, a = b.JWS, d = a.readSafeJSONString;
    this.aHeader = [];
    this.sPayload = "";
    this.aSignature = [];
    this.init = function() {
        this.aHeader = [];
        this.sPayload = undefined;
        this.aSignature = [];
    };
    this.initWithJWS = function(f) {
        this.init();
        var e = f.split(".");
        if (e.length != 3) throw "malformed input JWS";
        this.aHeader.push(e[0]);
        this.sPayload = e[1];
        this.aSignature.push(e[2]);
    };
    this.addSignature = function(e, h, m, k) {
        if (this.sPayload === undefined || this.sPayload === null) throw "there's no JSON-JS signature to add.";
        var l = this.aHeader.length;
        if (this.aHeader.length != this.aSignature.length) throw "aHeader.length != aSignature.length";
        try {
            var f = KJUR.jws.JWS.sign(e, h, this.sPayload, m, k);
            var j = f.split(".");
            var n = j[0];
            var g = j[2];
            this.aHeader.push(j[0]);
            this.aSignature.push(j[2]);
        } catch (i) {
            if (this.aHeader.length > l) this.aHeader.pop();
            if (this.aSignature.length > l) this.aSignature.pop();
            throw "addSignature failed: " + i;
        }
    };
    this.verifyAll = function(h) {
        if (this.aHeader.length !== h.length || this.aSignature.length !== h.length) return false;
        for(var g = 0; g < h.length; g++){
            var f = h[g];
            if (f.length !== 2) return false;
            var e = this.verifyNth(g, f[0], f[1]);
            if (e === false) return false;
        }
        return true;
    };
    this.verifyNth = function(f, j, g) {
        if (this.aHeader.length <= f || this.aSignature.length <= f) return false;
        var h = this.aHeader[f];
        var k = this.aSignature[f];
        var l = h + "." + this.sPayload + "." + k;
        var e = false;
        try {
            e = a.verify(l, j, g);
        } catch (i) {
            return false;
        }
        return e;
    };
    this.readJWSJS = function(g) {
        if (typeof g === "string") {
            var f = d(g);
            if (f == null) throw "argument is not safe JSON object string";
            this.aHeader = f.headers;
            this.sPayload = f.payload;
            this.aSignature = f.signatures;
        } else try {
            if (g.headers.length > 0) this.aHeader = g.headers;
            else throw "malformed header";
            if (typeof g.payload === "string") this.sPayload = g.payload;
            else throw "malformed signatures";
            if (g.signatures.length > 0) this.aSignature = g.signatures;
            else throw "malformed signatures";
        } catch (e) {
            throw "malformed JWS-JS JSON object: " + e;
        }
    };
    this.getJSON = function() {
        return {
            headers: this.aHeader,
            payload: this.sPayload,
            signatures: this.aSignature
        };
    };
    this.isEmpty = function() {
        if (this.aHeader.length == 0) return 1;
        return 0;
    };
};
exports.SecureRandom = SecureRandom;
exports.rng_seed_time = rng_seed_time;
exports.BigInteger = BigInteger;
exports.RSAKey = RSAKey;
exports.ECDSA = KJUR.crypto.ECDSA;
exports.DSA = KJUR.crypto.DSA;
exports.Signature = KJUR.crypto.Signature;
exports.MessageDigest = KJUR.crypto.MessageDigest;
exports.Mac = KJUR.crypto.Mac;
//exports.Cipher = KJUR.crypto.Cipher;
exports.KEYUTIL = KEYUTIL;
exports.ASN1HEX = ASN1HEX;
exports.X509 = X509;
exports.X509CRL = X509CRL;
exports.CryptoJS = CryptoJS;
// ext/base64.js
exports.b64tohex = b64tohex;
exports.b64toBA = b64toBA;
// ext/ec*.js
exports.ECFieldElementFp = ECFieldElementFp;
exports.ECPointFp = ECPointFp;
exports.ECCurveFp = ECCurveFp;
// base64x.js
exports.stoBA = stoBA;
exports.BAtos = BAtos;
exports.BAtohex = BAtohex;
exports.stohex = stohex;
exports.stob64 = stob64;
exports.stob64u = stob64u;
exports.b64utos = b64utos;
exports.b64tob64u = b64tob64u;
exports.b64utob64 = b64utob64;
exports.hex2b64 = hex2b64;
exports.hextob64u = hextob64u;
exports.b64utohex = b64utohex;
exports.utf8tob64u = utf8tob64u;
exports.b64utoutf8 = b64utoutf8;
exports.utf8tob64 = utf8tob64;
exports.b64toutf8 = b64toutf8;
exports.utf8tohex = utf8tohex;
exports.hextoutf8 = hextoutf8;
exports.hextorstr = hextorstr;
exports.rstrtohex = rstrtohex;
exports.hextob64 = hextob64;
exports.hextob64nl = hextob64nl;
exports.b64nltohex = b64nltohex;
exports.hextopem = hextopem;
exports.pemtohex = pemtohex;
exports.hextoArrayBuffer = hextoArrayBuffer;
exports.ArrayBuffertohex = ArrayBuffertohex;
exports.zulutomsec = zulutomsec;
exports.msectozulu = msectozulu;
exports.zulutosec = zulutosec;
exports.zulutodate = zulutodate;
exports.datetozulu = datetozulu;
exports.uricmptohex = uricmptohex;
exports.hextouricmp = hextouricmp;
exports.ipv6tohex = ipv6tohex;
exports.hextoipv6 = hextoipv6;
exports.hextoip = hextoip;
exports.iptohex = iptohex;
exports.ucs2hextoutf8 = ucs2hextoutf8;
exports.encodeURIComponentAll = encodeURIComponentAll;
exports.newline_toUnix = newline_toUnix;
exports.newline_toDos = newline_toDos;
exports.hextoposhex = hextoposhex;
exports.intarystrtohex = intarystrtohex;
exports.strdiffidx = strdiffidx;
exports.oidtohex = oidtohex;
exports.hextooid = hextooid;
exports.strpad = strpad;
exports.bitstrtoint = bitstrtoint;
exports.inttobitstr = inttobitstr;
exports.bitstrtobinstr = bitstrtobinstr;
exports.binstrtobitstr = binstrtobitstr;
exports.isBase64URLDot = isBase64URLDot;
exports.namearraytobinstr = namearraytobinstr;
exports.extendClass = extendClass;
exports.foldnl = foldnl;
exports.b64topem = b64topem;
exports.pemtob64 = pemtob64;
exports.timeogen = timetogen;
exports.aryval = aryval;
exports.inttohex = inttohex;
exports.twoscompl = twoscompl;
// name spaces
exports.KJUR = KJUR;
exports.crypto = KJUR.crypto;
exports.asn1 = KJUR.asn1;
exports.jws = KJUR.jws;
exports.lang = KJUR.lang;
exports.VERSION = VERSION;
exports.VERSION_FULL = VERSION_FULL;

},{"c47b943a373324d0":"fCgem"}],"ljM1w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidTokenError", ()=>n);
function e(e) {
    this.message = e;
}
e.prototype = new Error, e.prototype.name = "InvalidCharacterError";
var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r) {
    var t = String(r).replace(/=+$/, "");
    if (t.length % 4 == 1) throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
    for(var n, o, a = 0, i = 0, c = ""; o = t.charAt(i++); ~o && (n = a % 4 ? 64 * n + o : o, a++ % 4) && (c += String.fromCharCode(255 & n >> (-2 * a & 6))))o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);
    return c;
};
function t(e) {
    var t = e.replace(/-/g, "+").replace(/_/g, "/");
    switch(t.length % 4){
        case 0:
            break;
        case 2:
            t += "==";
            break;
        case 3:
            t += "=";
            break;
        default:
            throw "Illegal base64url string!";
    }
    try {
        return function(e) {
            return decodeURIComponent(r(e).replace(/(.)/g, function(e, r) {
                var t = r.charCodeAt(0).toString(16).toUpperCase();
                return t.length < 2 && (t = "0" + t), "%" + t;
            }));
        }(t);
    } catch (e) {
        return r(t);
    }
}
function n(e) {
    this.message = e;
}
function o(e, r) {
    if ("string" != typeof e) throw new n("Invalid token specified");
    var o = !0 === (r = r || {}).header ? 0 : 1;
    try {
        return JSON.parse(t(e.split(".")[o]));
    } catch (e) {
        throw new n("Invalid token specified: " + e.message);
    }
}
n.prototype = new Error, n.prototype.name = "InvalidTokenError";
exports.default = o;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jXmGY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AppActions", ()=>AppActions);
parcelHelpers.export(exports, "ChannelActions", ()=>ChannelActions);
parcelHelpers.export(exports, "MemberActions", ()=>MemberActions);
parcelHelpers.export(exports, "PublicationActions", ()=>PublicationActions);
parcelHelpers.export(exports, "SubscriptionActions", ()=>SubscriptionActions);
const AppActions = [
    "listChannels",
    "read",
    "write"
];
const ChannelActions = [
    "write",
    "read",
    "create",
    "delete",
    "updateMetadata"
];
const MemberActions = [
    "write",
    "create",
    "delete",
    "updateMetadata",
    "signal"
];
const PublicationActions = [
    "write",
    "create",
    "delete",
    "updateMetadata",
    "enable",
    "disable"
];
const SubscriptionActions = [
    "write",
    "create",
    "delete"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3G1of":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SfuBotActions", ()=>SfuBotActions);
parcelHelpers.export(exports, "ForwardingActions", ()=>ForwardingActions);
parcelHelpers.export(exports, "SfuSubscriptionActions", ()=>SfuSubscriptionActions);
const SfuBotActions = [
    "create",
    "write",
    "delete"
];
const ForwardingActions = [
    "create",
    "write",
    "delete"
];
const SfuSubscriptionActions = [
    "create",
    "write",
    "delete"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9fPcb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eXUkm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tokenErrors", ()=>tokenErrors);
const tokenErrors = {
    invalidParameter: {
        name: "invalidParameter",
        detail: "failed to decode token",
        solution: "Use the correct token according to the specification"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"nALhG":[function(require,module,exports) {
/**@private */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nowInSec", ()=>nowInSec);
const nowInSec = ()=>Math.floor(Date.now() / 1000);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Q3u4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalCustomVideoStream", ()=>LocalCustomVideoStream);
var _common = require("@skyway-sdk/common");
var _media = require("./media");
const log = new (0, _common.Logger)("packages/core/src/media/stream/local/customVideo.ts");
class LocalCustomVideoStream extends (0, _media.LocalMediaStreamBase) {
    contentType = "video";
    _isEnabled = true;
    _promiseQueue = new (0, _common.PromiseQueue)();
    constructor(options = {}){
        super((0, _media.emptyVideoTrack), "video", options);
        this._stream = null;
    }
    /**@internal */ async setStream(processedStream) {
        if (this._stream) throw new Error("ProcessedStream is already exists");
        this._stream = processedStream;
        this._updateTrack(processedStream.track);
    }
    /**@internal */ async setEnabled(enabled) {
        await this._promiseQueue.push(async ()=>{
            await this._stream?.setEnabled(enabled);
        });
    }
    /**@internal */ async updateTrack(track) {
        this._updateTrack(track);
        this._onEnableChanged.emit(track);
    }
    get isEnabled() {
        return this._isEnabled;
    }
    release() {
        this._stream?.dispose().catch(()=>{
            log.error("release failed");
        });
    }
}

},{"@skyway-sdk/common":"3hyrG","./media":"fGBzU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hcUYM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalVideoStream", ()=>LocalVideoStream);
var _common = require("@skyway-sdk/common");
var _errors = require("../../../errors");
var _util = require("../../../util");
var _media = require("./media");
const log = new (0, _common.Logger)("packages/core/src/media/stream/local/video.ts");
class LocalVideoStream extends (0, _media.LocalMediaStreamBase) {
    contentType = "video";
    _isEnabled = true;
    _promiseQueue = new (0, _common.PromiseQueue)();
    constructor(track, options = {}){
        super(track, "video", options);
        if (track.kind !== "video") throw (0, _util.createError)({
            operationName: "LocalVideoStream.constructor",
            path: log.prefix,
            info: (0, _errors.errors).invalidTrackKind,
            payload: {
                track
            }
        });
        log.debug("LocalVideoStream spawned", this.toJSON());
    }
    /**@internal */ async setEnabled(enabled) {
        await this._promiseQueue.push(async ()=>{
            // mute
            if (this._isEnabled === true && enabled === false) {
                this._isEnabled = enabled;
                this._disable("video");
                log.debug("stopped", this.toJSON());
            } else if (this._isEnabled === false && enabled === true) {
                this._isEnabled = enabled;
                if (this._options.stopTrackWhenDisabled) {
                    const track = this._options.isDisplayMedia === true ? await this.enableDisplay() : await this.enableCamera();
                    this._updateTrack(track);
                    this._onEnableChanged.emit(track);
                } else if (this._oldTrack) {
                    this._updateTrack(this._oldTrack);
                    this._onEnableChanged.emit(this._oldTrack);
                }
                log.debug("resumed", this.toJSON());
            }
        });
    }
    get isEnabled() {
        return this._isEnabled;
    }
    async enableCamera() {
        const [track] = (await navigator.mediaDevices.getUserMedia({
            video: this.trackConstraints
        })).getVideoTracks();
        return track;
    }
    async enableDisplay() {
        const [track] = (await navigator.mediaDevices.getDisplayMedia({
            video: this.trackConstraints
        })).getVideoTracks();
        return track;
    }
}

},{"@skyway-sdk/common":"3hyrG","../../../errors":"gDbIj","../../../util":"ey5Lv","./media":"fGBzU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kiBCx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "createPublication", ()=>createPublication);
var _ = require(".");
function createPublication(channel, { publisherId , stream , origin , metadata , codecCapabilities , encodings , contentType , id , isEnabled  }) {
    const exist = channel._getPublication(id);
    if (exist) return exist;
    contentType = contentType.toLowerCase();
    const originPublication = origin ? channel._getPublication(origin) : undefined;
    // リレーされたPublicationのencodingsを設定する
    if (originPublication) {
        if (encodings.length === 0) encodings = originPublication.encodings;
    }
    const publication = new (0, _.PublicationImpl)({
        id,
        channel,
        publisher: channel._getMember(publisherId),
        contentType,
        metadata,
        origin: originPublication,
        stream,
        codecCapabilities: codecCapabilities ?? [],
        encodings,
        isEnabled
    });
    return publication;
}

},{".":"3aobm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hAw7O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "isRemoteMember", ()=>isRemoteMember);
function isRemoteMember(member) {
    if (member == undefined) return false;
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //@ts-ignore
    if (member["side"] === "remote") return true;
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ifPzB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _publishing = require("./publishing");
parcelHelpers.exportAll(_publishing, exports);
var _subscribing = require("./subscribing");
parcelHelpers.exportAll(_subscribing, exports);

},{"./publishing":"aofWj","./subscribing":"cMzOb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aofWj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PublishingAgent", ()=>PublishingAgent);
var _common = require("@skyway-sdk/common");
var _errors = require("../../../errors");
var _util = require("../../../util");
const log = new (0, _common.Logger)("packages/core/src/dataPlane/agent/publishing.ts");
class PublishingAgent {
    constructor(_localPerson){
        this._localPerson = _localPerson;
        this.context = this._localPerson.context;
    }
    /**@throws {SkyWayError} */ async startPublishing(subscription) {
        if (this.context.config.internal.disableDPlane) {
            await new Promise((r)=>setTimeout(r, 500));
            return;
        }
        const publication = subscription.publication;
        const endpoint = subscription.subscriber;
        // タイミング的にstreamのセットが完了していない可能性がある
        if (!publication.stream) await this._localPerson.onStreamPublished.watch((e)=>e.publication.id === publication.id, this.context.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "PublishingAgent.startPublishing",
                context: this.context,
                channel: this._localPerson.channel,
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "PublishingAgent onStreamPublished"
                },
                path: log.prefix,
                payload: {
                    publication
                },
                error
            });
        });
        const connection = endpoint._getOrCreateConnection(this._localPerson);
        if (connection.startPublishing) await connection.startPublishing(publication, subscription.id);
    }
    async stopPublishing(publication, endpoint) {
        const connection = endpoint._getConnection(this._localPerson.id);
        if (connection?.stopPublishing) connection.stopPublishing(publication).catch((err)=>{
            log.error("stopPublishing failed", err);
        });
    }
}

},{"@skyway-sdk/common":"3hyrG","../../../errors":"gDbIj","../../../util":"ey5Lv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cMzOb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SubscribingAgent", ()=>SubscribingAgent);
class SubscribingAgent {
    constructor(_localPerson){
        this._localPerson = _localPerson;
        this._disposers = {};
        this._context = this._localPerson.context;
    }
    async startSubscribing(subscription) {
        if (this._context.config.internal.disableDPlane) {
            await new Promise((r)=>setTimeout(r, 500));
            return;
        }
        const publisher = subscription.publication.publisher;
        const connection = publisher._getOrCreateConnection(this._localPerson);
        if (connection.startSubscribing) {
            await connection.startSubscribing(subscription);
            const { removeListener  } = subscription._onChangeEncoding.add(async ()=>{
                await connection.changePreferredEncoding?.(subscription);
            });
            this._disposers[subscription.id] = removeListener;
        }
    }
    async stopSubscribing(subscription) {
        const publisher = subscription.publication.publisher;
        const connection = publisher._getConnection(this._localPerson.id);
        if (connection?.stopSubscribing) {
            await connection.stopSubscribing(subscription);
            this._disposers[subscription.id]?.();
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9IpNZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "LocalPersonAdapter", ()=>LocalPersonAdapter);
var _common = require("@skyway-sdk/common");
class LocalPersonAdapter {
    get keepaliveIntervalSec() {
        return this._impl.keepaliveIntervalSec;
    }
    get keepaliveIntervalGapSec() {
        return this._impl.keepaliveIntervalGapSec;
    }
    get disableSignaling() {
        return this._impl.disableSignaling;
    }
    get disableAnalytics() {
        return this._impl.disableAnalytics;
    }
    get type() {
        return this._impl.type;
    }
    get subtype() {
        return this._impl.subtype;
    }
    get side() {
        return this._impl.side;
    }
    get id() {
        return this._impl.id;
    }
    get name() {
        return this._impl.name;
    }
    get channel() {
        return this._impl.channel;
    }
    get metadata() {
        return this._impl.metadata;
    }
    get state() {
        return this._impl.state;
    }
    get publications() {
        return this._impl.publications;
    }
    get subscriptions() {
        return this._impl.subscriptions;
    }
    constructor(_impl){
        this._impl = _impl;
        this._events = new (0, _common.Events)();
        this.onLeft = this._events.make();
        this.onMetadataUpdated = this._events.make();
        this.onMemberStateChanged = this._events.make();
        this.onStreamPublished = this._events.make();
        this.onStreamUnpublished = this._events.make();
        this.onPublicationListChanged = this._events.make();
        this.onPublicationSubscribed = this._events.make();
        this.onPublicationUnsubscribed = this._events.make();
        this.onSubscriptionListChanged = this._events.make();
        this.onFatalError = this._events.make();
        this.apply(_impl);
    }
    // localPersonにAdapterを適用する
    apply(person) {
        this._impl = person;
        person.onLeft.pipe(this.onLeft);
        person.onMetadataUpdated.pipe(this.onMetadataUpdated);
        person.onStreamPublished.pipe(this.onStreamPublished);
        person.onStreamUnpublished.pipe(this.onStreamUnpublished);
        person.onPublicationListChanged.pipe(this.onPublicationListChanged);
        person.onPublicationSubscribed.pipe(this.onPublicationSubscribed);
        person.onPublicationUnsubscribed.pipe(this.onPublicationUnsubscribed);
        person.onSubscriptionListChanged.pipe(this.onSubscriptionListChanged);
        person.onFatalError.pipe(this.onFatalError);
    }
    subscribe(publication, options) {
        return this._impl.subscribe(publication, options);
    }
    unsubscribe(subscription) {
        return this._impl.unsubscribe(subscription);
    }
    publish(stream, options = {}) {
        return this._impl.publish(stream, options);
    }
    unpublish(publication) {
        return this._impl.unpublish(publication);
    }
    updateMetadata(metadata) {
        return this._impl.updateMetadata(metadata);
    }
    async leave() {
        await this._impl.leave();
    }
    dispose() {
        this._impl.dispose();
    }
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4jCnb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "createLocalPerson", ()=>createLocalPerson);
var _common = require("@skyway-sdk/common");
var _token = require("@skyway-sdk/token");
var _const = require("../../const");
var _errors = require("../../errors");
var _analytics = require("../../external/analytics");
var _ice = require("../../external/ice");
var _signaling = require("../../external/signaling");
var _util = require("../../util");
var _ = require(".");
const log = new (0, _common.Logger)("packages/core/src/member/person/local/factory.ts");
async function createLocalPerson(context, channel, memberDto, { keepaliveIntervalSec , keepaliveIntervalGapSec , disableSignaling , disableAnalytics  } = {}) {
    log.debug("createLocalPerson", {
        channel,
        memberDto,
        keepaliveIntervalSec,
        keepaliveIntervalGapSec
    });
    const { iceParamServer  } = context.config;
    const signalingSession = disableSignaling === true ? undefined : await (0, _signaling.setupSignalingSession)(context, channel, memberDto);
    const decodedToken = (0, _token.SkyWayAuthToken).Decode(context.authTokenString);
    const existAnalyticsScope = decodedToken.scope.app.analytics ?? false;
    const analyticsSession = disableAnalytics === true || !existAnalyticsScope ? undefined : await (0, _analytics.setupAnalyticsSession)(context, channel, memberDto);
    const iceManager = new (0, _ice.IceManager)({
        ...iceParamServer,
        memberId: memberDto.id,
        channelId: channel.id,
        ttl: (0, _const.MaxIceParamServerTTL),
        context
    });
    await iceManager.updateIceParams().catch((err)=>{
        throw (0, _util.createError)({
            operationName: "createLocalPerson",
            context,
            channel,
            info: {
                ...(0, _errors.errors).internal,
                detail: "updateIceParams failed"
            },
            path: log.prefix,
            error: err
        });
    });
    const person = await (0, _.LocalPersonImpl).Create({
        iceManager,
        channel,
        signaling: signalingSession,
        analytics: analyticsSession,
        metadata: memberDto.metadata,
        name: memberDto.name,
        id: memberDto.id,
        keepaliveIntervalSec,
        keepaliveIntervalGapSec,
        context
    });
    for (const plugin of context.plugins){
        await plugin._whenCreateLocalPerson?.(person);
        person._onDisposed.once(async ()=>{
            await plugin._whenDisposeLocalPerson?.(person);
        });
    }
    return person;
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/token":"1nlc7","../../const":"dMcT5","../../errors":"gDbIj","../../external/analytics":"kCrov","../../external/ice":"hAK93","../../external/signaling":"gUNcI","../../util":"ey5Lv",".":"dbPdD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dMcT5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MaxIceParamServerTTL", ()=>MaxIceParamServerTTL);
const MaxIceParamServerTTL = 86400;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kCrov":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupAnalyticsSession", ()=>setupAnalyticsSession);
parcelHelpers.export(exports, "AnalyticsSession", ()=>AnalyticsSession);
parcelHelpers.export(exports, "ConnectionState", ()=>(0, _analyticsClient.ConnectionState));
var _analyticsClient = require("@skyway-sdk/analytics-client");
var _common = require("@skyway-sdk/common");
var _context = require("../context");
var _errors = require("../errors");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/core/src/external/analytics.ts");
async function setupAnalyticsSession(context, channel, memberDto) {
    const { analyticsService  } = context.config;
    const client = new (0, _analyticsClient.AnalyticsClient)({
        token: context.authTokenString,
        channelId: channel.id,
        channelName: channel.name,
        memberId: memberDto.id,
        memberName: memberDto.name,
        sdkVersion: (0, _context.SkyWayContext).version
    }, {
        logger: {
            error: async (message, error)=>{
                log.error(`AnalyticsClient error: ${message}`, (0, _util.createError)({
                    operationName: "AnalyticsClient.logger",
                    context,
                    info: {
                        ...(0, _errors.errors).internal,
                        detail: "AnalyticsClient error"
                    },
                    error,
                    path: log.prefix,
                    channel
                }));
            },
            debug: (message, ...optionalParams)=>{
                log.debug("[analytics]:", message, ...optionalParams);
            },
            warn: (message, ...optionalParams)=>{
                log.warn("[analytics]:", message, ...optionalParams);
            }
        },
        analyticsLoggingServerDomain: analyticsService.domain,
        secure: analyticsService.secure
    });
    const analyticsSession = new AnalyticsSession(client, context);
    analyticsSession.connectWithTimeout().catch((error)=>{
        analyticsSession.close();
        log.error(`AnalyticsClient error: ${error.message}`, (0, _util.createError)({
            operationName: "AnalyticsClient.logger",
            context,
            info: {
                ...(0, _errors.errors).internal,
                detail: "AnalyticsClient error"
            },
            error,
            path: log.prefix,
            channel
        }));
        analyticsSession.onConnectionFailed.emit({});
    });
    return analyticsSession;
}
class AnalyticsSession {
    constructor(client, context){
        this.client = client;
        this.context = context;
        this.onConnectionFailed = new (0, _common.Event)();
        this.onConnectionStateChanged = new (0, _common.Event)();
        this.onMessage = new (0, _common.Event)();
        this._isClosed = false;
        this._listen();
        context._onTokenUpdated.add((token)=>{
            this.client.setNewSkyWayAuthToken(token);
        });
    }
    _listen() {
        this.client.onConnectionFailed.addOneTimeListener(()=>{
            this.onConnectionFailed.emit({});
        });
        this.client.onConnectionStateChanged.addListener((state)=>{
            if (state === "closed" && !this.isClosed() && this.client.isClosed()) this.close();
            this.onConnectionStateChanged.emit(state);
        });
    }
    get connectionState() {
        return this.client.connectionState;
    }
    async _connect() {
        log.debug("[start] connect analyticsService");
        await this.client.connect().then(()=>{
            log.debug("[end] connect analyticsService");
        }).catch((error)=>{
            this.close();
            log.debug("[end] failed connect analyticsService: also unreachable to server");
            log.error(`AnalyticsClient error: ${error.message}`, (0, _util.createError)({
                operationName: "AnalyticsClient.logger",
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "AnalyticsClient error"
                },
                error,
                path: log.prefix
            }));
            this.onConnectionFailed.emit({});
        });
        return;
    }
    async connectWithTimeout() {
        let connectTimeout;
        const timeoutPromise = new Promise((_, reject)=>{
            connectTimeout = setTimeout(()=>{
                log.debug("[end] failed connect analyticsService: no initial response from the server");
                reject(new Error("failed connect analyticsService"));
            }, 30000);
        });
        return Promise.race([
            this._connect(),
            timeoutPromise
        ]).finally(()=>{
            clearTimeout(connectTimeout);
        });
    }
    close() {
        this._isClosed = true;
        this.onConnectionFailed.removeAllListeners();
        this.onConnectionStateChanged.removeAllListeners();
        this.onMessage.removeAllListeners();
    }
    isClosed() {
        return this._isClosed;
    }
}

},{"@skyway-sdk/analytics-client":"2gPP3","@skyway-sdk/common":"3hyrG","../context":"dGqOo","../errors":"gDbIj","../util":"ey5Lv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2gPP3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConnectionState", ()=>(0, _socket.ConnectionState));
parcelHelpers.export(exports, "Event", ()=>(0, _event.Event));
parcelHelpers.export(exports, "Logger", ()=>(0, _logger.Logger));
var _analyticsClient = require("./analyticsClient");
parcelHelpers.exportAll(_analyticsClient, exports);
var _socket = require("./socket");
var _event = require("./utils/event");
var _logger = require("./utils/logger");

},{"./analyticsClient":"ReYus","./socket":"leAg9","./utils/event":"lsW6p","./utils/logger":"cw1eI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ReYus":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnalyticsClient", ()=>AnalyticsClient);
var _clientEvent = require("./clientEvent");
var _payloadTypes = require("./payloadTypes");
var _socket = require("./socket");
var _backoff = require("./utils/backoff");
var _event = require("./utils/event");
const ANALYTICS_LOGGING_SERVER_DOMAIN = "analytics-logging.skyway.ntt.com";
const API_VERSION = "v1";
const TIMEOUT_SEC = 5;
class AnalyticsClient {
    onConnectionStateChanged = new (0, _event.Event)();
    onConnectionFailed = new (0, _event.Event)();
    _isClosed = false;
    _responseCallbacks = new Map();
    _acknowledgeCallbacks = new Map();
    _mediaDeviceVersion = new Map();
    _encodingsVersion = new Map();
    _preferredEncodingVersion = new Map();
    _previousSubscriptionStats = new Map();
    _statsRequest = {
        // connect()時のopenServerEventPayload.statsRequest代入でそれぞれ値が入るが，一度初期値として定義しておく
        intervalSec: 5,
        types: []
    };
    constructor({ token , channelId , channelName , memberId , memberName , sdkVersion  }, options){
        this._token = token;
        this._newToken = undefined;
        this._channelId = channelId;
        this._channelName = channelName;
        this._memberId = memberId;
        this._memberName = memberName;
        this._sdkVersion = sdkVersion;
        const defaultOptions = {
            analyticsLoggingServerDomain: ANALYTICS_LOGGING_SERVER_DOMAIN,
            secure: true,
            logger: {
                debug: (message, ...optionalParams)=>{
                    console.debug(message, ...optionalParams);
                },
                warn: (message, ...optionalParams)=>{
                    console.warn(message, ...optionalParams);
                },
                error: (error)=>{
                    console.error(error);
                }
            }
        };
        this._options = Object.assign({}, defaultOptions, options ?? {});
        this._logger = this._options.logger;
        this._logger.debug(`Created instance with the options: ${this._options}`);
    }
    get connectionState() {
        return this._socket?.connectionState ?? "closed";
    }
    async connect() {
        const WSProtocol = this._options.secure ? "wss" : "ws";
        const analyticsLoggingServerDomain = this._options.analyticsLoggingServerDomain || ANALYTICS_LOGGING_SERVER_DOMAIN;
        this._socket = new (0, _socket.Socket)({
            sessionEndpoint: `${WSProtocol}://${analyticsLoggingServerDomain}/${API_VERSION}/client/ws`,
            channelId: this._channelId,
            channelName: this._channelName,
            memberId: this._memberId,
            memberName: this._memberName,
            token: this._token,
            logger: this._logger,
            sdkVersion: this._sdkVersion
        });
        this._socket.onEventReceived.addListener((data)=>{
            try {
                this._eventReceivedHandler(data);
            } catch (error) {
                this._logger.error("in _eventReceivedHandler", error);
            }
        });
        this._socket.onConnectionFailed.addListener(()=>{
            this.onConnectionFailed.emit();
            this._cleanupAnalyticsClientMaps();
        });
        this._socket.onConnectionStateChanged.addListener((state)=>{
            if (state === "closed" && !this.isClosed() && this._socket?.isClosed()) {
                this._isClosed = true;
                this.dispose();
            }
            this.onConnectionStateChanged.emit(state);
        });
        this._socket.onTokenExpired.addListener(()=>{
            this._reconnectWithNewSkyWayAuthToken();
        });
        const openServerEventPayload = await this._socket.onOpened.asPromise();
        if (openServerEventPayload !== undefined) {
            this._statsRequest = openServerEventPayload.statsRequest;
            return;
        } else {
            this._logger.error("First time connection payload is undefined", new Error());
            this.onConnectionFailed.emit();
            return;
        }
    }
    dispose() {
        this._disconnect();
        this._cleanupAnalyticsClientMaps();
    }
    setNewSkyWayAuthToken(token) {
        if (this._socket !== undefined) {
            this._newToken = token;
            this._logger.debug("setNewSkyWayAuthToken is success");
        }
    }
    cleanupOnUnpublished(publicationId) {
        this._mediaDeviceVersion.delete(publicationId);
        this._encodingsVersion.delete(publicationId);
    }
    cleanupOnUnsubscribed(subscriptionId) {
        this._preferredEncodingVersion.delete(subscriptionId);
        this._previousSubscriptionStats.delete(subscriptionId);
    }
    _disconnect() {
        this._socket?.destroy();
        this._socket = undefined;
        this._responseCallbacks.clear();
        this._acknowledgeCallbacks.clear();
    }
    async sendMediaDeviceReport(report) {
        let currentMediaDeviceVersion = this._mediaDeviceVersion.get(report.publicationId);
        if (currentMediaDeviceVersion === undefined) currentMediaDeviceVersion = 0;
        else currentMediaDeviceVersion++;
        this._mediaDeviceVersion.set(report.publicationId, currentMediaDeviceVersion);
        const payload = {
            publicationId: report.publicationId,
            mediaDeviceName: report.mediaDeviceName,
            mediaDeviceVersion: currentMediaDeviceVersion,
            mediaDeviceTrigger: report.mediaDeviceTrigger,
            updatedAt: report.updatedAt
        };
        const clientEvent = new (0, _clientEvent.ClientEvent)("MediaDeviceReport", payload);
        await this._sendClientEvent(clientEvent).catch((err)=>{
            this._logger.warn("_sendClientEvent in sendMediaDeviceReport is failed", err);
        });
    }
    async sendBindingRtcPeerConnectionToSubscription(bindingData) {
        const clientEvent = new (0, _clientEvent.ClientEvent)("BindingRtcPeerConnectionToSubscription", bindingData);
        await this._sendClientEvent(clientEvent).catch((err)=>{
            this._logger.warn("_sendClientEvent in sendBindingRtcPeerConnectionToSubscription is failed", err);
        });
    }
    _isDataChannelStatsReport(report) {
        const castedStatsReport = {};
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore RTCStatsReportの型エラー回避(TS2339: Property 'values' does not exist on type 'RTCStatsReport'.)
        for (const rtcStatsReportValue of report.values())castedStatsReport[rtcStatsReportValue.type] = rtcStatsReportValue;
        if (castedStatsReport && "data-channel" in castedStatsReport) return true;
        else return false;
    }
    /**
   * DataChannelのstatsReportのobjectを処理する際の判定用関数
   * 'data-channel', 'local-candidate', 'candidate-pair' が現在対象
   * 'candidate-pair' の場合は nominated:true のもののみをtrueとする
   */ _isTargetTypeOfStatsReport(report, targetType) {
        if (!report) return false;
        for (const type of targetType)if (report.type === type) {
            if (type === "data-channel" || type === "local-candidate") return true;
            else if (type === "candidate-pair") {
                // 'candidate-pair' の場合は nominated:true のものであるかを確認
                if ("nominated" in report && report.nominated === true) return true;
            }
        }
        // すべてのtypeに一致しない場合や条件に当てはまらない場合はfalse
        return false;
    }
    async sendSubscriptionStatsReport(report, subscriptionParams) {
        const previousSubscriptionStat = this._previousSubscriptionStats.get(subscriptionParams.subscriptionId);
        this._previousSubscriptionStats.set(subscriptionParams.subscriptionId, {
            stats: report,
            createdAt: subscriptionParams.createdAt
        });
        if (previousSubscriptionStat === undefined) // 初回の場合は時間あたりの値が出せないので送信しない
        return;
        const previousCreatedAt = previousSubscriptionStat.createdAt;
        const duration = (subscriptionParams.createdAt - previousCreatedAt) / 1000; // mills to sec.
        if (duration <= 0) throw new Error("duration must be greater than 0. also sendSubscriptionStatsReport was duplicated.");
        const isDataChannelStatsReport = this._isDataChannelStatsReport(report);
        const filteredStats = {};
        for (const statsRequestType of this._statsRequest.types)Object.keys(statsRequestType.properties).forEach((key)=>{
            const isNeedNormalization = statsRequestType.properties[key].normalization;
            const outputKey = statsRequestType.properties[key].outputKey;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore RTCStatsReportの型エラー回避(TS2339: Property 'values' does not exist on type 'RTCStatsReport'.)
            for (const rtcStatsReportValue of report.values()){
                if (rtcStatsReportValue.type !== statsRequestType.type) continue;
                Object.keys(rtcStatsReportValue).forEach((statName)=>{
                    if (statName === key) {
                        // 時折プロパティがない場合があるため，今回分のデータをチェックしておく
                        if (!rtcStatsReportValue || !(statName in rtcStatsReportValue)) {
                            this._logger.warn(`statsReport key:${statName} in current statsReport is undefined`);
                            return;
                        }
                        if (isNeedNormalization) {
                            // 前回分のデータを使って時間あたりの値を計算する必要があるフィールドについてはこちらで処理
                            /**
                 * idは接続が続いている間同じ値を取るので,前回保持したstatsから値を取り出す際に利用する
                 * https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport#common_instance_properties
                 */ // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                            // @ts-ignore RTCStatsReportの型エラー回避(TS2339: Property 'get' does not exist on type 'RTCStatsReport')
                            const previousObject = previousSubscriptionStat.stats.get(rtcStatsReportValue.id);
                            // 時折プロパティがない場合があるため，前回分のデータをチェックしておく
                            if (!previousObject || !(key in previousObject)) {
                                this._logger.warn(`statsReport key:${key} in previous statsReport is undefined`);
                                return;
                            }
                            const previousValue = Number(previousObject[key]);
                            const perSecondValue = (Number(rtcStatsReportValue[statName]) - previousValue) / duration;
                            if (isDataChannelStatsReport) {
                                // 'data-channel'の場合はbytesSent/bytesReceivedの両方とも格納されてしまうのでroleによって切り替える
                                if (this._isTargetTypeOfStatsReport(rtcStatsReportValue, [
                                    "data-channel"
                                ])) {
                                    if (subscriptionParams.role === "sender") {
                                        if (statName === "bytesSent") filteredStats[statsRequestType.type] = {
                                            ...filteredStats[statsRequestType.type],
                                            [outputKey]: String(perSecondValue)
                                        };
                                    } else if (statName === "bytesReceived") filteredStats[statsRequestType.type] = {
                                        ...filteredStats[statsRequestType.type],
                                        [outputKey]: String(perSecondValue)
                                    };
                                } else if (this._isTargetTypeOfStatsReport(rtcStatsReportValue, [
                                    "local-candidate",
                                    "candidate-pair"
                                ])) filteredStats[statsRequestType.type] = {
                                    ...filteredStats[statsRequestType.type],
                                    [outputKey]: String(perSecondValue)
                                };
                            } else /**
                   * this._statsRequest で保持している変換用のobjectは同一のkeyが複数回出てくるので，上書きしないためにスプレッド構文を利用する．
                   * またServer側で受け付けているstatsの値はstringなので変換してやる必要あり．
                   */ filteredStats[statsRequestType.type] = {
                                ...filteredStats[statsRequestType.type],
                                [outputKey]: String(perSecondValue)
                            };
                        } else {
                            // 時間あたりの値を計算する必要がないフィールドはこちらで処理
                            if (isDataChannelStatsReport) {
                                if (this._isTargetTypeOfStatsReport(rtcStatsReportValue, [
                                    "data-channel",
                                    "local-candidate",
                                    "candidate-pair"
                                ])) {
                                    if (rtcStatsReportValue.type === "candidate-pair") // 'candidate-pair'はvideo/audioがある場合，他のフィールド:availableOutgoingBitrateも入ってきてしまうため必要なものに限定する
                                    {
                                        if (statName === "currentRoundTripTime") filteredStats[statsRequestType.type] = {
                                            ...filteredStats[statsRequestType.type],
                                            [outputKey]: String(rtcStatsReportValue[statName])
                                        };
                                    } else filteredStats[statsRequestType.type] = {
                                        ...filteredStats[statsRequestType.type],
                                        [outputKey]: String(rtcStatsReportValue[statName])
                                    };
                                }
                            } else filteredStats[statsRequestType.type] = {
                                ...filteredStats[statsRequestType.type],
                                [outputKey]: String(rtcStatsReportValue[statName])
                            };
                        }
                    }
                });
            }
        });
        const payload = {
            subscriptionId: subscriptionParams.subscriptionId,
            stats: filteredStats,
            role: subscriptionParams.role,
            createdAt: subscriptionParams.createdAt
        };
        const clientEvent = new (0, _clientEvent.ClientEvent)("SubscriptionStatsReport", payload);
        await this._sendClientEvent(clientEvent).catch((err)=>{
            this._logger.warn("_sendClientEvent in sendSubscriptionStatsReport is failed", err);
        });
    }
    async sendRtcPeerConnectionEventReport(report) {
        const clientEvent = new (0, _clientEvent.ClientEvent)("RtcPeerConnectionEventReport", report);
        await this._sendClientEvent(clientEvent).catch((err)=>{
            this._logger.warn("_sendClientEvent in sendRtcPeerConnectionEventReport is failed", err);
        });
    }
    async sendPublicationUpdateEncodingsReport(report) {
        let currentEncodingsVersion = this._encodingsVersion.get(report.publicationId);
        if (currentEncodingsVersion === undefined) currentEncodingsVersion = 0;
        else currentEncodingsVersion++;
        this._encodingsVersion.set(report.publicationId, currentEncodingsVersion);
        const payload = {
            publicationId: report.publicationId,
            encodings: report.encodings,
            encodingsVersion: currentEncodingsVersion,
            updatedAt: report.updatedAt
        };
        const clientEvent = new (0, _clientEvent.ClientEvent)("PublicationUpdateEncodingsReport", payload);
        await this._sendClientEvent(clientEvent).catch((err)=>{
            this._logger.warn("_sendClientEvent in sendPublicationUpdateEncodingsReport is failed", err);
        });
    }
    async sendSubscriptionUpdatePreferredEncodingReport(report) {
        let currentPreferredEncodingVersion = this._preferredEncodingVersion.get(report.subscriptionId);
        if (currentPreferredEncodingVersion === undefined) currentPreferredEncodingVersion = 0;
        else currentPreferredEncodingVersion++;
        this._preferredEncodingVersion.set(report.subscriptionId, currentPreferredEncodingVersion);
        const payload = {
            subscriptionId: report.subscriptionId,
            preferredEncodingIndex: report.preferredEncodingIndex,
            preferredEncodingVersion: currentPreferredEncodingVersion,
            updatedAt: report.updatedAt
        };
        const clientEvent = new (0, _clientEvent.ClientEvent)("SubscriptionUpdatePreferredEncodingReport", payload);
        await this._sendClientEvent(clientEvent).catch((err)=>{
            this._logger.warn("_sendClientEvent in sendSubscriptionUpdatePreferredEncodingReport is failed", err);
        });
    }
    async _sendClientEvent(clientEvent) {
        return new Promise(async (resolve, reject)=>{
            if (this._socket === undefined || this._socket.connectionState === "closed") {
                reject(new Error("websocket is not connected"));
                return;
            }
            // 初回の接続に時間がかかっている場合はここで再送用のキューとacknowledgeのリストに入れる
            if (this._socket.connectionState === "connecting") {
                this._socket.pushResendClientEventsQueue(clientEvent);
                this._setAcknowledgeCallback(clientEvent.id, async (data)=>{
                    if (data.ok) {
                        this._acknowledgeCallbacks.delete(clientEvent.id);
                        resolve();
                    } else {
                        this._acknowledgeCallbacks.delete(clientEvent.id);
                        reject(data);
                    }
                });
                this._logger.debug(`pushResendClientEventsQueue and setAcknowledgeCallback. clientEvent.id: ${clientEvent.id}`);
                reject(new Error("websocket is connecting now"));
                return;
            }
            const backoff = new (0, _backoff.BackOff)({
                times: 6,
                interval: 500,
                jitter: 100
            });
            for(; !backoff.exceeded;){
                const timer = setTimeout(async ()=>{
                    if (this._socket === undefined) {
                        this._acknowledgeCallbacks.delete(clientEvent.id);
                        reject(new Error("Socket closed when trying to resend"));
                        return;
                    } else this._socket.resendAfterReconnect(clientEvent);
                    reject(new Error("Timeout to send data"));
                    return;
                }, TIMEOUT_SEC * 1000);
                // 送信に失敗した際の再送ロジックはsend()内で処理される
                this._logger.debug(`send clientEvent, ${JSON.stringify(clientEvent)}`);
                this._socket.send(clientEvent).catch((err)=>{
                    this._acknowledgeCallbacks.delete(clientEvent.id);
                    clearTimeout(timer);
                    reject(err);
                    return;
                });
                /**
         * _waitForAcknowledgeはresultに次の2種類の値を返す
         * 1. undefined: 送信が成功し、undefinedでresolveされた場合
         * 2. AcknowledgePayload型の値:送信は成功したがサーバーから ok: false のacknowledgeが返されたため、acknowledge payloadでrejectされた場合
         * 何らかのエラーによってrejectされた場合:
         * これは_messageHandlerで弾かれるので考慮しなくて良い．
         */ const result = await this._waitForAcknowledge(clientEvent.id).catch((err)=>{
                    return err;
                });
                clearTimeout(timer);
                if ((0, _payloadTypes.isAcknowledgePayload)(result)) {
                    if (result.reason === "unexpected") await backoff.wait();
                    else {
                        reject(result);
                        return;
                    }
                } else {
                    resolve();
                    return;
                }
            }
            reject(new Error("unexpected has occurred at server"));
            return;
        });
    }
    async _waitForAcknowledge(clientEventId) {
        return new Promise((resolve, reject)=>{
            this._setAcknowledgeCallback(clientEventId, async (data)=>{
                if (data.ok) {
                    this._acknowledgeCallbacks.delete(clientEventId);
                    resolve();
                } else {
                    this._acknowledgeCallbacks.delete(clientEventId);
                    reject(data);
                }
            });
        });
    }
    async _reconnectWithNewSkyWayAuthToken() {
        this._disconnect();
        if (this._newToken !== undefined) {
            this._token = this._newToken;
            this._newToken = undefined;
            await this.connect();
        } else this._logger.warn("new token is not set. so not reconnect.");
    }
    _eventReceivedHandler(data) {
        switch(data.type){
            case "Acknowledge":
                this._acknowledgeHandler(data.payload);
                break;
            case "Open":
                break; // nop
            default:
                {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const _ = data.type;
                    this._logger.warn(`Unknown event: ${data.type}`);
                }
        }
    }
    _acknowledgeHandler(payload) {
        if (!(0, _payloadTypes.isAcknowledgePayload)(payload)) throw new Error("Invalid payload");
        const { eventId  } = payload;
        if (!this._acknowledgeCallbacks.has(eventId)) throw new Error(`acknowledge event has unknown eventId: ${eventId}`);
        const callback = this._acknowledgeCallbacks.get(eventId);
        if (callback) {
            this._acknowledgeCallbacks.delete(eventId);
            callback(payload);
        }
    }
    _setAcknowledgeCallback(eventId, callback) {
        this._acknowledgeCallbacks.set(eventId, callback);
    }
    _cleanupAnalyticsClientMaps() {
        this._mediaDeviceVersion.clear();
        this._encodingsVersion.clear();
        this._preferredEncodingVersion.clear();
        this._previousSubscriptionStats.clear();
    }
    getIntervalSec() {
        return this._statsRequest.intervalSec;
    }
    isConnectionEstablished() {
        if (!this._socket || this._socket.connectionState === "connecting" || this._socket.connectionState === "closed") return false;
        else return true;
    }
    isClosed() {
        return this._isClosed;
    }
}

},{"./clientEvent":"lXgIz","./payloadTypes":"3F5Pi","./socket":"leAg9","./utils/backoff":"9IpMM","./utils/event":"lsW6p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lXgIz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ClientEvent", ()=>ClientEvent);
var _uuid = require("uuid");
class ClientEvent {
    constructor(type, payload){
        this.id = (0, _uuid.v4)();
        this.type = type;
        this.payload = payload;
    }
    toJSON() {
        return {
            id: this.id,
            type: this.type,
            payload: this.payload
        };
    }
}

},{"uuid":"8syZB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8syZB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":false,"./v3.js":false,"./v4.js":"4jANr","./v5.js":false,"./nil.js":false,"./version.js":false,"./validate.js":"iHTjg","./stringify.js":"f5EyE","./parse.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4jANr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeJs = require("./native.js");
var _nativeJsDefault = parcelHelpers.interopDefault(_nativeJs);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
function v4(options, buf, offset) {
    if ((0, _nativeJsDefault.default).randomUUID && !buf && !options) return (0, _nativeJsDefault.default).randomUUID();
    options = options || {};
    const rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJs.unsafeStringify)(rnds);
}
exports.default = v4;

},{"./native.js":"8Kbum","./rng.js":"e5jMK","./stringify.js":"f5EyE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Kbum":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports.default = {
    randomUUID
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5jMK":[function(require,module,exports) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return getRandomValues(rnds8);
}
exports.default = rng;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f5EyE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeStringify", ()=>unsafeStringify);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"iHTjg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iHTjg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === "string" && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"esKvk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"esKvk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3F5Pi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isRecord", ()=>isRecord);
parcelHelpers.export(exports, "isOpenServerEventPayload", ()=>isOpenServerEventPayload);
parcelHelpers.export(exports, "isAcknowledgePayload", ()=>isAcknowledgePayload);
function isRecord(arg) {
    if (typeof arg !== "object") return false;
    if (arg === null) return false;
    if (Array.isArray(arg)) return false;
    return true;
}
function isOpenServerEventPayload(payload) {
    if (!payload || typeof payload !== "object") return false;
    if (!payload.statsRequest || typeof payload.statsRequest !== "object") return false;
    if (!payload.statsRequest.intervalSec || typeof payload.statsRequest.intervalSec !== "number") return false;
    if (!payload.statsRequest.types || !Array.isArray(payload.statsRequest.types)) return false;
    for (const statsRequestType of payload.statsRequest.types){
        if (!statsRequestType.type || typeof statsRequestType.type !== "string") return false;
        if (!statsRequestType.properties || !isRecord(statsRequestType.properties)) return false;
        for (const key of Object.keys(statsRequestType.properties)){
            if (!("normalization" in statsRequestType.properties[key]) || typeof statsRequestType.properties[key].normalization !== "boolean") return false;
            if (!statsRequestType.properties[key].outputKey || typeof statsRequestType.properties[key].outputKey !== "string") return false;
        }
    }
    return true;
}
const AcknowledgeReason = [
    "invalidPayload",
    "unexpected"
];
function isAcknowledgePayload(payload) {
    if (!payload || typeof payload !== "object") return false;
    if (typeof payload.eventId !== "string") return false;
    if (typeof payload.ok !== "boolean") return false;
    if (typeof payload.reason !== "undefined" && (typeof payload.reason !== "string" || !AcknowledgeReason.includes(payload.reason))) return false;
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"leAg9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Socket", ()=>Socket);
var _isomorphicWs = require("isomorphic-ws");
var _isomorphicWsDefault = parcelHelpers.interopDefault(_isomorphicWs);
var _payloadTypes = require("./payloadTypes");
var _event = require("./utils/event");
const ServerEventType = [
    "Open",
    "Acknowledge"
];
const getReconnectWaitTime = (reconnectCount)=>{
    return (2 ** reconnectCount + Math.random()) * 1000;
};
class Socket {
    _isOpen = false;
    _isClosed = false;
    _reconnectCount = 0;
    connectionState = "connecting";
    onConnectionStateChanged = new (0, _event.Event)();
    onOpened = new (0, _event.Event)();
    onTokenExpired = new (0, _event.Event)();
    onEventReceived = new (0, _event.Event)();
    onConnectionFailed = new (0, _event.Event)();
    _resendClientEvents = [];
    constructor({ channelId , channelName , memberId , memberName , sessionEndpoint , token , logger , sdkVersion  }){
        this._sessionEndpoint = sessionEndpoint;
        this._channelId = channelId;
        this._channelName = channelName;
        this._memberId = memberId;
        this._memberName = memberName;
        this._token = token;
        this._logger = logger;
        this._sdkVersion = sdkVersion;
        this._connect();
    }
    _setConnectionState(state) {
        if (this.connectionState === state) return;
        this._logger.debug(`connectionState changed : ${state}`);
        this.connectionState = state;
        this.onConnectionStateChanged.emit(state);
    }
    _connect() {
        let ws;
        try {
            // We use the SubProtocol header to send the token.
            // This is because the browser's WebSocket class does not allow the header to be changed freely.
            const subProtocol = `SkyWayAuthToken!${this._token}`;
            const wsProperties = {
                channelId: this._channelId,
                channelName: this._channelName,
                memberId: this._memberId,
                memberName: this._memberName,
                sdkPlatform: "js",
                sdkVersion: this._sdkVersion
            };
            const queryString = Object.entries(wsProperties).filter(([_, v])=>v !== undefined).map((pair)=>pair.join("=")).join("&");
            const wsURL = `${this._sessionEndpoint}?${queryString}`;
            ws = new (0, _isomorphicWsDefault.default)(wsURL, subProtocol);
            this._logger.debug(`Connecting to analytics-logging-server: ${this._sessionEndpoint}`);
            ws.onerror = (event)=>{
                this._logger.error("WebSocket error occurred", event.error);
                ws.close(4202);
            };
        } catch (err) {
            const error = err instanceof Error ? err : new Error();
            this._logger.error("Failed to create WebSocket instance", error);
            this.reconnect();
            return;
        }
        ws.onopen = ()=>{
            this._logger.debug("Connected to analytics-logging-server");
        };
        ws.onclose = (event)=>{
            const logMessage = "Close event fired: " + JSON.stringify({
                code: event.code,
                reason: event.reason,
                type: event.type
            });
            // 1000, 4000~4099: normal case (should not reconnect)
            // 4100~4199: non-normal case (should not reconnect)
            // 4200~4299: non-normal case (should reconnect)
            // others: unexpected case (should reconnect)
            if (4100 <= event.code && event.code <= 4199) this._logger.error(logMessage, new Error());
            else this._logger.debug(logMessage);
            if (event.code !== 1000 && !(4000 <= event.code && event.code <= 4199)) {
                if (4200 === event.code) this.onTokenExpired.emit();
                else this.reconnect();
                return;
            }
            // Return not to destroy _ws successfully reconnected
            if (event.code === 4000) return;
            this._logger.debug("Closed the connection to analytics-logging-server");
            this.onConnectionFailed.emit();
            this.close();
        };
        ws.onmessage = (event)=>{
            this._messageHandler(event.data);
        };
        this._ws = ws;
    }
    updateAuthToken(token) {
        this._token = token;
    }
    reconnect() {
        if (this._ws !== undefined) this._ws.close(4000);
        this._ws = undefined;
        this._isOpen = false;
        // getReconnectWaitTime により30秒程まで再試行するため5を指定している
        if (this._reconnectCount >= 5) {
            this.onConnectionFailed.emit();
            this.close();
            this._logger.error("Failed to reconnect for five times", new Error());
        } else {
            this._setConnectionState("reconnecting");
            const waitTime = getReconnectWaitTime(this._reconnectCount);
            this._reconnectTimer = setTimeout(()=>{
                this._connect();
                this._reconnectCount++;
                this._logger.debug(`Try to reconnect: count = ${this._reconnectCount}`);
            }, waitTime);
        }
    }
    close() {
        this._isClosed = true;
        this.destroy();
    }
    destroy() {
        this._setConnectionState("closed");
        this.onConnectionStateChanged.removeAllListeners();
        this.onOpened.removeAllListeners();
        this.onEventReceived.removeAllListeners();
        this.onConnectionFailed.removeAllListeners();
        if (this._reconnectTimer) clearTimeout(this._reconnectTimer);
        if (this._ws !== undefined) this._ws.close(1000);
    }
    async send(clientEvent) {
        if (this._ws === undefined || !this._isOpen || this._ws.readyState !== (0, _isomorphicWsDefault.default).OPEN) {
            this._logger.debug("Try to reconnect because connection is lost");
            this.resendAfterReconnect(clientEvent);
            return;
        }
        const data = JSON.stringify(clientEvent.toJSON());
        this._ws.send(data, (err)=>{
            if (err) {
                this._logger.debug(`Try to reconnect because failed to send: ${err.message}`);
                this.resendAfterReconnect(clientEvent);
                return;
            }
        });
    }
    resendAfterReconnect(data) {
        const isEventExist = this._resendClientEvents.some((event)=>event.id === data.id);
        if (!isEventExist) this._resendClientEvents.push(data);
        // この関数が複数回呼ばれた際に再接続の試行が重複しないよう、connectionStateを確認してから再接続する
        if (this.connectionState !== "reconnecting") this.reconnect();
    }
    pushResendClientEventsQueue(data) {
        this._resendClientEvents.push(data);
    }
    isClosed() {
        return this._isClosed;
    }
    _messageHandler(data) {
        if (typeof data !== "string") {
            this._logger.error("Received invalid message: not string", new Error());
            return;
        }
        let parsedData;
        try {
            parsedData = JSON.parse(data);
        } catch (err) {
            const error = err instanceof Error ? err : new Error();
            this._logger.error("Received invalid message: parse error", error);
            return;
        }
        if (!isServerEvent(parsedData)) {
            this._logger.error(`Received invalid message: ${JSON.stringify(parsedData)}`, new Error());
            return;
        }
        if (parsedData.type === "Open") {
            if (!(0, _payloadTypes.isOpenServerEventPayload)(parsedData.payload)) {
                this._logger.error(`Received invalid message: ${JSON.stringify(parsedData.payload)}`, new Error());
                return;
            }
            this._logger.debug("Received a open event");
            this._isOpen = true;
            this._setConnectionState("connected");
            if (this._reconnectCount !== 0) {
                this._reconnectCount = 0;
                this._logger.debug("Succeeded to reconnect");
            }
            if (this._resendClientEvents.length > 0) {
                for (const event of this._resendClientEvents){
                    if (this._ws === undefined || !this._isOpen || this._ws.readyState !== (0, _isomorphicWsDefault.default).OPEN) {
                        this._logger.error(`Failed to resend event because connection lost after reconnect: ${event}`, new Error());
                        continue;
                    }
                    const data = JSON.stringify(event.toJSON());
                    this._ws.send(data, (err)=>{
                        if (err) {
                            this._logger.error(`Failed to resend event: ${event}`, err);
                            return;
                        }
                        this._logger.debug(`Succeed to resend ClientEvent: ${event}`);
                    });
                }
                this._logger.debug("Process of resending ClientEvents is completed");
                this._resendClientEvents = [];
            }
            this.onOpened.emit(parsedData.payload);
        } else {
            this._logger.debug(`Received the event: ${parsedData.type}, payload: ${JSON.stringify(parsedData.payload)}`);
            this.onEventReceived.emit(parsedData);
        }
    }
}
function isServerEvent(data) {
    if (!data || typeof data !== "object") return false;
    if (typeof data.type !== "string" || !ServerEventType.includes(data.type)) return false;
    if (typeof data.id !== "string") return false;
    if (data.payload && typeof data.payload !== "object") return false;
    return true;
}

},{"isomorphic-ws":"5nVUE","./payloadTypes":"3F5Pi","./utils/event":"lsW6p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5nVUE":[function(require,module,exports) {
// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js
var global = arguments[3];
var ws = null;
if (typeof WebSocket !== "undefined") ws = WebSocket;
else if (typeof MozWebSocket !== "undefined") ws = MozWebSocket;
else if (typeof global !== "undefined") ws = global.WebSocket || global.MozWebSocket;
else if (typeof window !== "undefined") ws = window.WebSocket || window.MozWebSocket;
else if (typeof self !== "undefined") ws = self.WebSocket || self.MozWebSocket;
module.exports = ws;

},{}],"lsW6p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Event", ()=>Event);
class Event {
    _listeners = new Map();
    _listenerIndex = 0;
    emit = (arg)=>{
        this._listeners.forEach((listener)=>listener(arg));
    };
    removeAllListeners = ()=>{
        this._listeners.clear();
    };
    addListener = (listener)=>{
        const id = this._listenerIndex;
        this._listeners.set(id, listener);
        this._listenerIndex++;
        const removeListener = ()=>{
            this._listeners.delete(id);
        };
        return {
            removeListener
        };
    };
    addOneTimeListener = (listener)=>{
        const off = this.addListener((arg)=>{
            off.removeListener();
            listener(arg);
        });
        return off;
    };
    asPromise = (timeLimit)=>new Promise((resolve, reject)=>{
            let removeListener = ()=>{};
            const timeout = timeLimit && setTimeout(()=>{
                reject("Event asPromise timeout");
                removeListener();
            }, timeLimit);
            const off = this.addOneTimeListener((arg)=>{
                if (timeout) clearTimeout(timeout);
                resolve(arg);
            });
            removeListener = off.removeListener;
        });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9IpMM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BackOff", ()=>BackOff);
class BackOff {
    count = 0;
    times = 8;
    /**ms */ interval = 100;
    /**ms */ jitter = 0;
    /**20.4 sec {var sum=0;for(i=0;i<=8;i++){sum +=i ** 2 * 100}} */ constructor(props = {}){
        Object.assign(this, props);
    }
    async wait() {
        if (this.exceeded) return false;
        const timeout = this.timeout;
        this.count++;
        await new Promise((r)=>setTimeout(r, timeout));
        return true;
    }
    get timeout() {
        const timeout = this.count ** 2 * this.interval + this.count ** 2 * this.jitter * Math.random();
        return timeout;
    }
    get exceeded() {
        return this.count >= this.times;
    }
    reset() {
        this.count = 0;
    }
    stop() {
        this.count = this.times;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cw1eI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dGqOo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SkyWayContext", ()=>SkyWayContext);
var _common = require("@skyway-sdk/common");
var _rtcApiClient = require("@skyway-sdk/rtc-api-client");
var _token = require("@skyway-sdk/token");
var _config = require("./config");
var _errors = require("./errors");
var _plugin = require("./plugin/internal/person/plugin");
var _plugin1 = require("./plugin/internal/unknown/plugin");
var _util = require("./util");
var _version = require("./version");
const log = new (0, _common.Logger)("packages/core/src/context.ts");
class SkyWayContext {
    /**@internal */ static version = (0, _version.PACKAGE_VERSION);
    /**
   * @description [japanese] Contextの作成
   */ static async Create(authTokenString, configOptions = {}) {
        const config = new (0, _config.ContextConfig)(configOptions);
        (0, _common.Logger).level = config.log.level;
        (0, _common.Logger).format = config.log.format;
        const token = (0, _token.SkyWayAuthToken).Decode(authTokenString);
        const { osName , osVersion , browserName , browserVersion  } = (0, _util.getRuntimeInfo)();
        const runtime = {
            sdkName: "core",
            sdkVersion: this.version,
            osName,
            osVersion,
            browserName,
            browserVersion
        };
        const endpoint = {
            rapi: config.rtcApi.domain,
            signaling: config.signalingService.domain,
            ice: config.iceParamServer.domain
        };
        log.info("core sdk spawned", {
            operationName: "SkyWayContext.Create",
            runtime,
            endpoint,
            config,
            token
        });
        try {
            const api = await (0, _rtcApiClient.RtcApiClient).Create({
                appId: token.scope.app.id,
                token: authTokenString,
                log: config.log,
                rtcApi: config.rtcApi
            });
            const context = new SkyWayContext(api, config, token, {
                endpoint,
                runtime
            });
            await context._setTokenExpireTimer();
            return context;
        } catch (error) {
            throw (0, _util.createError)({
                operationName: "SkyWayContext.Create",
                info: (0, _errors.errors).connectRtcApiFailed,
                error,
                path: log.prefix
            });
        }
    }
    /**@private */ constructor(api, config, authToken, info){
        this.config = config;
        this.authToken = authToken;
        this.info = info;
        this.disposed = false;
        this.plugins = [];
        this._unknownPlugin = new (0, _plugin1.UnknownPlugin)();
        this._reminderSec = this.config.token.updateReminderSec;
        this._events = new (0, _common.Events)();
        this.onTokenUpdateReminder = this._events.make();
        this.onTokenExpired = this._events.make();
        this.onFatalError = this._events.make();
        this._onTokenUpdated = this._events.make();
        this._onDisposed = this._events.make();
        this._authTokenString = authToken.tokenString;
        this.appId = this.authToken.scope.app.id;
        (0, _plugin.registerPersonPlugin)(this);
        this._api = api;
        this._api.onFatalError.once((error)=>{
            log.error("onFatalError", {
                appId: this.appId,
                error
            });
            this.onFatalError.emit((0, _util.createError)({
                operationName: "SkyWayContext._api.onFatalError",
                context: this,
                info: (0, _errors.errors).rtcApiFatalError,
                error,
                path: log.prefix
            }));
            this.dispose();
        });
    }
    get authTokenString() {
        return this._authTokenString;
    }
    /**@internal */ async _setTokenExpireTimer() {
        // seconds
        const now = await this._api.getServerUnixtimeInSec();
        const expiresInSec = this.authToken.exp - now;
        if (expiresInSec < 0) throw (0, _util.createError)({
            operationName: "SkyWayContext._setTokenExpireTimer",
            context: this,
            info: (0, _errors.errors).invalidExpireTokenValue,
            path: log.prefix,
            payload: {
                exp: this.authToken.exp,
                now
            }
        });
        if (this.tokenUpdateReminderTimer) clearTimeout(this.tokenUpdateReminderTimer);
        const tokenExpireReminderTimeSec = expiresInSec - this._reminderSec;
        if (tokenExpireReminderTimeSec < 0) throw (0, _util.createError)({
            operationName: "SkyWayContext._setTokenExpireTimer",
            context: this,
            info: (0, _errors.errors).invalidRemindExpireTokenValue,
            path: log.prefix,
            payload: {
                expiresInSec,
                reminderSec: this._reminderSec
            }
        });
        log.debug("_setTokenExpireTimer", {
            expiresInSec,
            tokenExpireReminderTimeSec
        });
        this.tokenUpdateReminderTimer = setTimeout(()=>{
            log.debug("tokenUpdateReminder", {
                appid: this.appId
            });
            this.onTokenUpdateReminder.emit();
        }, tokenExpireReminderTimeSec * 1000);
        if (this.tokenExpiredTimer) clearTimeout(this.tokenExpiredTimer);
        this.tokenExpiredTimer = setTimeout(()=>{
            log.debug("tokenExpired", {
                appid: this.appId
            });
            this.onTokenExpired.emit();
        }, expiresInSec * 1000);
    }
    /**
   * @description [japanese] トークンの更新
   */ async updateAuthToken(token) {
        const newToken = (0, _token.SkyWayAuthToken).Decode(token);
        log.info({
            operationName: "SkyWayContext.updateAuthToken"
        }, {
            oldToken: this.authToken,
            newToken
        });
        if (newToken.scope.app.id !== this.appId) throw (0, _util.createError)({
            operationName: "SkyWayContext.updateAuthToken",
            context: this,
            info: (0, _errors.errors).invalidTokenAppId,
            path: log.prefix,
            payload: {
                invalid: this.authToken.scope.app.id,
                expect: this.appId
            }
        });
        this._authTokenString = token;
        this.authToken = newToken;
        this._onTokenUpdated.emit(token);
        await this._setTokenExpireTimer();
        await this._api.updateAuthToken(token);
    }
    /**
   * @description [japanese] プラグインの登録
   */ registerPlugin(plugin) {
        if (this.plugins.find((p)=>p.subtype === plugin.subtype)) return;
        plugin._attachContext(this);
        this.plugins.push(plugin);
    }
    /**@private */ _createRemoteMember(channel, memberDto) {
        const exist = channel._getMember(memberDto.id);
        if (exist) return exist;
        log.debug("createRemoteMember", {
            memberDto
        });
        memberDto.type = memberDto.type.toLowerCase();
        memberDto.subtype = memberDto.subtype.toLowerCase();
        let plugin = this.plugins.find((p)=>p.subtype === memberDto.subtype);
        if (!plugin) plugin = this._unknownPlugin;
        const member = plugin._createRemoteMember(channel, memberDto);
        return member;
    }
    /**
   * @description [japanese] Contextの利用を終了し次のリソースを解放する
   * - イベントリスナー
   * - バックエンドサーバとの通信
   * - Contextを参照する全Channelインスタンス
   */ dispose() {
        if (this.disposed) return;
        this.disposed = true;
        log.debug("disposed", {
            appid: this.appId
        });
        clearTimeout(this.tokenUpdateReminderTimer);
        this._onDisposed.emit();
        this._events.dispose();
        this._api.close();
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/rtc-api-client":"cfsMg","@skyway-sdk/token":"1nlc7","./config":"c9WRi","./errors":"gDbIj","./plugin/internal/person/plugin":"47TnT","./plugin/internal/unknown/plugin":"8IrOr","./util":"ey5Lv","./version":"3jBjn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cfsMg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _client = require("./client");
parcelHelpers.exportAll(_client, exports);
var _config = require("./config");
parcelHelpers.exportAll(_config, exports);
var _api = require("./domain/api");
parcelHelpers.exportAll(_api, exports);
var _channel = require("./domain/channel");
parcelHelpers.exportAll(_channel, exports);

},{"./client":"fmrv9","./config":"ci526","./domain/api":"kPJ9W","./domain/channel":"fDjvD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fmrv9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RtcApiClient", ()=>RtcApiClient);
var _common = require("@skyway-sdk/common");
var _rtcRpcApiClient = require("@skyway-sdk/rtc-rpc-api-client");
var _ = require(".");
var _config = require("./config");
var _api = require("./infrastructure/api");
var _eventObserver = require("./infrastructure/eventObserver");
const log = new (0, _common.Logger)("packages/rtc-api-client/src/client.ts");
class RtcApiClient {
    /** @throws {@link SkyWayError} */ static async Create(args) {
        const config = new (0, _config.Config)(args);
        if (config.log) {
            (0, _common.Logger).level = config.log.level;
            (0, _common.Logger).format = config.log.format;
        }
        log.debug("RtcApiClient spawned", config);
        const rpc = new (0, _rtcRpcApiClient.RtcRpcApiClient)({
            ...config.rtcApi,
            token: args.token,
            log: config.log
        });
        const api = new (0, _api.RtcApiImpl)(rpc);
        await api.connect();
        const eventObserverFactory = (appId, channel)=>new (0, _eventObserver.EventObserverImpl)(appId, rpc, channel, config.rtcApi);
        return new RtcApiClient(args.appId, config, api, eventObserverFactory);
    }
    constructor(appId, config, apiClient, _eventObserverFactory){
        this.appId = appId;
        this.config = config;
        this.apiClient = apiClient;
        this._eventObserverFactory = _eventObserverFactory;
        this.closed = false;
        this.onFatalError = new (0, _common.Event)();
        this.apiClient.onFatalError.pipe(this.onFatalError);
    }
    async updateAuthToken(token) {
        await this.apiClient.updateAuthToken(token);
    }
    /**ms */ async getServerUnixtimeInMs() {
        return this.apiClient.getServerUnixtime(this.appId);
    }
    /**sec */ async getServerUnixtimeInSec() {
        return Math.floor(await this.getServerUnixtimeInMs() / 1000);
    }
    /**@throws {@link SkyWayError} */ async createChannel(init = {}) {
        log.debug("[start] apiClient.createChannel", {
            init
        });
        const channelDto = await this.apiClient.createChannel(this.appId, init).catch((e)=>{
            log.debug("[failed] apiClient.createChannel", {
                init,
                e
            });
            throw e;
        });
        log.debug("[end] apiClient.createChannel", {
            init,
            channelDto
        });
        const channel = (0, _.channelFactory)(this.appId, this._eventObserverFactory(this.appId, channelDto), this.apiClient, channelDto, this.config);
        return channel;
    }
    async findChannel(query) {
        log.debug("[start] apiClient.getChannel", {
            query
        });
        const channelDto = await this.apiClient.getChannel(this.appId, query).catch((e)=>{
            log.debug("[failed] apiClient.getChannel", {
                query,
                e
            });
            throw e;
        });
        const channel = (0, _.channelFactory)(this.appId, this._eventObserverFactory(this.appId, channelDto), this.apiClient, channelDto, this.config);
        log.debug("[end] apiClient.getChannel", {
            channelId: channel.id
        });
        return channel;
    }
    async findOrCreateChannel(query) {
        log.debug("[start] apiClient.findOrCreateChannel", {
            query
        });
        const channelDto = await this.apiClient.findOrCreateChannel(this.appId, query).catch((e)=>{
            log.debug("[failed] apiClient.findOrCreateChannel", {
                query,
                e
            });
            throw e;
        });
        log.debug("[end] apiClient.findOrCreateChannel", {
            query
        });
        const channel = (0, _.channelFactory)(this.appId, this._eventObserverFactory(this.appId, channelDto), this.apiClient, channelDto, this.config);
        return channel;
    }
    deleteChannel(channelId) {
        return this.apiClient.deleteChannel(this.appId, channelId);
    }
    close() {
        if (this.closed) return;
        this.closed = true;
        log.debug("closed", {
            appid: this.appId
        });
        this.apiClient.close();
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/rtc-rpc-api-client":"NA7aK",".":"cfsMg","./config":"ci526","./infrastructure/api":"aEMZA","./infrastructure/eventObserver":"dXVw4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"NA7aK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _client = require("./client");
parcelHelpers.exportAll(_client, exports);
var _errors = require("./errors");
parcelHelpers.exportAll(_errors, exports);
var _event = require("./event");
parcelHelpers.exportAll(_event, exports);
var _rpc = require("./rpc");
parcelHelpers.exportAll(_rpc, exports);

},{"./client":"cTK33","./errors":"igCtZ","./event":"3oOGD","./rpc":"g55yE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cTK33":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RtcRpcApiClient", ()=>RtcRpcApiClient);
var _common = require("@skyway-sdk/common");
var _const = require("./const");
var _errors = require("./errors");
var _rpc = require("./rpc");
var _util = require("./util");
const log = new (0, _common.Logger)("packages/rtc-rpc-api-client/src/client.ts");
class RtcRpcApiClient {
    constructor(config){
        this.config = config;
        this.closed = false;
        this._domain = this.config.domain ?? (0, _const.defaultDomain);
        this._secure = this.config.secure ?? true;
        this._token = this.config.token;
        this./**@private */ _rpc = new (0, _rpc.RPC)();
        this._subscribingChannelEvents = new Set();
        this._subscribingChannelVersions = {};
        this._httpClient = new (0, _common.HttpClient)(`http${this.config.secure ? "s" : ""}://${this.config.domain}`);
        this._reconnectCount = 0;
        this._reconnectLimit = (0, _const.MaxRetry);
        this._events = new (0, _common.Events)();
        this.onEvent = this._events.make();
        this.onFatalError = this._events.make();
        this.onClose = this._events.make();
        this.onReconnected = this._events.make();
        (0, _common.Logger).level = config.log?.level ?? (0, _common.Logger).level;
        (0, _common.Logger).format = config.log?.format ?? (0, _common.Logger).format;
        log.debug("RtcRpcApiClient spawned", config);
        this._rpc.onNotify.add((notify)=>{
            if (notify.method === "channelEventNotification") {
                const event = notify.params;
                this._subscribingChannelVersions[event.data.channel.id] = event.data.channel.version;
                this.onEvent.emit({
                    channelId: event.data.channel.id,
                    event
                });
            }
        });
        this._rpc.onDisconnected.add(async ()=>{
            if (this._rpc.negotiated && !this._rpc.closed && !this._rpc.reconnecting) await this._reconnect();
        });
        this._rpc.onFatalError.once((e)=>{
            log.error("fatal error", e);
            this.onFatalError.emit(e);
            this.close();
        });
    }
    get token() {
        return this._token;
    }
    async _reconnect() {
        if (this._reconnectCount >= this._reconnectLimit) {
            this._rpc.onFatalError.emit((0, _util.createError)({
                operationName: "RtcRpcApiClient._reconnect",
                info: {
                    name: "failed to reconnect",
                    detail: "_reconnectLimit exceeded",
                    solution: ""
                },
                path: log.prefix
            }));
            this.close();
            return;
        }
        this._rpc.reconnecting = true;
        log.warn("[start] reconnect", (0, _util.createWarnPayload)({
            operationName: "RtcRpcApiClient._reconnect",
            detail: "reconnect start",
            payload: {
                reconnectCount: this._reconnectCount,
                limit: this._reconnectLimit
            }
        }));
        this._reconnectCount++;
        const backOffTime = this._reconnectCount ** 2 * 100 + this._reconnectCount ** 2 * 100 * Math.random();
        await new Promise((r)=>setTimeout(r, backOffTime));
        try {
            await this.connect().catch((err)=>{
                log.warn(`[failed] reconnect rtc api`, (0, _util.createWarnPayload)({
                    operationName: "RtcRpcApiClient._reconnect",
                    detail: "connect rpc failed",
                    payload: {
                        reconnectCount: this._reconnectCount
                    }
                }), err);
                throw err;
            });
            this._rpc.reconnecting = false;
            this._reconnectCount = 0;
            this._rpc.resolvePendingRequests();
            await Promise.all([
                ...this._subscribingChannelEvents
            ].map(async (s)=>{
                const [appId, channelId] = s.split(":");
                const offset = this._subscribingChannelVersions[channelId];
                await this.subscribeChannelEvents({
                    appId,
                    channelId,
                    offset
                });
            })).catch((e)=>{
                log.warn("subscribeChannelEvents failed", (0, _util.createWarnPayload)({
                    operationName: "RtcRpcApiClient._reconnect",
                    detail: "subscribeChannelEvents failed",
                    payload: {
                        reconnectCount: this._reconnectCount
                    }
                }), e);
                throw e;
            });
            log.warn("[end] reconnect", (0, _util.createWarnPayload)({
                operationName: "RtcRpcApiClient._reconnect",
                detail: "reconnect finished",
                payload: {
                    reconnectCount: this._reconnectCount
                }
            }));
            this.onReconnected.emit();
        } catch (error) {
            log.warn("[failed] reconnect", (0, _util.createWarnPayload)({
                operationName: "RtcRpcApiClient._reconnect",
                detail: "reconnect failed",
                payload: {
                    reconnectCount: this._reconnectCount
                }
            }), error);
            await this._reconnect();
        }
    }
    async updateToken(token) {
        log.debug("token update", {
            token
        });
        this._token = token;
        await this._updateAuthToken();
    }
    close() {
        if (this.closed) return;
        this.closed = true;
        log.debug("closed");
        this._rpc.close();
        this.onClose.emit();
        this._events.dispose();
    }
    async health() {
        const response = await this._httpClient.get("/health");
        return response;
    }
    /** @throws {@link SkyWayError} */ async connect() {
        log.debug("connect to rtc api rpc", this._domain);
        await this._rpc.connect({
            domain: this._domain,
            token: this.token,
            secure: this._secure
        }).catch((e)=>{
            throw (0, _util.createError)({
                operationName: "RtcRpcApiClient.connect",
                info: (0, _errors.errors).failedToConnectRtcAPI,
                error: e,
                path: log.prefix
            });
        });
    }
    _channelSubscribed(appId, channelId) {
        this._subscribingChannelEvents.add(appId + ":" + channelId);
        log.debug("_channelSubscribed", {
            appId,
            channelId,
            _subscribingChannelEvents: [
                ...this._subscribingChannelEvents
            ]
        });
    }
    _isSubscribingChannel(appId, channelId) {
        return this._subscribingChannelEvents.has(appId + ":" + channelId);
    }
    async createChannel({ name , metadata , appId  }) {
        const { channel  } = await this._rpc.request("createChannel", {
            name,
            metadata,
            appId,
            authToken: this.token
        });
        this._channelSubscribed(appId, channel.id);
        return channel;
    }
    async findOrCreateChannel({ name , metadata , appId  }) {
        const { channel  } = await this._rpc.request("findOrCreateChannel", {
            name,
            metadata,
            appId,
            authToken: this.token
        });
        this._channelSubscribed(appId, channel.id);
        return channel;
    }
    async getChannel({ appId , id  }) {
        const res = await this._rpc.request("getChannel", {
            id,
            appId,
            authToken: this.token
        });
        // getChannelは暗黙的にEventがsubscribeされない
        if (!this._isSubscribingChannel(appId, id)) {
            this._channelSubscribed(appId, id);
            await this.subscribeChannelEvents({
                appId,
                channelId: id,
                offset: res.channel.version
            });
        }
        return res.channel;
    }
    async getChannelByName({ name , appId  }) {
        const res = await this._rpc.request("getChannelByName", {
            name,
            appId,
            authToken: this.token
        });
        const channelId = res.channel.id;
        // getChannelByNameは暗黙的にEventがsubscribeされない
        if (!this._isSubscribingChannel(appId, channelId)) {
            this._channelSubscribed(appId, channelId);
            await this.subscribeChannelEvents({
                appId,
                channelId,
                offset: res.channel.version
            });
        }
        return res.channel;
    }
    async deleteChannel({ id , appId  }) {
        await this._rpc.request("deleteChannel", {
            id,
            appId,
            authToken: this.token
        });
    }
    async updateChannelMetadata({ id , metadata , appId  }) {
        await this._rpc.request("updateChannelMetadata", {
            id,
            metadata,
            appId,
            authToken: this.token
        });
    }
    async addMember({ channelId , name , metadata , subscribeChannelEvents , appId , ttlSec , subtype , type  }) {
        const res = await this._rpc.request("addMember", {
            channelId,
            name,
            metadata,
            subscribeChannelEvents,
            appId,
            ttlSec: ttlSec && parseInt(ttlSec.toString()),
            authToken: this.token,
            subtype,
            type
        });
        return res;
    }
    async updateMemberTtl(args, backoff = new (0, _common.BackOff)({
        times: 8
    })) {
        const { appId , channelId , memberId , ttlSec  } = args;
        try {
            await this._rpc.request("updateMemberTtl", {
                appId,
                channelId,
                memberId,
                ttlSec: ttlSec && parseInt(ttlSec.toString()),
                authToken: this.token
            });
        } catch (e) {
            if (!backoff.exceeded) {
                log.warn("retry updateMemberTtl", (0, _util.createWarnPayload)({
                    operationName: "RtcRpcApiClient.updateMemberTtl",
                    detail: "retry updateMemberTtl",
                    appId,
                    channelId,
                    memberId,
                    payload: {
                        backoff: backoff.count
                    }
                }), e);
                await backoff.wait();
                await this.updateMemberTtl(args, backoff);
            } else {
                const error = new (0, _common.SkyWayError)({
                    path: log.prefix,
                    info: (0, _errors.errors).failedToUpdateMemberTTL,
                    error: e
                });
                throw error;
            }
        }
    }
    async updateMemberMetadata({ channelId , memberId , metadata , appId  }) {
        await this._rpc.request("updateMemberMetadata", {
            channelId,
            memberId,
            metadata,
            appId,
            authToken: this.token
        });
    }
    async leaveChannel({ channelId , id , appId  }) {
        await this._rpc.request("removeMember", {
            channelId,
            id,
            appId,
            authToken: this.token
        });
    }
    async publishStream({ appId , channelId , publisherId , contentType , metadata , origin , codecCapabilities , encodings , isEnabled  }) {
        const res = await this._rpc.request("publishStream", {
            channelId,
            publisherId,
            contentType: contentType[0].toUpperCase() + contentType.slice(1),
            metadata,
            origin,
            codecCapabilities,
            encodings: encodings?.map((e)=>({
                    id: e.id
                })),
            isEnabled,
            appId,
            authToken: this.token
        });
        return {
            publicationId: res.id
        };
    }
    async disablePublication({ channelId , publicationId , appId  }) {
        await this._rpc.request("disablePublication", {
            channelId,
            appId,
            publicationId,
            authToken: this.token
        });
    }
    async enablePublication({ channelId , publicationId , appId  }) {
        await this._rpc.request("enablePublication", {
            channelId,
            appId,
            publicationId,
            authToken: this.token
        });
    }
    async updatePublicationMetadata({ channelId , publicationId , appId , metadata  }) {
        await this._rpc.request("updatePublicationMetadata", {
            channelId,
            publicationId,
            metadata,
            appId,
            authToken: this.token
        });
    }
    async unpublishStream({ channelId , publicationId , appId  }) {
        await this._rpc.request("unpublishStream", {
            channelId,
            publicationId,
            appId,
            authToken: this.token
        });
    }
    async subscribeStream({ channelId , subscriberId , publicationId , appId  }) {
        const res = await this._rpc.request("subscribeStream", {
            channelId,
            subscriberId,
            publicationId,
            appId,
            authToken: this.token
        });
        return {
            subscriptionId: res.id
        };
    }
    async unsubscribeStream({ channelId , subscriptionId , appId  }) {
        await this._rpc.request("unsubscribeStream", {
            channelId,
            subscriptionId,
            appId,
            authToken: this.token
        });
    }
    /**
   * @returns Date.now()
   */ async getServerUnixtime(args, backoff = new (0, _common.BackOff)({
        times: 8
    })) {
        const { appId  } = args;
        try {
            const res = await this._rpc.request("getServerUnixtime", {
                appId,
                authToken: this.token
            });
            return res.unixtime;
        } catch (error) {
            if (!backoff.exceeded) {
                log.warn((0, _util.createWarnPayload)({
                    operationName: "RtcRpcApiClient.getServerUnixtime",
                    detail: "retry getServerUnixtime",
                    appId,
                    payload: {
                        backoff: backoff.count
                    }
                }), error);
                await backoff.wait();
                return this.getServerUnixtime(args, backoff);
            } else throw error;
        }
    }
    /**@description [japanese] 現在のセッションに関連付けられている SkyWayAuthToken を更新します */ async _updateAuthToken() {
        await this._rpc.request("updateAuthToken", {
            authToken: this.token
        });
    }
    /**
   * @description
   * - 指定した Channel の Event を Subscribe していなければ Event が生じるたびに Notification が送られるようになります。
   * - Subscribeした時点で、指定された offset (default to 0) の version から、最新の version までのイベントが送られます。
   */ async subscribeChannelEvents({ appId , channelId , offset  }) {
        try {
            log.debug("[start] subscribeChannelEvents", {
                offset
            });
            await this._rpc.request("subscribeChannelEvents", {
                appId,
                authToken: this.token,
                channelId,
                offset
            });
            log.debug("[end] subscribeChannelEvents", {
                offset
            });
        } catch (error) {
            if (error instanceof (0, _common.SkyWayError) && error.info.name === (0, _errors.errors).connectionDisconnected.name) {
                log.warn("reconnect happened while subscribeChannelEvents. retry", (0, _util.createWarnPayload)({
                    operationName: "RtcRpcApiClient.subscribeChannelEvents",
                    detail: "reconnect happened while subscribeChannelEvents. retry",
                    appId,
                    channelId,
                    payload: {
                        offset
                    }
                }), error);
                await this.subscribeChannelEvents({
                    appId,
                    channelId,
                    offset
                });
            } else {
                log.error("[failed] subscribeChannelEvents", (0, _util.createError)({
                    operationName: "RtcRpcApiClient.subscribeChannelEvents",
                    info: {
                        ...(0, _errors.errors).internalError,
                        detail: "subscribeChannelEvents failed"
                    },
                    path: log.prefix,
                    error,
                    payload: {
                        offset
                    },
                    appId,
                    channelId
                }));
                throw error;
            }
        }
    }
}

},{"@skyway-sdk/common":"3hyrG","./const":"kN20V","./errors":"igCtZ","./rpc":"g55yE","./util":"kFQW1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kN20V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultDomain", ()=>defaultDomain);
parcelHelpers.export(exports, "rpcTimeout", ()=>rpcTimeout);
parcelHelpers.export(exports, "MaxRetry", ()=>MaxRetry);
const defaultDomain = "rtc-api.skyway.ntt.com";
const rpcTimeout = 20000;
const MaxRetry = 8;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"igCtZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errors", ()=>errors);
const errors = {
    timeout: {
        name: "timeout",
        detail: "",
        solution: ""
    },
    internalError: {
        name: "internalError",
        detail: "",
        solution: ""
    },
    invalidParameter: {
        name: "invalidParameter",
        detail: "",
        solution: ""
    },
    connectionDisconnected: {
        name: "connectionDisconnected",
        detail: "",
        solution: ""
    },
    websocketConnectionFailure: {
        name: "connectionFailure",
        detail: "サーバへの接続に失敗しました",
        solution: "ネットワーク接続状況を確認してください"
    },
    rpcResponseError: {
        name: "rpcResponseError",
        detail: "",
        solution: "",
        error: {}
    },
    onClosedWhileRequesting: {
        name: "onClosedWhileRequesting",
        detail: "request中にクライアントが終了されました",
        solution: "リクエストの完了を確認してからクライアントを終了させてください"
    },
    failedToConnectRtcAPI: {
        name: "failedToConnectRtcAPI",
        detail: "rtc-api serverへの接続に失敗しました",
        solution: "インターネット接続状況とTokenの内容が正しいかを確かめてください"
    },
    failedToUpdateMemberTTL: {
        name: "failedToUpdateMemberTTL",
        detail: "updateMemberTTLを再試行しましたが、失敗しました",
        solution: "インターネット接続状況を確認してください"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g55yE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RPC", ()=>RPC);
var _common = require("@skyway-sdk/common");
var _isomorphicWs = require("isomorphic-ws");
var _isomorphicWsDefault = parcelHelpers.interopDefault(_isomorphicWs);
var _uuid = require("uuid");
var _const = require("./const");
var _errors = require("./errors");
var _util = require("./util");
const log = new (0, _common.Logger)("packages/rtc-rpc-api-client/src/rpc.ts");
class RPC {
    _id = (0, _uuid.v4)();
    closed = false;
    negotiated = false;
    _reconnecting = false;
    set reconnecting(b) {
        this._reconnecting = b;
    }
    get reconnecting() {
        return this._reconnecting;
    }
    _pendingRequests = [];
    _events = new (0, _common.Events)();
    _onMessage = this._events.make();
    onNotify = this._events.make();
    onFatalError = this._events.make();
    onDisconnected = this._events.make();
    onClosed = this._events.make();
    async connect({ domain , token , secure  }) {
        const subProtocol = token;
        this._ws = new (0, _isomorphicWsDefault.default)(`${secure ? "wss" : "ws"}://${domain}/ws`, subProtocol);
        this._ws.onmessage = (ev)=>{
            this._onMessage.emit(JSON.parse(ev.data));
        };
        this._ws.onclose = async ()=>{
            log.debug("websocket closed", {
                id: this._id
            });
            this.onDisconnected.emit();
        };
        this._onMessage.add((msg)=>{
            if (isNotifyMessage(msg)) this.onNotify.emit(msg);
        });
        const error = await new Promise((r, f)=>{
            const timeout = setTimeout(()=>{
                f((0, _util.createError)({
                    operationName: "RPC.connect",
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "ws.open"
                    },
                    path: log.prefix
                }));
            }, 5000);
            this._ws.onerror = (e)=>{
                f((0, _util.createError)({
                    operationName: "RPC.connect",
                    info: (0, _errors.errors).websocketConnectionFailure,
                    path: log.prefix,
                    error: e
                }));
            };
            this._ws.onopen = ()=>{
                clearTimeout(timeout);
                r();
            };
        }).catch((e)=>e);
        if (error) throw error;
        this.negotiated = true;
    }
    close() {
        if (this.closed) return;
        this.closed = true;
        log.debug("closed");
        this._ws.close();
        this.onClosed.emit();
        this._events.dispose();
    }
    resolvePendingRequests() {
        log.debug("resolve pendingRequests", [
            ...this._pendingRequests
        ]);
        this._pendingRequests.forEach(async (req)=>{
            await this._send(req);
        });
        this._pendingRequests = [];
    }
    _send = (request)=>new Promise(async (r, f)=>{
            // 非同期化
            await new Promise((r)=>setTimeout(r, 0));
            if (this._ws.readyState !== this._ws.OPEN) {
                f((0, _util.createError)({
                    operationName: "RPC._send",
                    info: {
                        ...(0, _errors.errors).internalError,
                        detail: "wrong state"
                    },
                    path: log.prefix,
                    payload: {
                        request,
                        wsReadyState: wsStates[this._ws.readyState]
                    }
                }));
                return;
            }
            this._ws.send(JSON.stringify(request), (error)=>{
                if (error) throw f((0, _util.createError)({
                    operationName: "RPC._send",
                    info: {
                        ...(0, _errors.errors).internalError,
                        detail: "failed to send rpc message"
                    },
                    path: log.prefix,
                    error
                }));
            });
            r();
        });
    /**
   * @throws {@link SkyWayError}
   */ async request(method, params) {
        if (this.closed) throw (0, _util.createError)({
            operationName: "RPC.request",
            info: {
                ...(0, _errors.errors).internalError,
                detail: "rpc closed"
            },
            path: log.prefix,
            payload: {
                method,
                params,
                id: this._id
            }
        });
        let promiseResolved = false;
        try {
            const request = buildRequest(method, params);
            const handleMessage = async ()=>await this._onMessage.watch((msg)=>msg.id === request.id, (0, _const.rpcTimeout)).catch(()=>{
                    if (promiseResolved) return;
                    throw (0, _util.createError)({
                        operationName: "RPC.request",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "rpc request timeout"
                        },
                        path: log.prefix,
                        payload: {
                            rpcTimeout: (0, _const.rpcTimeout),
                            method,
                            params,
                            wsReadyState: wsStates[this._ws.readyState],
                            id: this._id
                        }
                    });
                });
            const pendingRequest = async ()=>{
                log.warn("[start] reconnecting. pending request", (0, _util.createWarnPayload)({
                    operationName: "RPC.request",
                    detail: "[start] reconnecting. pending request",
                    payload: {
                        request,
                        id: this._id
                    }
                }));
                // 再接続後に再送する
                this._pendingRequests.push(request);
                const message = await Promise.race([
                    handleMessage(),
                    this.onFatalError.asPromise((0, _const.rpcTimeout) + 100).then((e)=>{
                        if (!promiseResolved) log.error("[failed] reconnecting. pending request", (0, _util.createError)({
                            operationName: "RPC.request",
                            info: {
                                ...(0, _errors.errors).internalError,
                                detail: "onFatalError while request"
                            },
                            path: log.prefix
                        }), e);
                        throw e;
                    })
                ]);
                promiseResolved = true;
                log.warn("[end] reconnecting. pending request", (0, _util.createWarnPayload)({
                    operationName: "RPC.request",
                    detail: "[end] reconnecting. pending request",
                    payload: {
                        request,
                        id: this._id
                    }
                }));
                return message;
            };
            let message;
            if (!this._reconnecting) {
                this._send(request).catch((e)=>{
                    log.error("send error", e);
                });
                message = await Promise.race([
                    handleMessage(),
                    // 返信待ち中に接続が切れた場合
                    (async ()=>{
                        await this.onDisconnected.asPromise((0, _const.rpcTimeout) + 100);
                        if (promiseResolved) return {};
                        try {
                            const message = await pendingRequest();
                            log.warn((0, _util.createWarnPayload)({
                                operationName: "request.pendingRequest",
                                detail: "success to handle disconnected"
                            }));
                            return message;
                        } catch (error) {
                            throw (0, _util.createError)({
                                operationName: "RPC.request",
                                info: (0, _errors.errors).connectionDisconnected,
                                path: log.prefix,
                                error
                            });
                        }
                    })(),
                    this.onFatalError.asPromise((0, _const.rpcTimeout) + 100).then((e)=>{
                        if (promiseResolved) return {};
                        throw (0, _util.createError)({
                            operationName: "RPC.request",
                            info: {
                                ...(0, _errors.errors).internalError,
                                detail: "onFatalError while requesting"
                            },
                            path: log.prefix,
                            error: e
                        });
                    }),
                    this.onClosed.asPromise((0, _const.rpcTimeout) + 100).then(()=>{
                        if (promiseResolved) return {};
                        throw (0, _util.createError)({
                            operationName: "RPC.request",
                            info: (0, _errors.errors).onClosedWhileRequesting,
                            path: log.prefix,
                            payload: {
                                method,
                                params
                            }
                        });
                    })
                ]);
                promiseResolved = true;
            } else message = await pendingRequest();
            if (message.error) {
                log.warn("[failed] request ", {
                    message,
                    method,
                    params
                });
                throw (0, _util.createError)({
                    operationName: "RPC.request",
                    info: {
                        ...(0, _errors.errors).rpcResponseError,
                        detail: method,
                        error: message.error
                    },
                    payload: {
                        message,
                        method,
                        params
                    },
                    path: log.prefix
                });
            }
            return message.result;
        } catch (error) {
            promiseResolved = true;
            throw error;
        }
    }
    async notify(method, params) {
        const request = buildRequest(method, params, true);
        await this._send(request);
    }
    async batch(requests) {
        const messages = requests.map(({ method , params  })=>buildRequest(method, params));
        this._send(messages).catch((e)=>{
            throw e;
        });
        const responses = await Promise.all(messages.map(async ({ id  })=>{
            const message = await this._onMessage.watch((msg)=>msg.id === id, (0, _const.rpcTimeout));
            return message;
        }));
        return responses;
    }
}
const buildRequest = (method, params, notify)=>{
    if (notify) return {
        jsonrpc: "2.0",
        method,
        params
    };
    const id = (0, _uuid.v4)();
    return {
        jsonrpc: "2.0",
        method,
        params,
        id
    };
};
const isNotifyMessage = (msg)=>{
    const notify = msg;
    if (notify.method && notify.id == undefined) return true;
    return false;
};
const wsStates = [
    "CONNECTING",
    "OPEN",
    "CLOSING",
    "CLOSED"
];

},{"@skyway-sdk/common":"3hyrG","isomorphic-ws":"5nVUE","uuid":"1wY3w","./const":"kN20V","./errors":"igCtZ","./util":"kFQW1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1wY3w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":false,"./v3.js":false,"./v4.js":"5xJl4","./v5.js":false,"./nil.js":false,"./version.js":false,"./validate.js":"cbvks","./stringify.js":"1kzSz","./parse.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5xJl4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeJs = require("./native.js");
var _nativeJsDefault = parcelHelpers.interopDefault(_nativeJs);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
function v4(options, buf, offset) {
    if ((0, _nativeJsDefault.default).randomUUID && !buf && !options) return (0, _nativeJsDefault.default).randomUUID();
    options = options || {};
    const rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJs.unsafeStringify)(rnds);
}
exports.default = v4;

},{"./native.js":"9WM8b","./rng.js":"9psaA","./stringify.js":"1kzSz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9WM8b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports.default = {
    randomUUID
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9psaA":[function(require,module,exports) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return getRandomValues(rnds8);
}
exports.default = rng;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1kzSz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeStringify", ()=>unsafeStringify);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"cbvks","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cbvks":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === "string" && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"25n7f","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"25n7f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kFQW1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createError", ()=>createError);
parcelHelpers.export(exports, "createWarnPayload", ()=>createWarnPayload);
var _common = require("@skyway-sdk/common");
function createError({ operationName , info , error , path , payload , channelId , appId , memberId  }) {
    return new (0, _common.SkyWayError)({
        error,
        info: info,
        payload: {
            payload,
            operationName,
            channelId,
            appId,
            memberId
        },
        path
    });
}
function createWarnPayload({ appId , detail , channelId , operationName , payload , memberId  }) {
    const warn = {
        operationName,
        payload,
        detail,
        appId,
        channelId,
        memberId
    };
    return warn;
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3oOGD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ci526":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RtcRpcApiConfig", ()=>(0, _rtcRpcApiClient.RtcRpcApiConfig));
parcelHelpers.export(exports, "Config", ()=>Config);
var _rtcRpcApiClient = require("@skyway-sdk/rtc-rpc-api-client");
var _deepmerge = require("deepmerge");
var _deepmergeDefault = parcelHelpers.interopDefault(_deepmerge);
class Config {
    rtcApi = {
        domain: "rtc-api.skyway.ntt.com",
        timeout: 30000,
        secure: true,
        eventSubscribeTimeout: 5000
    };
    log = {
        level: "error",
        format: "object"
    };
    constructor(options = {}){
        Object.assign(this, (0, _deepmergeDefault.default)(this, options));
    }
}

},{"@skyway-sdk/rtc-rpc-api-client":"NA7aK","deepmerge":"ck1Q2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ck1Q2":[function(require,module,exports) {
"use strict";
var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
    return !!value && typeof value === "object";
}
function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;
function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) return deepmerge;
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
}
function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    try {
        return property in object;
    } catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
     && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
     && Object.propertyIsEnumerable.call(target, key) // and also unsafe if they're nonenumerable.
    );
}
function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
    getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) return;
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        else destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    });
    return destination;
}
function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) return cloneUnlessOtherwiseSpecified(source, options);
    else if (sourceIsArray) return options.arrayMerge(target, source, options);
    else return mergeObject(target, source, options);
}
deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) throw new Error("first argument should be an array");
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
    }, {});
};
var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;

},{}],"aEMZA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RtcApiImpl", ()=>RtcApiImpl);
var _common = require("@skyway-sdk/common");
var _token = require("@skyway-sdk/token");
var _errors = require("../errors");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/rtc-api-client/src/infrastructure/api.ts");
class RtcApiImpl {
    constructor(_client){
        this._client = _client;
        this.closed = false;
        this.onClose = new (0, _common.Event)();
        this.onFatalError = new (0, _common.Event)();
        this._token = (0, _token.SkyWayAuthToken).Decode(this._client.token);
        _client.onClose.once(()=>{
            this.close();
        });
        _client.onFatalError.add((e)=>{
            this.onFatalError.emit(e);
        });
    }
    /** @throws {@link SkyWayError} */ async connect() {
        await this._client.connect();
    }
    async updateAuthToken(token) {
        this._token = (0, _token.SkyWayAuthToken).Decode(token);
        await this._client.updateToken(token);
    }
    close() {
        if (this.closed) return;
        this.closed = true;
        log.debug("closed");
        this._client.close();
        this.onClose.emit();
        this.onClose.removeAllListeners();
    }
    _commonError(method, code, detail) {
        switch(code){
            case -32602:
                return (0, _util.createError)({
                    operationName: method,
                    info: (0, _errors.errors).invalidRequestParameter,
                    path: log.prefix,
                    error: detail
                });
            case -32603:
                return (0, _util.createError)({
                    operationName: method,
                    info: (0, _errors.errors).internalError,
                    path: log.prefix,
                    error: detail
                });
            case 403:
            case 4030:
                return (0, _util.createError)({
                    operationName: method,
                    info: (0, _errors.errors).insufficientPermissions,
                    path: log.prefix,
                    error: detail
                });
        }
    }
    /**@throws {@link SkyWayError} */ async createChannel(appId, channelInit) {
        const { id  } = await this._client.createChannel({
            appId,
            name: channelInit.name,
            metadata: channelInit.metadata
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.createChannel", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.createChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNotFound,
                        error: e
                    });
                case 409:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.createChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNameDuplicated,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.createChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
        const res = await this.getChannel(appId, {
            id
        });
        return res;
    }
    async getChannel(appId, { name , id  }) {
        if (id) return await this._client.getChannel({
            appId,
            id
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.getChannel", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.getChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.getChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
        if (name) return await this._client.getChannelByName({
            appId,
            name
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.getChannel", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "getChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "getChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
        throw (0, _util.createError)({
            operationName: "RtcApiImpl.createChannel",
            path: log.prefix,
            info: (0, _errors.errors).invalidRequestParameter
        });
    }
    async findOrCreateChannel(appId, query) {
        return this._client.findOrCreateChannel({
            ...query,
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.findOrCreateChannel", info?.error?.code ?? -1, e);
            if (error) throw error;
            if (query.name && info?.error?.code === 409) return this.getChannel(appId, {
                name: query.name
            });
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.findOrCreateChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNotFound,
                        error: e
                    });
                case 409:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.findOrCreateChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNameDuplicated,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.findOrCreateChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    async deleteChannel(appId, id) {
        await this._client.deleteChannel({
            appId,
            id
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.deleteChannel", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.deleteChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.deleteChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    async updateChannelMetadata(appId, id, metadata) {
        await this._client.updateChannelMetadata({
            appId,
            id,
            metadata
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.updateChannelMetadata", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.updateChannelMetadata",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.updateChannelMetadata",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    async join(appId, channelId, memberInit) {
        const { memberId  } = await this._client.addMember({
            appId,
            channelId,
            name: memberInit.name,
            metadata: memberInit.metadata,
            ttlSec: memberInit.ttlSec,
            type: memberInit.type,
            subtype: memberInit.subtype
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.addMember", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.addMember",
                        path: log.prefix,
                        info: (0, _errors.errors).channelNotFound,
                        error: e
                    });
                case 409:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.addMember",
                        path: log.prefix,
                        info: (0, _errors.errors).memberNameDuplicated,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.addMember",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
        const member = {
            id: memberId,
            name: memberInit.name,
            type: memberInit.type,
            subtype: memberInit.subtype,
            metadata: memberInit.metadata
        };
        return member;
    }
    async updateMemberTtl(appId, channelId, memberId, ttlSec) {
        await this._client.updateMemberTtl({
            appId,
            channelId,
            memberId,
            ttlSec
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.updateMemberTtl", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.updateMemberTtl",
                        path: log.prefix,
                        info: (0, _errors.errors).memberNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.updateMemberTtl",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    /**
   * @returns Date.now()
   */ async getServerUnixtime(appId) {
        return await this._client.getServerUnixtime({
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.getServerUnixtime", info?.error?.code ?? -1, e);
            if (error) throw error;
            throw (0, _util.createError)({
                operationName: "RtcApiImpl.getServerUnixtime",
                path: log.prefix,
                info: (0, _errors.errors).internalError,
                error: e
            });
        });
    }
    async updateMemberMetadata(appId, channelId, memberId, metadata) {
        await this._client.updateMemberMetadata({
            appId,
            channelId,
            memberId,
            metadata
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.updateMemberMetadata", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.updateMemberMetadata",
                        path: log.prefix,
                        info: (0, _errors.errors).memberNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.updateMemberMetadata",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    async leave(appId, channelId, memberId) {
        await this._client.leaveChannel({
            channelId,
            id: memberId,
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.leaveChannel", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.leaveChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).memberNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.leaveChannel",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    /**@throws {@link SkyWayError} */ async publish(appId, init) {
        const { publicationId  } = await this._client.publishStream({
            channelId: init.channel,
            publisherId: init.publisher,
            contentType: init.contentType,
            metadata: init.metadata,
            origin: init.origin,
            codecCapabilities: init.codecCapabilities,
            encodings: init.encodings,
            isEnabled: init.isEnabled,
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.publish", info?.error?.code ?? -1, e);
            if (error) throw error;
            info?.error?.code;
            throw (0, _util.createError)({
                operationName: "RtcApiImpl.publish",
                path: log.prefix,
                info: (0, _errors.errors).internalError,
                error: e
            });
        });
        return publicationId;
    }
    async updatePublicationMetadata(appId, channelId, publicationId, metadata) {
        await this._client.updatePublicationMetadata({
            channelId,
            publicationId,
            metadata,
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.updatePublicationMetadata", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.updatePublicationMetadata",
                        path: log.prefix,
                        info: (0, _errors.errors).publicationNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.updatePublicationMetadata",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    async disablePublication(appId, channelId, publicationId) {
        await this._client.disablePublication({
            channelId,
            publicationId,
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.disablePublication", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.disablePublication",
                        path: log.prefix,
                        info: (0, _errors.errors).publicationNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.disablePublication",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    async enablePublication(appId, channelId, publicationId) {
        await this._client.enablePublication({
            channelId,
            publicationId,
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.enablePublication", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.enablePublication",
                        path: log.prefix,
                        info: (0, _errors.errors).publicationNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.enablePublication",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    async unpublish(appId, channelId, publicationId) {
        await this._client.unpublishStream({
            channelId,
            publicationId,
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.unpublishStream", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.unpublishStream",
                        path: log.prefix,
                        info: (0, _errors.errors).publicationNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.unpublishStream",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
    /**@throws {@link SkyWayError} */ async subscribe(appId, init) {
        const { subscriptionId  } = await this._client.subscribeStream({
            channelId: init.channel.id,
            subscriberId: init.subscriber.id,
            publicationId: init.publication.id,
            appId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.subscribeStream", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.subscribeStream",
                        path: log.prefix,
                        info: (0, _errors.errors).publicationNotFound,
                        error: e
                    });
                case 409:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.subscribeStream",
                        path: log.prefix,
                        info: (0, _errors.errors).subscriptionAlreadyExists,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.subscribeStream",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
        return subscriptionId;
    }
    async unsubscribe(appId, channelId, subscriptionId) {
        await this._client.unsubscribeStream({
            appId,
            channelId,
            subscriptionId
        }).catch((e)=>{
            const { info  } = e;
            const error = this._commonError("RtcApiImpl.unsubscribeStream", info?.error?.code ?? -1, e);
            if (error) throw error;
            switch(info?.error?.code){
                case 404:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.unsubscribeStream",
                        path: log.prefix,
                        info: (0, _errors.errors).publicationNotFound,
                        error: e
                    });
                default:
                    throw (0, _util.createError)({
                        operationName: "RtcApiImpl.unsubscribeStream",
                        path: log.prefix,
                        info: (0, _errors.errors).internalError,
                        error: e
                    });
            }
        });
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/token":"1nlc7","../errors":"ic8pt","../util":"aQ6vw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ic8pt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errors", ()=>errors);
parcelHelpers.export(exports, "ErrorNames", ()=>ErrorNames);
var _rtcRpcApiClient = require("@skyway-sdk/rtc-rpc-api-client");
const errors = {
    ...(0, _rtcRpcApiClient.errors),
    invalidParameter: {
        name: "invalidParameter",
        detail: "",
        solution: ""
    },
    notFound: {
        name: "notFound",
        detail: "",
        solution: ""
    },
    timeout: {
        name: "timeout",
        detail: "",
        solution: ""
    },
    internalError: {
        name: "internalError",
        detail: "",
        solution: ""
    },
    invalidRequestParameter: {
        name: "invalidRequestParameter",
        detail: "リクエストのパラメーターが正しくありません",
        solution: "API仕様を確認し正しい値を入力してください"
    },
    insufficientPermissions: {
        name: "insufficientPermissions",
        detail: "tokenの権限が不足しています Token permissions are insufficient",
        solution: "Tokenに必要な権限を加えてください Add the necessary permissions to the Token"
    },
    publicationNestedTooMuch: {
        name: "publicationNestedTooMuch",
        detail: "originが設定されているPublicationをPublicationのoriginに指定することは出来ません It is not possible to specify the origin of a publication for which Origin has been set",
        solution: "仕様上の制約なので解決法はありません There is no solution because it is a specification limitation"
    },
    channelNotFound: {
        name: "channelNotFound",
        detail: "参照しようとしたchannelは存在しません The channel you tried to reference does not exist.",
        solution: "channelIdやchannelNameが正しいか確かめてください Make sure that the Channel id and channel name are correct."
    },
    memberNotFound: {
        name: "memberNotFound",
        detail: "参照しようとしたMemberは存在しません The member you tried to reference does not exist.",
        solution: "memberIdやmemberNameが正しいか確かめてください Make sure that the member id and member name is correct."
    },
    publicationNotFound: {
        name: "publicationNotFound",
        detail: "参照しようとしたPublicationは存在しません The Publication you tried to reference does not exist.",
        solution: "publicationIdが正しいか確かめてください Make sure that the publication id is correct."
    },
    subscriptionNotFound: {
        name: "subscriptionNotFound",
        detail: "参照しようとしたSubscriptionは存在しません The Subscription you tried to reference does not exist.",
        solution: "subscriptionIdが正しいか確かめてください Make sure that the subscription id is correct."
    },
    operationConflicted: {
        name: "operationConflicted",
        detail: "与えられた名前のチャネルは、今までの競合する要求によって、すでに作成されています The channel with the given name has already been created by a conflicting request up to now",
        solution: "別の名前を使ってchannelを作成してください"
    },
    channelNameDuplicated: {
        name: "channelNameDuplicated",
        detail: "その名前のChannelはすでに存在します A channel with that name already exists",
        solution: "別の名前を使ってchannelを作成してください"
    },
    memberNameDuplicated: {
        name: "memberNameDuplicated",
        detail: "その名前のMemberはすでに存在します A member with that name already exists",
        solution: "別の名前を使ってmemberを作成してください"
    },
    subscriptionAlreadyExists: {
        name: "subscriptionAlreadyExists",
        detail: "PublicationはすでにSubscribeされています",
        solution: "publicationIdが正しいか確かめてください"
    },
    rateLimitExceeded: {
        name: "rateLimitExceeded",
        detail: "リソースを規定仕様以上に消費しています",
        solution: "リソースの消費量を減らしてください"
    },
    authTokenExpired: {
        name: "authTokenExpired",
        detail: "AuthTokenが期限切れです",
        solution: "適切なExpを設定したAuthTokenを使用してください"
    },
    serverBusy: {
        name: "serverBusy",
        detail: "サービス側の問題です",
        solution: "しばらく時間を置いて再試行してください"
    }
};
const ErrorNames = Object.keys(errors);

},{"@skyway-sdk/rtc-rpc-api-client":"NA7aK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aQ6vw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createWarnPayload", ()=>createWarnPayload);
parcelHelpers.export(exports, "createError", ()=>createError);
var _common = require("@skyway-sdk/common");
function createWarnPayload({ appId , detail , channelId , operationName , payload  }) {
    const warn = {
        operationName,
        payload,
        detail,
        appId,
        channelId
    };
    return warn;
}
function createError({ operationName , info , error , path , channelId , appId , payload  }) {
    return new (0, _common.SkyWayError)({
        error,
        info: info,
        payload: {
            payload,
            operationName,
            channelId,
            appId
        },
        path
    });
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dXVw4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EventObserverImpl", ()=>EventObserverImpl);
/**@internal */ parcelHelpers.export(exports, "EventJitterBuffer", ()=>EventJitterBuffer);
var _common = require("@skyway-sdk/common");
var _errors = require("../errors");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/rtc-api-client/src/infrastructure/eventObserver.ts");
class EventObserverImpl {
    onEvent = new (0, _common.Event)();
    _disposer = [];
    constructor(appId, client, channelDto, config){
        const eventBuffer = new EventJitterBuffer(channelDto.version, async (expectNextVersion)=>{
            // ここで回復できなければシステム継続不能
            await client.subscribeChannelEvents({
                appId,
                channelId: channelDto.id,
                offset: expectNextVersion
            });
            await new Promise((r)=>setTimeout(r, config.eventSubscribeTimeout));
            if (eventBuffer.packetLostHappened) log.error((0, _util.createError)({
                operationName: "EventObserverImpl.eventJitterBuffer",
                info: {
                    ...(0, _errors.errors).internalError,
                    detail: "failed to resolve event lost"
                },
                channelId: channelDto.id,
                appId,
                path: log.prefix
            }));
        });
        this._disposer = [
            client.onEvent.add(async ({ channelId , event  })=>{
                if (channelId === channelDto.id) eventBuffer.push({
                    event,
                    version: event.data.channel.version
                });
            }).removeListener,
            eventBuffer.onEvent.add((e)=>{
                this.onEvent.emit(e);
            }).removeListener
        ];
    }
    dispose() {
        this._disposer.forEach((d)=>d());
        this.onEvent.removeAllListeners();
    }
}
class EventJitterBuffer {
    constructor(presentVersion, onPacketLost, packetLifetime = 1000){
        this.presentVersion = presentVersion;
        this.onPacketLost = onPacketLost;
        this.packetLifetime = packetLifetime;
        this.onEvent = new (0, _common.Event)();
        this.eventBuffer = {};
        this.packetLostHappened = false;
    }
    get expectNextVersion() {
        return this.presentVersion + 1;
    }
    push(eventFrame) {
        const incomingVersion = eventFrame.version;
        if (incomingVersion < this.expectNextVersion) {
            log.debug("duplicate event", {
                ...eventFrame,
                presentVersion: this.presentVersion
            });
            return;
        }
        if (incomingVersion > this.expectNextVersion) {
            log.debug("maybe miss order event received", {
                ...eventFrame,
                presentVersion: this.presentVersion
            });
            this.eventBuffer[incomingVersion] = eventFrame;
            this.handlePacketLifetime();
            return;
        }
        // expected version event received
        if (this.packetLostHappened) {
            log.warn("event packetLost resolved", (0, _util.createWarnPayload)({
                operationName: "EventJitterBuffer.push",
                detail: "event packetLost resolved",
                payload: {
                    eventFrame
                }
            }));
            this.packetLostHappened = false;
        }
        this.eventBuffer[incomingVersion] = eventFrame;
        this.resolveEvents();
    }
    handlePacketLifetime() {
        const [oldestBufferedEvent] = Object.keys(this.eventBuffer).sort().map((key)=>this.eventBuffer[Number(key)]);
        if (this.packetLifeTimer == undefined && oldestBufferedEvent) {
            log.debug("set event packetLost timer", {
                ...oldestBufferedEvent,
                presentVersion: this.presentVersion
            });
            this.packetLifeTimer = setTimeout(async ()=>{
                if (this.presentVersion < oldestBufferedEvent.version) {
                    log.warn("event packetLost", (0, _util.createWarnPayload)({
                        operationName: "EventJitterBuffer.handlePacketLifetime",
                        detail: "eventPacket lost",
                        payload: {
                            oldestBufferedEvent,
                            eventBufferLength: Object.keys(this.eventBuffer).length,
                            presentVersion: this.presentVersion
                        }
                    }));
                    if (this.packetLostHappened) return;
                    else {
                        this.packetLostHappened = true;
                        await this.onPacketLost(this.expectNextVersion);
                    }
                }
                this.packetLifeTimer = undefined;
                this.handlePacketLifetime();
            }, this.packetLifetime);
        }
    }
    resolveEvents() {
        const resolve = [];
        for(let i = this.expectNextVersion;; i++){
            const frame = this.eventBuffer[i];
            if (frame) {
                resolve.push(frame);
                delete this.eventBuffer[i];
            } else break;
        }
        if (resolve.length > 0) {
            this.presentVersion = resolve.slice(-1)[0].version;
            resolve.forEach((frame)=>{
                this.onEvent.emit(frame.event);
            });
        }
    }
}

},{"@skyway-sdk/common":"3hyrG","../errors":"ic8pt","../util":"aQ6vw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPJ9W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fDjvD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChannelImpl", ()=>ChannelImpl);
parcelHelpers.export(exports, "channelFactory", ()=>channelFactory);
var _common = require("@skyway-sdk/common");
var _errors = require("../errors");
var _event = require("../model/event");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/rtc-api-client/src/domain/channel.ts");
class ChannelImpl {
    getMember(id) {
        return this.members.find((s)=>s.id === id);
    }
    addMember(member) {
        const exist = this.getMember(member.id);
        if (exist) return exist;
        this.members.push(member);
        return member;
    }
    deleteMember(id) {
        this.members = this.members.filter((m)=>m.id !== id);
    }
    getPublication(id) {
        return this.publications.find((s)=>s.id === id);
    }
    addPublication(summary) {
        const exist = this.getPublication(summary.id);
        if (exist) return exist;
        const publication = {
            ...summary,
            channelId: this.id,
            codecCapabilities: summary.codecCapabilities ?? [],
            encodings: summary.encodings ?? []
        };
        this.publications.push(publication);
        return publication;
    }
    deletePublication(publicationId) {
        this.publications = this.publications.filter((p)=>p.id !== publicationId);
    }
    getSubscription(id) {
        return this.subscriptions.find((s)=>s.id === id);
    }
    addSubscription(summary) {
        const exist = this.getSubscription(summary.id);
        if (exist) return exist;
        const publication = this.getPublication(summary.publicationId);
        const subscription = {
            ...summary,
            channelId: this.id,
            publisherId: publication.publisherId,
            contentType: publication.contentType
        };
        this.subscriptions.push(subscription);
        return subscription;
    }
    deleteSubscription(subscriptionId) {
        this.subscriptions = this.subscriptions.filter((s)=>s.id !== subscriptionId);
    }
    constructor(appId, { id , name , members , metadata , publications , subscriptions , version  }, eventObserver, apiClient, config){
        this.appId = appId;
        this.eventObserver = eventObserver;
        this.apiClient = apiClient;
        this.config = config;
        this.disposed = false;
        this._events = new (0, _common.Events)();
        this.onClosed = this._events.make();
        this.onMetadataUpdated = this._events.make();
        this.onMemberListChanged = this._events.make();
        this.onMemberJoined = this._events.make();
        this.onMemberLeft = this._events.make();
        this.onMemberMetadataUpdated = this._events.make();
        this.onPublicationDisabled = this._events.make();
        this.onPublicationEnabled = this._events.make();
        this.onPublicationListChanged = this._events.make();
        this.onStreamPublished = this._events.make();
        this.onStreamUnpublished = this._events.make();
        this.onPublicationMetadataUpdated = this._events.make();
        this.onSubscriptionListChanged = this._events.make();
        this.onPublicationSubscribed = this._events.make();
        this.onPublicationUnsubscribed = this._events.make();
        this.updateChannelMetadata = (metadata)=>new Promise((r, f)=>{
                let failed = false;
                this.apiClient.updateChannelMetadata(this.appId, this.id, metadata).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onMetadataUpdated.watch((e)=>e.channel.metadata === metadata).then(()=>r()).catch((error)=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "ChannelImpl.updateChannelMetadata",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onMetadataUpdated"
                        },
                        path: log.prefix,
                        error,
                        appId: this.appId,
                        channelId: this.id
                    }));
                });
            });
        this.leave = (channelId, memberId)=>new Promise((r, f)=>{
                let failed = false;
                this.apiClient.leave(this.appId, channelId, memberId).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onMemberLeft.watch((e)=>e.member.id === memberId, this.config.rtcApi.timeout).then(()=>r()).catch((error)=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "ChannelImpl.leave",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onMemberLeft"
                        },
                        path: log.prefix,
                        error,
                        appId: this.appId,
                        channelId: this.id
                    }));
                });
            });
        this.updateMemberMetadata = (memberId, metadata)=>new Promise((r, f)=>{
                let failed = false;
                this.apiClient.updateMemberMetadata(this.appId, this.id, memberId, metadata).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onMemberMetadataUpdated.watch((e)=>e.member.id === memberId && e.member.metadata === metadata).then(()=>r()).catch((error)=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "ChannelImpl.updateMemberMetadata",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onMemberMetadataUpdated"
                        },
                        path: log.prefix,
                        error,
                        appId: this.appId,
                        channelId: this.id
                    }));
                });
            });
        this.unpublish = (publicationId)=>new Promise((r, f)=>{
                let failed = false;
                this.apiClient.unpublish(this.appId, this.id, publicationId).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onStreamUnpublished.watch((e)=>e.publication.id === publicationId).then(()=>r()).catch((error)=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "ChannelImpl.unpublish",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onStreamUnpublished"
                        },
                        path: log.prefix,
                        error,
                        payload: {
                            publicationId
                        },
                        appId: this.appId,
                        channelId: this.id
                    }));
                });
            });
        this.updatePublicationMetadata = (publicationId, metadata)=>new Promise((r, f)=>{
                let failed = false;
                this.apiClient.updatePublicationMetadata(this.appId, this.id, publicationId, metadata).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onPublicationMetadataUpdated.watch((e)=>e.publication.id === publicationId && e.publication.metadata === metadata).then(()=>r()).catch((error)=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "ChannelImpl.updatePublicationMetadata",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onPublicationMetadataUpdated"
                        },
                        path: log.prefix,
                        error,
                        payload: {
                            publicationId
                        },
                        appId: this.appId,
                        channelId: this.id
                    }));
                });
            });
        this.disablePublication = (publicationId)=>new Promise((r, f)=>{
                let failed = false;
                this.apiClient.disablePublication(this.appId, this.id, publicationId).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onPublicationDisabled.watch((e)=>e.publication.id === publicationId).then(()=>r()).catch((error)=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "ChannelImpl.disablePublication",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onPublicationDisabled"
                        },
                        path: log.prefix,
                        error,
                        payload: {
                            publicationId
                        },
                        appId: this.appId,
                        channelId: this.id
                    }));
                });
            });
        this.enablePublication = (publicationId)=>new Promise((r, f)=>{
                let failed = false;
                this.apiClient.enablePublication(this.appId, this.id, publicationId).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onPublicationEnabled.watch((e)=>e.publication.id === publicationId).then(()=>r()).catch((error)=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "ChannelImpl.enablePublication",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onPublicationEnabled"
                        },
                        path: log.prefix,
                        error,
                        payload: {
                            publicationId
                        },
                        appId: this.appId,
                        channelId: this.id
                    }));
                });
            });
        this.unsubscribe = (subscriptionId)=>new Promise((r, f)=>{
                let failed = false;
                this.apiClient.unsubscribe(this.appId, this.id, subscriptionId).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onPublicationUnsubscribed.watch((e)=>e.subscription.id === subscriptionId).then(()=>r()).catch((error)=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "ChannelImpl.unsubscribe",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onPublicationUnsubscribed"
                        },
                        path: log.prefix,
                        error,
                        payload: {
                            subscriptionId
                        },
                        appId: this.appId,
                        channelId: this.id
                    }));
                });
            });
        this.id = id;
        this.name = name;
        this.metadata = metadata;
        this.members = members;
        this.publications = publications;
        this.subscriptions = subscriptions;
        this.version = version;
        eventObserver.onEvent.add((event)=>{
            log.debug("received event: ", event);
            this.version = event.data.channel.version;
            try {
                switch(event.type){
                    case "ChannelDeleted":
                        this._channelClosed();
                        break;
                    case "ChannelMetadataUpdated":
                        this._channelMetadataUpdated(event.data);
                        break;
                    case "MemberAdded":
                        this._memberJoined(event.data);
                        break;
                    case "MemberRemoved":
                        this._memberLeft(event.data);
                        break;
                    case "MemberMetadataUpdated":
                        this._memberMetadataUpdated(event.data);
                        break;
                    case "StreamPublished":
                        this._streamPublished(event.data);
                        break;
                    case "StreamUnpublished":
                        this._streamUnpublished(event.data);
                        break;
                    case "PublicationMetadataUpdated":
                        this._publicationMetadataUpdated(event.data);
                        break;
                    case "PublicationDisabled":
                        this._publicationDisabled(event.data);
                        break;
                    case "PublicationEnabled":
                        this._publicationEnabled(event.data);
                        break;
                    case "StreamSubscribed":
                        this._streamSubscribed(event.data);
                        break;
                    case "StreamUnsubscribed":
                        this._streamUnsubscribed(event.data);
                        break;
                }
            } catch (error) {
                log.error(error);
            }
        });
        apiClient.onClose.once(()=>{
            this.dispose();
        });
    }
    _channelClosed() {
        this.onClosed.emit({});
    }
    _channelMetadataUpdated(event) {
        this.metadata = event.channel.metadata;
        this.onMetadataUpdated.emit(event);
    }
    _memberJoined(event) {
        this.addMember(event.member);
        this.onMemberJoined.emit(event);
        this.onMemberListChanged.emit({});
    }
    _memberLeft(event) {
        const member = this.getMember(event.member.id);
        if (!member) throw (0, _util.createError)({
            operationName: "ChannelImpl._memberLeft",
            info: (0, _errors.errors).memberNotFound,
            path: log.prefix,
            payload: {
                event
            },
            appId: this.appId,
            channelId: this.id
        });
        this.deleteMember(member.id);
        this.onMemberLeft.emit({
            member
        });
        this.onMemberListChanged.emit({});
    }
    _memberMetadataUpdated(event) {
        const member = this.getMember(event.member.id);
        if (!member) throw (0, _util.createError)({
            operationName: "ChannelImpl._memberMetadataUpdated",
            info: (0, _errors.errors).memberNotFound,
            path: log.prefix,
            payload: {
                event
            },
            appId: this.appId,
            channelId: this.id
        });
        member.metadata = event.member.metadata;
        this.onMemberMetadataUpdated.emit(event);
    }
    _streamPublished(event) {
        const publication = this.addPublication(event.publication);
        const outgoing = {
            ...event,
            publication
        };
        this.onStreamPublished.emit(outgoing);
        this.onPublicationListChanged.emit({});
    }
    _streamUnpublished(event) {
        const publication = this.getPublication(event.publication.id);
        if (!publication) throw (0, _util.createError)({
            operationName: "ChannelImpl._streamUnpublished",
            info: (0, _errors.errors).publicationNotFound,
            path: log.prefix,
            payload: {
                event
            },
            appId: this.appId,
            channelId: this.id
        });
        this.deletePublication(publication.id);
        const outgoing = {
            ...event,
            publication
        };
        this.onStreamUnpublished.emit(outgoing);
        this.onPublicationListChanged.emit({});
    }
    _publicationMetadataUpdated(event) {
        const publication = this.getPublication(event.publication.id);
        if (!publication) throw (0, _util.createError)({
            operationName: "ChannelImpl._publicationMetadataUpdated",
            info: (0, _errors.errors).publicationNotFound,
            path: log.prefix,
            payload: {
                event
            },
            appId: this.appId,
            channelId: this.id
        });
        publication.metadata = event.publication.metadata;
        const outgoing = {
            ...event,
            publication
        };
        this.onPublicationMetadataUpdated.emit(outgoing);
    }
    _publicationDisabled(event) {
        const publication = this.getPublication(event.publication.id);
        if (!publication) throw (0, _util.createError)({
            operationName: "ChannelImpl._publicationDisabled",
            info: (0, _errors.errors).publicationNotFound,
            path: log.prefix,
            payload: {
                event
            },
            appId: this.appId,
            channelId: this.id
        });
        publication.isEnabled = event.publication.isEnabled;
        const outgoing = {
            publication
        };
        this.onPublicationDisabled.emit(outgoing);
    }
    _publicationEnabled(incoming) {
        const publication = this.getPublication(incoming.publication.id);
        if (!publication) throw (0, _util.createError)({
            operationName: "ChannelImpl._publicationEnabled",
            info: (0, _errors.errors).publicationNotFound,
            path: log.prefix,
            payload: {
                event: _event
            },
            appId: this.appId,
            channelId: this.id
        });
        publication.isEnabled = incoming.publication.isEnabled;
        const outgoing = {
            publication
        };
        this.onPublicationEnabled.emit(outgoing);
    }
    _streamSubscribed(incoming) {
        const subscription = this.addSubscription(incoming.subscription);
        const outgoing = {
            ...incoming,
            subscription
        };
        this.onPublicationSubscribed.emit(outgoing);
        this.onSubscriptionListChanged.emit({});
    }
    _streamUnsubscribed(event) {
        const subscription = this.getSubscription(event.subscription.id);
        if (!subscription) throw (0, _util.createError)({
            operationName: "ChannelImpl._streamUnsubscribed",
            info: (0, _errors.errors).subscriptionNotFound,
            path: log.prefix,
            payload: {
                event
            },
            appId: this.appId,
            channelId: this.id
        });
        this.deleteSubscription(subscription.id);
        const outgoing = {
            ...event,
            subscription
        };
        this.onPublicationUnsubscribed.emit(outgoing);
        this.onSubscriptionListChanged.emit({});
    }
    async joinChannel(memberInit) {
        if (memberInit.type) memberInit.type = memberInit.type[0].toUpperCase() + memberInit.type.slice(1);
        if (memberInit.subtype) memberInit.subtype = memberInit.subtype[0].toUpperCase() + memberInit.subtype.slice(1);
        log.debug("[start] joinChannel", {
            memberInit
        });
        const res = await this.apiClient.join(this.appId, this.id, {
            ...memberInit
        });
        const member = this.getMember(res.id) ?? (await this.onMemberJoined.watch((e)=>e.member.id === res.id, this.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "ChannelImpl.joinChannel",
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onMemberJoined"
                },
                path: log.prefix,
                error,
                appId: this.appId,
                channelId: this.id
            });
        })).member;
        log.debug("[end] joinChannel", {
            member
        });
        return member;
    }
    updateMemberTtl(memberId, ttlSec) {
        return this.apiClient.updateMemberTtl(this.appId, this.id, memberId, ttlSec);
    }
    /**@throws {SkyWayError} */ async publish(init) {
        const ts = log.debug("[start] apiClient.publish", {
            init
        });
        const channelId = this.id;
        const publicationId = await this.apiClient.publish(this.appId, {
            ...init,
            channel: channelId
        });
        const publicationDto = {
            id: publicationId,
            channelId,
            publisherId: init.publisher,
            origin: init.origin,
            contentType: init.contentType,
            metadata: init.metadata,
            codecCapabilities: init.codecCapabilities ?? [],
            encodings: init.encodings ?? [],
            isEnabled: init.isEnabled ?? true
        };
        log.elapsed(ts, "[ongoing] apiClient.publish", {
            publicationDto
        });
        const exist = this.getPublication(publicationId);
        if (exist) return exist;
        const { publication  } = await this.onStreamPublished.watch((e)=>e.publication.id === publicationId, this.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "ChannelImpl.publish",
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onStreamPublished"
                },
                path: log.prefix,
                error,
                payload: {
                    publicationDto
                },
                appId: this.appId,
                channelId: this.id
            });
        });
        log.elapsed(ts, "[end] apiClient.publish", {
            publicationDto
        });
        return publication;
    }
    /**@throws {@link SkyWayError} */ async subscribe(init) {
        const ts = log.debug("[start] apiClient.subscribe", {
            init
        });
        const subscriptionId = await this.apiClient.subscribe(this.appId, {
            ...init,
            channel: this
        });
        const subscriptionDto = {
            id: subscriptionId,
            publicationId: init.publication.id,
            channelId: this.id,
            publisherId: init.publication.publisherId,
            subscriberId: init.subscriber.id,
            contentType: init.publication.contentType
        };
        log.elapsed(ts, "[ongoing] apiClient.subscribe", {
            subscriptionDto
        });
        const exist = this.getSubscription(subscriptionId);
        if (exist) {
            log.elapsed(ts, "[end] apiClient.subscribe", {
                subscriptionDto
            });
            return exist;
        }
        const { subscription  } = await this.onPublicationSubscribed.watch((e)=>e.subscription.id === subscriptionId, this.config.rtcApi.timeout).catch((error)=>{
            log.elapsed(ts, "[fail] apiClient.subscribe", error);
            throw (0, _util.createError)({
                operationName: "ChannelImpl.subscribe",
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onPublicationSubscribed"
                },
                path: log.prefix,
                error,
                payload: {
                    subscriptionDto
                }
            });
        });
        log.elapsed(ts, "[end] apiClient.subscribe", {
            subscriptionDto
        });
        return subscription;
    }
    close() {
        return this.apiClient.deleteChannel(this.appId, this.id);
    }
    /**
   * リソースの解放
   * - Channelイベントの購読停止
   * - イベントリスナー
   */ dispose() {
        if (this.disposed) return;
        this.disposed = true;
        log.debug("disposed", {
            id: this.id
        });
        this.eventObserver.dispose();
        this._events.dispose();
    }
}
function channelFactory(appId, eventObserver, api, channelDto, config) {
    const channel = new ChannelImpl(appId, channelDto, eventObserver, api, config);
    return channel;
}

},{"@skyway-sdk/common":"3hyrG","../errors":"ic8pt","../model/event":"9rdhv","../util":"aQ6vw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9rdhv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c9WRi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RtcApiConfig", ()=>(0, _rtcApiClient.RtcApiConfig));
parcelHelpers.export(exports, "RtcRpcApiConfig", ()=>(0, _rtcApiClient.RtcRpcApiConfig));
parcelHelpers.export(exports, "ContextConfig", ()=>ContextConfig);
var _rtcApiClient = require("@skyway-sdk/rtc-api-client");
var _deepmerge = require("deepmerge");
var _deepmergeDefault = parcelHelpers.interopDefault(_deepmerge);
class ContextConfig {
    /**@internal */ rtcApi = {
        domain: "rtc-api.skyway.ntt.com",
        timeout: 30000,
        secure: true,
        eventSubscribeTimeout: 5000
    };
    /**@internal */ iceParamServer = {
        domain: "ice-params.skyway.ntt.com",
        version: 1,
        secure: true
    };
    /**@internal */ signalingService = {
        domain: "signaling.skyway.ntt.com",
        secure: true
    };
    /**@internal */ analyticsService = {
        domain: "analytics-logging.skyway.ntt.com",
        secure: true
    };
    rtcConfig = {
        timeout: 30000,
        turnPolicy: "enable",
        turnProtocol: "all",
        encodedInsertableStreams: false,
        iceDisconnectBufferTimeout: 5000
    };
    token = {
        updateReminderSec: 30
    };
    log = {
        level: "error",
        format: "string"
    };
    /**@internal */ internal = {
        disableDPlane: false
    };
    member = {
        keepaliveIntervalGapSec: 30,
        keepaliveIntervalSec: 30
    };
    /**@internal */ constructor(options = {}){
        Object.assign(this, (0, _deepmergeDefault.default)(this, options));
    }
}

},{"@skyway-sdk/rtc-api-client":"cfsMg","deepmerge":"ck1Q2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"47TnT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PersonPlugin", ()=>PersonPlugin);
parcelHelpers.export(exports, "registerPersonPlugin", ()=>registerPersonPlugin);
var _plugin = require("../../interface/plugin");
var _messageBuffer = require("./connection/messageBuffer");
var _member = require("./member");
class PersonPlugin extends (0, _plugin.SkyWayPlugin) {
    subtype = "person";
    _messageBuffers = {};
    _whenCreateLocalPerson = async (person)=>{
        if (person._signaling) this._messageBuffers[person.id] = new (0, _messageBuffer.MessageBuffer)(person._signaling);
    };
    _whenDisposeLocalPerson = async (person)=>{
        const messageBuffer = this._messageBuffers[person.id];
        if (messageBuffer) {
            messageBuffer.close();
            delete this._messageBuffers[person.id];
        }
    };
    _createRemoteMember = (channel, memberDto)=>{
        const person = new (0, _member.RemotePersonImpl)({
            ...this._context,
            context: this._context,
            channel,
            metadata: memberDto.metadata,
            id: memberDto.id,
            name: memberDto.name,
            plugin: this
        });
        return person;
    };
}
const registerPersonPlugin = (context)=>{
    const plugin = new PersonPlugin();
    context.registerPlugin(plugin);
    return plugin;
};

},{"../../interface/plugin":"3MSpg","./connection/messageBuffer":"1KIu1","./member":"k0JDW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MSpg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "SkyWayPlugin", ()=>SkyWayPlugin);
var _common = require("@skyway-sdk/common");
class SkyWayPlugin {
    /**@internal */ _onContextAttached = new (0, _common.Event)();
    /**@internal */ _attachContext(context) {
        this._context = context;
        this._onContextAttached.emit(context);
    }
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1KIu1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
connectionが生成されるイベントの通信経路と、
メッセージングの通信経路が違うので、
connectionが生成される前にメッセージを受信する
タイミング問題が起きうる。
その対策のためのコンポーネント
*/ parcelHelpers.export(exports, "MessageBuffer", ()=>MessageBuffer);
var _common = require("@skyway-sdk/common");
const log = new (0, _common.Logger)("packages/core/src/plugin/internal/person/connection/messageBuffer.ts");
class MessageBuffer {
    constructor(signaling){
        this.signaling = signaling;
        this._indicateMessageBuffer = {};
        this._excludeConnectionIndicateBuffering = new Set();
        this._disposer = new (0, _common.EventDisposer)();
        this.signaling.onMessage.add((req)=>{
            const requesterIdName = req.src.id + req.src.name;
            if (this._excludeConnectionIndicateBuffering.has(requesterIdName)) return;
            if (!this._indicateMessageBuffer[requesterIdName]) this._indicateMessageBuffer[requesterIdName] = [];
            this._indicateMessageBuffer[requesterIdName].push(req);
        }).disposer(this._disposer);
    }
    resolveMessagingBuffer({ id , name  }) {
        const endpointIdName = id + name;
        const bufferedIndicates = this._indicateMessageBuffer[endpointIdName];
        if (bufferedIndicates?.length > 0) {
            log.debug("resolveMessagingBuffer", {
                length: bufferedIndicates.length
            });
            bufferedIndicates.forEach((req)=>{
                this.signaling.onMessage.emit(req);
            });
            delete this._indicateMessageBuffer[endpointIdName];
        }
        this._excludeConnectionIndicateBuffering.add(endpointIdName);
    }
    close() {
        this._disposer.dispose();
        this._indicateMessageBuffer = {};
        this._excludeConnectionIndicateBuffering = new Set();
    }
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k0JDW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "RemotePersonImpl", ()=>RemotePersonImpl);
var _common = require("@skyway-sdk/common");
var _errors = require("../../../errors");
var _member = require("../../../member");
var _util = require("../../../util");
var _connection = require("./connection");
const log = new (0, _common.Logger)("packages/core/src/plugin/internal/person/member.ts");
class RemotePersonImpl extends (0, _member.MemberImpl) {
    constructor(args){
        super(args);
        this.args = args;
        this.type = "person";
        this.subtype = "person";
        this.side = "remote";
        this._connections = {};
        this._context = this.args.channel._context;
        this._disposer = new (0, _common.EventDisposer)();
        this.onPublicationSubscribed = this._events.make();
        this.onPublicationUnsubscribed = this._events.make();
        this.onPublicationListChanged = this._events.make();
        this.onSubscriptionListChanged = this._events.make();
        this.subscribe = (publicationId)=>new Promise((r, f)=>{
                let failed = false;
                this.channel._subscribe(this.id, publicationId).catch((e)=>{
                    failed = true;
                    f(e);
                });
                this.onPublicationSubscribed.watch(({ subscription  })=>subscription.publication.id === publicationId, this._context.config.rtcApi.timeout).then(({ subscription  })=>{
                    r({
                        subscription
                    });
                }).catch(()=>{
                    if (!failed) f((0, _util.createError)({
                        operationName: "RemotePersonImpl.subscribe",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onPublicationSubscribed"
                        },
                        path: log.prefix,
                        context: this._context,
                        channel: this.channel
                    }));
                });
            });
        this.plugin = args.plugin;
        this.channel.onPublicationUnsubscribed.add(({ subscription  })=>{
            if (subscription.subscriber.id === this.id) {
                this.onPublicationUnsubscribed.emit({
                    subscription
                });
                this.onSubscriptionListChanged.emit();
            }
        }).disposer(this._disposer);
        this.channel.onPublicationSubscribed.add(({ subscription  })=>{
            if (subscription.subscriber.id === this.id) {
                this.onPublicationSubscribed.emit({
                    subscription
                });
                this.onSubscriptionListChanged.emit();
            }
        }).disposer(this._disposer);
        this.channel.onStreamPublished.add(({ publication  })=>{
            if (publication.publisher.id === this.id) this.onPublicationListChanged.emit();
        }).disposer(this._disposer);
        this.channel.onStreamUnpublished.add(({ publication  })=>{
            if (publication.publisher.id === this.id) this.onPublicationListChanged.emit();
        }).disposer(this._disposer);
        this.onLeft.once(()=>{
            log.debug("RemotePerson left: ", this.toJSON());
            Object.values(this._connections).forEach((connection)=>{
                connection.close({
                    reason: "remote person left"
                });
            });
            this._connections = {};
        });
    }
    /**@private */ _getConnection(localPersonId) {
        return this._connections[localPersonId];
    }
    /**@private */ _getOrCreateConnection(localPerson) {
        const connection = this._getConnection(localPerson.id) ?? this._createConnection(this.channel, localPerson, this);
        return connection;
    }
    _createConnection(channel, localPerson, endpointMember) {
        if (localPerson.side !== "local") throw (0, _util.createError)({
            operationName: "RemotePersonImpl._createConnection",
            info: {
                ...(0, _errors.errors).invalidArgumentValue,
                detail: "wrong localPerson type"
            },
            path: log.prefix,
            context: this._context,
            channel: this.channel
        });
        if (!localPerson._signaling) throw (0, _util.createError)({
            operationName: "RemotePersonImpl._createConnection",
            info: {
                ...(0, _errors.errors).missingProperty,
                detail: "signalingSession not exist"
            },
            path: log.prefix,
            context: this._context,
            channel: this.channel
        });
        const connection = new (0, _connection.P2PConnection)(localPerson.iceManager, localPerson._signaling, localPerson._analytics, this._context, channel.id, localPerson, endpointMember);
        this.plugin._messageBuffers[localPerson.id].resolveMessagingBuffer(endpointMember);
        connection.onClose.once(()=>{
            log.debug("connection closed", this.toJSON(), {
                connectionId: connection.id
            });
            delete this._connections[localPerson.id];
        });
        this._connections[localPerson.id] = connection;
        return connection;
    }
    async unsubscribe(subscriptionId) {
        await this.channel._unsubscribe(subscriptionId);
    }
    _dispose() {
        this._disposer.dispose();
    }
}

},{"@skyway-sdk/common":"3hyrG","../../../errors":"gDbIj","../../../member":"dkuHe","../../../util":"ey5Lv","./connection":"9R3XO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9R3XO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "P2PConnection", ()=>P2PConnection);
var _common = require("@skyway-sdk/common");
var _uuid = require("uuid");
var _errors = require("../../../../errors");
var _publication = require("../../../../publication");
var _util = require("../../../../util");
var _receiver = require("./receiver");
var _sender = require("./sender");
const log = new (0, _common.Logger)("packages/core/src/plugin/internal/person/connection/index.ts");
class P2PConnection {
    /**@internal */ constructor(_iceManager, _signaling, _analytics, _context, channelId, localPerson, remoteMember){
        this._iceManager = _iceManager;
        this._signaling = _signaling;
        this._analytics = _analytics;
        this._context = _context;
        this.channelId = channelId;
        this.localPerson = localPerson;
        this.remoteMember = remoteMember;
        this.id = (0, _uuid.v4)();
        this.type = "p2p";
        this.onDisconnect = new (0, _common.Event)();
        this.onClose = new (0, _common.Event)();
        this.closed = false;
        this.disconnected = false;
        this._log = log.createBlock({
            id: this.id,
            localPersonId: this.localPerson.id
        });
        this._pubsubQueue = new (0, _common.PromiseQueue)();
        this.sendSubscriptionStatsReportTimers = new Map();
        this._waitingSendSubscriptionStatsReportsFromPublish = new Map();
        this._waitingSendSubscriptionStatsReportsFromSubscribe = [];
        this.sender = new (0, _sender.Sender)(this._context, this._iceManager, this._signaling, this._analytics, this.localPerson, this.remoteMember);
        this.receiver = new (0, _receiver.Receiver)(this._context, this._iceManager, this._signaling, this._analytics, this.localPerson, this.remoteMember);
        this.sender.onDisconnect.once(()=>{
            this.disconnected = true;
            this.onDisconnect.emit();
        });
        this.receiver.onDisconnect.once(()=>{
            this.disconnected = true;
            this.onDisconnect.emit();
        });
        if (this._analytics) this._analytics.onConnectionStateChanged.add((state)=>{
            // AnalyticsServerに初回接続できなかった場合のsendSubscriptionStatsReportタイマー再セット処理
            if (state !== "connected") return;
            if (this._waitingSendSubscriptionStatsReportsFromPublish.size > 0) {
                for (const [subscriptionId, publicationId] of this._waitingSendSubscriptionStatsReportsFromPublish){
                    const publication = this.sender.publications[publicationId];
                    if (publication) this.startSendSubscriptionStatsReportTimer(publication, subscriptionId);
                }
                this._waitingSendSubscriptionStatsReportsFromPublish.clear();
            }
            if (this._waitingSendSubscriptionStatsReportsFromSubscribe.length > 0) {
                for (const subscriptionId of this._waitingSendSubscriptionStatsReportsFromSubscribe){
                    const subscription = this.receiver.subscriptions[subscriptionId];
                    if (subscription) this.startSendSubscriptionStatsReportTimer(subscription, subscriptionId);
                }
                this._waitingSendSubscriptionStatsReportsFromSubscribe = [];
            }
        });
    }
    /**
   * @internal
   * @throws {SkyWayError}
   */ async startPublishing(publication, subscriptionId) {
        await this._pubsubQueue.push(async ()=>{
            this._log.debug("startPublishing", {
                publication
            });
            await this.sender.add(publication);
        });
        if (this._analytics && !this._analytics.isClosed()) {
            this._analytics.client.sendBindingRtcPeerConnectionToSubscription({
                subscriptionId: subscriptionId,
                role: "sender",
                rtcPeerConnectionId: this.sender.rtcPeerConnectionId
            });
            if (this._analytics.client.isConnectionEstablished()) this.startSendSubscriptionStatsReportTimer(publication, subscriptionId);
            else // AnalyticsServerに初回接続できなかった場合はキューに入れる
            this._waitingSendSubscriptionStatsReportsFromPublish.set(subscriptionId, publication.id);
        }
    }
    /**@internal */ async stopPublishing(publication) {
        await this._pubsubQueue.push(async ()=>{
            this._log.debug("<stopPublishing> start", {
                publication
            });
            this.sender.remove(publication.id).then(()=>{
                this._log.debug("<stopPublishing> removed", {
                    publication
                });
            }).catch((e)=>{
                this._log.error("<stopPublishing> remove failed", e, {
                    publication
                });
            });
            this._closeIfNeeded();
            this._log.debug("<stopPublishing> end", {
                publication
            });
        });
        // publication(=stream）のidをkeyとして一致するタイマーを取得する
        const sendSubscriptionStatsReportTimer = this.sendSubscriptionStatsReportTimers.get(publication.id);
        if (sendSubscriptionStatsReportTimer) {
            clearInterval(sendSubscriptionStatsReportTimer);
            this.sendSubscriptionStatsReportTimers.delete(publication.id);
        }
    }
    /**@internal */ async startSubscribing(subscription) {
        await this._pubsubQueue.push(async ()=>{
            this._log.debug("startSubscribing", {
                subscription
            });
            this.receiver.add(subscription);
            const publicationId = subscription.publication.id;
            let stream = this.receiver.streams[publicationId];
            if (!stream) {
                await this.receiver.onStreamAdded.watch((res)=>res.publicationId === publicationId, this._context.config.rtcConfig.timeout).catch(()=>{
                    throw (0, _util.createError)({
                        operationName: "P2PConnection.startSubscribing",
                        info: {
                            ...(0, _errors.errors).timeout,
                            detail: "onStreamAdded"
                        },
                        path: log.prefix,
                        context: this._context,
                        channel: this.localPerson.channel,
                        payload: {
                            subscription
                        }
                    });
                });
                stream = this.receiver.streams[publicationId];
            }
            stream.setIsEnabled(subscription.publication.state === "enabled");
            subscription.codec = stream.codec;
            subscription._setStream(stream);
            if (this._analytics && !this._analytics.isClosed()) {
                this._analytics.client.sendBindingRtcPeerConnectionToSubscription({
                    subscriptionId: subscription.id,
                    role: "receiver",
                    rtcPeerConnectionId: this.receiver.rtcPeerConnectionId
                });
                if (this._analytics.client.isConnectionEstablished()) this.startSendSubscriptionStatsReportTimer(subscription, subscription.id);
                else // AnalyticsServerに初回接続できなかった場合はキューに入れる
                this._waitingSendSubscriptionStatsReportsFromSubscribe.push(subscription.id);
            }
        });
    }
    /**@internal */ async stopSubscribing(subscription) {
        await this._pubsubQueue.push(async ()=>{
            this._log.debug("stopSubscribing", {
                subscription
            });
            this.receiver.remove(subscription.id);
            this._closeIfNeeded();
        });
        // subscription(=stream）のidをkeyとして一致するタイマーを取得する
        const sendSubscriptionStatsReportTimer = this.sendSubscriptionStatsReportTimers.get(subscription.id);
        if (sendSubscriptionStatsReportTimer) {
            clearInterval(sendSubscriptionStatsReportTimer);
            this.sendSubscriptionStatsReportTimers.delete(subscription.id);
        }
    }
    _closeIfNeeded() {
        if (this.sender.hasMedia || this.receiver.hasMedia) return;
        this.close({
            reason: "no media"
        });
    }
    async getStats(content) {
        const stream = content.stream;
        if (!stream) throw (0, _util.createError)({
            operationName: "P2PConnection.getStats",
            info: {
                ...(0, _errors.errors).invalidArgumentValue,
                detail: "Subscription or Publication must has stream"
            },
            path: log.prefix,
            context: this._context,
            channel: this.localPerson.channel
        });
        if (stream.side === "local") {
            if (stream.contentType === "data") return this.sender.pc.getStats();
            return this.sender.pc.getStats(stream.track);
        } else {
            if (stream.contentType === "data") return this.receiver.pc.getStats();
            return this.receiver.pc.getStats(stream.track);
        }
    }
    /**@internal */ close({ reason  } = {}) {
        if (this.closed) return;
        this.closed = true;
        this._log.debug("closed", {
            endpointId: this.remoteMember.id,
            reason,
            sender: this.sender.id,
            receiver: this.receiver.id,
            id: this.id
        });
        this.sender.close();
        this.receiver.close();
        this.onClose.emit();
    }
    startSendSubscriptionStatsReportTimer(stream, subscriptionId) {
        if (this._analytics) {
            const role = stream instanceof (0, _publication.PublicationImpl) ? "sender" : "receiver";
            const intervalSec = this._analytics.client.getIntervalSec();
            this.sendSubscriptionStatsReportTimers.set(stream.id, setInterval(async ()=>{
                if (!this._analytics) throw (0, _util.createError)({
                    operationName: "P2PConnection.sendSubscriptionStatsReportTimer",
                    info: {
                        ...(0, _errors.errors).missingProperty,
                        detail: "AnalyticsSession not exist"
                    },
                    path: log.prefix,
                    context: this._context,
                    channel: this.localPerson.channel
                });
                // AnalyticsSessionがcloseされていたらタイマーを止める
                if (this._analytics.isClosed()) {
                    const subscriptionStatsReportTimer = this.sendSubscriptionStatsReportTimers.get(stream.id);
                    if (subscriptionStatsReportTimer) {
                        clearInterval(subscriptionStatsReportTimer);
                        this.sendSubscriptionStatsReportTimers.delete(stream.id);
                    }
                    return;
                }
                const stats = await this.getStats(stream);
                if (stats) this._analytics.client.sendSubscriptionStatsReport(stats, {
                    subscriptionId: subscriptionId,
                    role: role,
                    createdAt: Date.now()
                });
            }, intervalSec * 1000));
        }
    }
}
const p2pMessageKinds = [
    "senderProduceMessage",
    "senderUnproduceMessage",
    "receiverAnswerMessage",
    "iceCandidateMessage",
    "senderRestartIceMessage",
    "ping"
];

},{"@skyway-sdk/common":"3hyrG","uuid":"bmRfK","../../../../errors":"gDbIj","../../../../publication":"3aobm","../../../../util":"ey5Lv","./receiver":"bP92r","./sender":"81DLa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bmRfK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":false,"./v3.js":false,"./v4.js":"aBGO8","./v5.js":false,"./nil.js":false,"./version.js":false,"./validate.js":"aQ8SN","./stringify.js":"4zh8i","./parse.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aBGO8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeJs = require("./native.js");
var _nativeJsDefault = parcelHelpers.interopDefault(_nativeJs);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
function v4(options, buf, offset) {
    if ((0, _nativeJsDefault.default).randomUUID && !buf && !options) return (0, _nativeJsDefault.default).randomUUID();
    options = options || {};
    const rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJs.unsafeStringify)(rnds);
}
exports.default = v4;

},{"./native.js":"8QoZV","./rng.js":"8tTp7","./stringify.js":"4zh8i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8QoZV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports.default = {
    randomUUID
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8tTp7":[function(require,module,exports) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return getRandomValues(rnds8);
}
exports.default = rng;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4zh8i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeStringify", ()=>unsafeStringify);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"aQ8SN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aQ8SN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === "string" && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"7aBC4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7aBC4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bP92r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Receiver", ()=>Receiver);
var _common = require("@skyway-sdk/common");
var _sdpTransform = require("sdp-transform");
var _uuid = require("uuid");
var _errors = require("../../../../errors");
var _factory = require("../../../../media/stream/remote/factory");
var _util = require("../../../../util");
var _util1 = require("../util");
var _datachannel = require("./datachannel");
var _peer = require("./peer");
const log = new (0, _common.Logger)("packages/core/src/plugin/internal/person/connection/receiver.ts");
class Receiver extends (0, _peer.Peer) {
    id = (0, _uuid.v4)();
    onConnectionStateChanged = new (0, _common.Event)();
    onStreamAdded = new (0, _common.Event)();
    onError = new (0, _common.Event)();
    _connectionState = "new";
    _publicationInfo = {};
    streams = {};
    _subscriptions = {};
    _promiseQueue = new (0, _common.PromiseQueue)();
    _disposer = new (0, _common.EventDisposer)();
    _log = log.createBlock({
        localPersonId: this.localPerson.id,
        id: this.id
    });
    constructor(context, iceManager, signaling, analytics, localPerson, endpoint){
        super(context, iceManager, signaling, analytics, localPerson, endpoint, "receiver");
        this._log.debug("spawned");
        this.signaling.onMessage.add(async ({ src , data  })=>{
            if (!(src.id === endpoint.id && src.name === endpoint.name)) return;
            const message = data;
            switch(message.kind){
                case "senderProduceMessage":
                    this._promiseQueue.push(()=>this._handleSenderProduce(message.payload)).catch((err)=>this._log.error("handle senderProduceMessage failed", err, {
                            localPersonId: this.localPerson.id,
                            endpointId: this.endpoint.id
                        }));
                    break;
                case "senderUnproduceMessage":
                    this._promiseQueue.push(()=>this._handleSenderUnproduce(message.payload)).catch((err)=>this._log.error("handle handleSenderUnproduce", err, {
                            localPersonId: this.localPerson.id,
                            endpointId: this.endpoint.id
                        }));
                    break;
                case "senderRestartIceMessage":
                    this._promiseQueue.push(()=>this._handleSenderRestartIce(message.payload)).catch((err)=>this._log.error("_handleSenderRestartIce", err, {
                            localPersonId: this.localPerson.id,
                            endpointId: this.endpoint.id
                        }));
                    break;
                case "iceCandidateMessage":
                    {
                        const { role , candidate  } = message.payload;
                        if (role === "sender") await this.handleCandidate(candidate);
                    }
                    break;
            }
        }).disposer(this._disposer);
        this.pc.ontrack = async ({ track , transceiver  })=>{
            if (!transceiver.mid) throw (0, _util.createError)({
                operationName: "Receiver.pc.ontrack",
                info: {
                    ...(0, _errors.errors).missingProperty,
                    detail: "mid missing"
                },
                path: log.prefix,
                context: this._context,
                channel: this.localPerson.channel
            });
            const info = Object.values(this._publicationInfo).find((i)=>i.mid === transceiver.mid?.toString());
            if (!info) {
                const error = (0, _util.createError)({
                    operationName: "Receiver.pc.ontrack",
                    info: {
                        ...(0, _errors.errors).notFound,
                        detail: "publicationInfo not found"
                    },
                    path: log.prefix,
                    context: this._context,
                    channel: localPerson.channel,
                    payload: {
                        endpointId: this.endpoint.id,
                        publicationInfo: this._publicationInfo,
                        mid: transceiver.mid
                    }
                });
                this.onError.emit(error);
                this._log.error(error);
                return;
            }
            const sdpObject = _sdpTransform.parse(this.pc.remoteDescription.sdp);
            const codec = this._getCodecFromSdp(sdpObject, transceiver, track.kind);
            const stream = (0, _factory.createRemoteStream)(info.streamId, track, codec);
            stream.codec = codec;
            this._setupTransportAccessForStream(stream);
            this.streams[info.publicationId] = stream;
            this._log.debug("MediaStreamTrack added", info, track, codec);
            this.onStreamAdded.emit({
                publicationId: info.publicationId,
                stream
            });
        };
        this.pc.ondatachannel = async ({ channel  })=>{
            const { publicationId , streamId  } = (0, _datachannel.DataChannelNegotiationLabel).fromLabel(channel.label);
            const codec = {
                mimeType: "datachannel"
            };
            const stream = (0, _factory.createRemoteStream)(streamId, channel, codec);
            this._setupTransportAccessForStream(stream);
            this.streams[publicationId] = stream;
            this._log.debug("DataChannel added", publicationId, channel, codec);
            this.onStreamAdded.emit({
                publicationId,
                stream
            });
        };
        this.onPeerConnectionStateChanged.add((state)=>{
            switch(state){
                case "connecting":
                case "connected":
                    this._setConnectionState(state);
                    break;
                case "failed":
                case "closed":
                    this._setConnectionState("disconnected");
                    break;
            }
        }).disposer(this._disposer);
    }
    _setConnectionState(state) {
        if (this._connectionState === state) return;
        this._log.debug("onConnectionStateChanged", this.id, this._connectionState, state);
        this._connectionState = state;
        this.onConnectionStateChanged.emit(state);
    }
    _setupTransportAccessForStream(stream) {
        stream._getTransport = ()=>({
                rtcPeerConnection: this.pc,
                connectionState: (0, _util1.convertConnectionState)(this.pc.connectionState)
            });
        stream._getStats = async ()=>{
            if (stream.contentType === "data") {
                const stats = await this.pc.getStats();
                const arr = (0, _util.statsToArray)(stats);
                return arr;
            }
            const stats = await this.pc.getStats(stream.track);
            const arr = (0, _util.statsToArray)(stats);
            return arr;
        };
        this._disposer.push(()=>{
            stream._getTransport = ()=>undefined;
        });
        this.onConnectionStateChanged.add((state)=>{
            stream._setConnectionState(state);
            if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                rtcPeerConnectionId: this.rtcPeerConnectionId,
                type: "skywayConnectionStateChange",
                data: {
                    skywayConnectionState: state
                },
                createdAt: Date.now()
            });
        }).disposer(this._disposer);
    }
    _getCodecFromSdp(sdpObject, transceiver, kind) {
        const media = sdpObject.media.find(// sdpTransformのmidは実際はnumber
        (m)=>m.mid?.toString() === transceiver.mid?.toString());
        if (!media) throw (0, _util.createError)({
            operationName: "Receiver._getCodecFromSdp",
            info: {
                ...(0, _errors.errors).notFound,
                detail: "m-line not exist"
            },
            path: log.prefix,
            context: this._context,
            channel: this.localPerson.channel
        });
        const codecPT = media.payloads.split(" ")[0];
        const rtp = media.rtp.find((r)=>r.payload.toString() === codecPT);
        const mimeType = `${kind}/${rtp.codec}`.toLowerCase();
        let parameters = {};
        const fmtp = media.fmtp.find((f)=>f.payload.toString() === codecPT);
        if (fmtp?.config) parameters = (0, _util.fmtpConfigParser)(fmtp.config);
        const codec = {
            mimeType,
            parameters
        };
        return codec;
    }
    get hasMedia() {
        const count = Object.values(this.streams).length;
        this._log.debug("hasMedia", {
            count
        });
        if (count > 0) return true;
        return false;
    }
    close() {
        this._log.debug("closed");
        this.unSetPeerConnectionListener();
        this.pc.close();
        this._setConnectionState("disconnected");
        this._disposer.dispose();
    }
    add(subscription) {
        this._subscriptions[subscription.id] = subscription;
    }
    remove(subscriptionId) {
        const subscription = this._subscriptions[subscriptionId];
        if (!subscription) return;
        delete this._subscriptions[subscription.id];
        const publicationId = subscription.publication.id;
        const stream = this.streams[publicationId];
        if (!stream) return;
        delete this.streams[publicationId];
    }
    /**@throws {SkyWayError} */ _validateRemoteOffer(sdp) {
        const sdpObject = _sdpTransform.parse(sdp);
        this._log.debug("_validateRemoteOffer", {
            sdpObject
        });
        for (const sdpMediaLine of sdpObject.media){
            if (sdpMediaLine.direction === "inactive") continue;
            const exist = Object.values(this._publicationInfo).find((info)=>sdpMediaLine.mid?.toString() === info.mid);
            if (!exist) {
                const error = (0, _util.createError)({
                    operationName: "Receiver._validateRemoteOffer",
                    info: {
                        ...(0, _errors.errors).notFound,
                        detail: "mismatch between sdp and state"
                    },
                    path: log.prefix,
                    context: this._context,
                    channel: this.localPerson.channel,
                    payload: {
                        sdpMedia: sdpObject.media,
                        sdpMediaLine,
                        info: this._publicationInfo
                    }
                });
                this.onError.emit(error);
                throw error;
            }
        }
    }
    get isWrongSignalingState() {
        return this.pc.signalingState === "have-local-offer" && this.pc.remoteDescription || this.pc.signalingState === "have-remote-offer";
    }
    /**@throws {SkyWayError} */ async _handleSenderProduce({ sdp , publicationId , info  }) {
        if (this.pc.signalingState === "closed") return;
        if (this.pc.signalingState !== "stable") {
            if (this.isWrongSignalingState) {
                this._log.warn("_handleSenderProduce wait for be stable", (0, _util.createWarnPayload)({
                    operationName: "Receiver._handleSenderProduce",
                    channel: this.localPerson.channel,
                    detail: "_handleSenderProduce wait for be stable",
                    payload: {
                        signalingState: this.pc.signalingState
                    }
                }));
                await this.waitForSignalingState("stable");
                await this._handleSenderProduce({
                    sdp,
                    publicationId,
                    info
                });
                return;
            }
            throw (0, _util.createError)({
                operationName: "Receiver._handleSenderProduce",
                context: this._context,
                channel: this.localPerson.channel,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "wrong signalingState"
                },
                payload: {
                    signalingState: this.pc.signalingState
                },
                path: log.prefix
            });
        }
        this._log.debug("_handleSenderProduce", {
            info,
            publicationId,
            publicationInfo: Object.values(this._publicationInfo)
        });
        this._publicationInfo[info.publicationId] = info;
        this._validateRemoteOffer(sdp.sdp);
        await this.sendAnswer(sdp);
        await this.resolveCandidates();
    }
    /**@throws {SkyWayError} */ async _handleSenderUnproduce({ sdp , publicationId  }) {
        if (this.pc.signalingState === "closed") {
            this._log.warn("signalingState closed", (0, _util.createWarnPayload)({
                channel: this.localPerson.channel,
                detail: "signalingState closed",
                operationName: "Receiver._handleSenderUnproduce"
            }));
            return;
        }
        this._log.debug("<handleSenderUnproduce> start", {
            sdp,
            publicationId
        });
        if (this.pc.signalingState !== "stable") {
            if (this.isWrongSignalingState) {
                this._log.warn("signalingState is not stable", (0, _util.createWarnPayload)({
                    channel: this.localPerson.channel,
                    detail: "signalingState is not stable",
                    operationName: "Receiver._handleSenderUnproduce",
                    payload: {
                        signalingState: this.pc.signalingState
                    }
                }));
                await this.waitForSignalingState("stable");
                await this._handleSenderUnproduce({
                    sdp,
                    publicationId
                });
                return;
            }
            throw (0, _util.createError)({
                operationName: "Receiver._handleSenderProduce",
                context: this._context,
                channel: this.localPerson.channel,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "wrong signalingState"
                },
                payload: {
                    signalingState: this.pc.signalingState
                },
                path: log.prefix
            });
        }
        delete this._publicationInfo[publicationId];
        await this.sendAnswer(sdp);
        await this.resolveCandidates();
        this._log.debug("<handleSenderUnproduce> end", {
            publicationId
        });
    }
    /**@throws {SkyWayError} */ async _handleSenderRestartIce({ sdp  }) {
        if (this.pc.signalingState === "closed") return;
        if (this.pc.signalingState !== "stable") {
            if (this.isWrongSignalingState) {
                this._log.warn("signalingState is not stable", (0, _util.createWarnPayload)({
                    channel: this.localPerson.channel,
                    detail: "signalingState is not stable",
                    operationName: "Receiver._handleSenderRestartIce",
                    payload: {
                        signalingState: this.pc.signalingState
                    }
                }));
                await this.waitForSignalingState("stable");
                await this._handleSenderRestartIce({
                    sdp
                });
                return;
            }
            throw (0, _util.createError)({
                operationName: "Receiver._handleSenderRestartIce",
                context: this._context,
                channel: this.localPerson.channel,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "wrong signalingState"
                },
                payload: {
                    signalingState: this.pc.signalingState
                },
                path: log.prefix
            });
        }
        this._setConnectionState("reconnecting");
        await this.sendAnswer(sdp);
        await this.resolveCandidates();
        if (this.pc.connectionState === "connected") this._setConnectionState("connected");
    }
    async sendAnswer(sdp) {
        this._log.debug(`[receiver] start: sendAnswer`);
        await this.pc.setRemoteDescription(sdp);
        const answer = await this.pc.createAnswer();
        if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
            rtcPeerConnectionId: this.rtcPeerConnectionId,
            type: "answer",
            data: {
                answer: JSON.stringify(answer)
            },
            createdAt: Date.now()
        });
        const offerObject = _sdpTransform.parse(this.pc.remoteDescription.sdp);
        const answerObject = _sdpTransform.parse(answer.sdp);
        // fmtpの一部の設定(stereo)はremote側でも設定しないと効果を発揮しない
        offerObject.media.forEach((offerMedia, i)=>{
            const answerMedia = answerObject.media[i];
            answerMedia.fmtp = (0, _common.deepCopy)(answerMedia.fmtp).map((answerFmtp)=>{
                const offerFmtp = offerMedia.fmtp.find((f)=>f.payload === answerFmtp.payload);
                if (offerFmtp) return offerFmtp;
                return answerFmtp;
            });
        });
        const munged = _sdpTransform.write(answerObject);
        await this.pc.setLocalDescription({
            type: "answer",
            sdp: munged
        });
        const message = {
            kind: "receiverAnswerMessage",
            payload: {
                sdp: this.pc.localDescription
            }
        };
        await this.signaling.send(this.endpoint, message).catch((e)=>this._log.error("failed to send answer", e, {
                localPersonId: this.localPerson.id,
                endpointId: this.endpoint.id
            }));
        this._log.debug(`[receiver] end: sendAnswer`);
    }
    get subscriptions() {
        return this._subscriptions;
    }
}

},{"@skyway-sdk/common":"3hyrG","sdp-transform":"8vPQN","uuid":"bmRfK","../../../../errors":"gDbIj","../../../../media/stream/remote/factory":"ezfKU","../../../../util":"ey5Lv","../util":"5vybP","./datachannel":"6MzFO","./peer":"8RxiR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ezfKU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createRemoteStream", ()=>createRemoteStream);
var _common = require("@skyway-sdk/common");
var _errors = require("../../../errors");
var _util = require("../../../util");
var _audio = require("./audio");
var _data = require("./data");
var _video = require("./video");
const log = new (0, _common.Logger)("packages/core/src/media/stream/remote/factory.ts");
const createRemoteStream = (id, media, codec)=>{
    if (media instanceof RTCDataChannel) {
        const stream = new (0, _data.RemoteDataStream)(id, media);
        stream.codec = codec;
        return stream;
    } else {
        if (media.kind === "audio") {
            const stream = new (0, _audio.RemoteAudioStream)(id, media);
            stream.codec = codec;
            return stream;
        } else if (media.kind === "video") {
            const stream = new (0, _video.RemoteVideoStream)(id, media);
            stream.codec = codec;
            return stream;
        }
    }
    throw (0, _util.createError)({
        operationName: "createRemoteStream",
        path: log.prefix,
        info: {
            ...(0, _errors.errors).invalidArgumentValue,
            detail: "invalid stream type"
        }
    });
};

},{"@skyway-sdk/common":"3hyrG","../../../errors":"gDbIj","../../../util":"ey5Lv","./audio":"8TpY5","./data":"8kcOV","./video":"bjaWL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8TpY5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RemoteAudioStream", ()=>RemoteAudioStream);
var _media = require("./media");
class RemoteAudioStream extends (0, _media.RemoteMediaStreamBase) {
    /**@internal */ constructor(id, track){
        super(id, "audio", track);
        this.track = track;
        this.contentType = "audio";
    }
}

},{"./media":"llk9G","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llk9G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RemoteMediaStreamBase", ()=>RemoteMediaStreamBase);
var _base = require("../base");
var _base1 = require("./base");
class RemoteMediaStreamBase extends (0, _base1.RemoteStreamBase) {
    constructor(id, contentType, track){
        super(id, contentType);
        this.id = id;
        this.contentType = contentType;
        this.track = track;
    }
    get isEnabled() {
        return this.track.enabled;
    }
    /**@internal */ setIsEnabled(b) {
        this.track.enabled = b;
    }
    /**
   * @description [english] Attach the stream to the element.
   * @description [japanese] streamをelementに適用する.
   */ attach(element) {
        this._element = element;
        (0, _base.attachElement)(element, this.track);
    }
    /**
   * @description [english] Detach the stream from the element.
   * @description [japanese] elementからstreamを取り除く.
   */ detach() {
        if (this._element) {
            (0, _base.detachElement)(this._element, this.track);
            this._element = undefined;
        }
    }
}

},{"../base":"6o4hs","./base":"jN2dr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jN2dr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RemoteStreamBase", ()=>RemoteStreamBase);
var _common = require("@skyway-sdk/common");
class RemoteStreamBase {
    /**@internal */ constructor(id, contentType){
        this.id = id;
        this.contentType = contentType;
        this.side = "remote";
        this.onConnectionStateChanged = new (0, _common.Event)();
        this._onConnectionStateChanged = new (0, _common.Event)();
        this._connectionState = "new";
        this./**@internal */ _getTransport = ()=>undefined;
        this.getStats = ()=>{
            return this._getStats();
        };
        this./**@internal */ _getStats = async ()=>[];
        this._onConnectionStateChanged.pipe(this.onConnectionStateChanged);
    }
    /**@internal */ _setConnectionState(state) {
        if (this._connectionState === state) return;
        this._connectionState = state;
        this._onConnectionStateChanged.emit(state);
    }
    /**
   * @deprecated
   * @use Subscription.getRTCPeerConnection
   */ getRTCPeerConnection() {
        return this._getRTCPeerConnection();
    }
    /**@internal */ _getRTCPeerConnection() {
        return this._getTransport()?.rtcPeerConnection;
    }
    /**
   * @deprecated
   * @use Subscription.getConnectionState
   */ getConnectionState() {
        return this._getConnectionState();
    }
    /**@internal */ _getConnectionState() {
        return this._connectionState;
    }
    /**@internal */ toJSON() {
        return {
            contentType: this.contentType,
            id: this.id,
            codec: this.codec,
            side: this.side
        };
    }
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8kcOV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RemoteDataStream", ()=>RemoteDataStream);
var _common = require("@skyway-sdk/common");
var _data = require("../local/data");
var _base = require("./base");
class RemoteDataStream extends (0, _base.RemoteStreamBase) {
    /**@internal */ constructor(id, _datachannel){
        super(id, "data");
        this._datachannel = _datachannel;
        this._isEnabled = true;
        this.contentType = "data";
        this.onData = new (0, _common.Event)();
        _datachannel.onmessage = ({ data  })=>{
            if (!this.isEnabled) return;
            if (typeof data === "string" && data.includes((0, _data.objectFlag))) data = JSON.parse(data.slice((0, _data.objectFlag).length));
            this.onData.emit(data);
        };
    }
    /**@internal */ get isEnabled() {
        return this._isEnabled;
    }
    /**@internal */ setIsEnabled(b) {
        this._isEnabled = b;
    }
}

},{"@skyway-sdk/common":"3hyrG","../local/data":"T39q0","./base":"jN2dr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bjaWL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RemoteVideoStream", ()=>RemoteVideoStream);
var _media = require("./media");
class RemoteVideoStream extends (0, _media.RemoteMediaStreamBase) {
    /**@internal */ constructor(id, track){
        super(id, "video", track);
        this.track = track;
        this.contentType = "video";
    }
}

},{"./media":"llk9G","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5vybP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setEncodingParams", ()=>setEncodingParams);
parcelHelpers.export(exports, "isSafari", ()=>isSafari);
/**@internal */ parcelHelpers.export(exports, "convertConnectionState", ()=>convertConnectionState);
parcelHelpers.export(exports, "statsToJson", ()=>statsToJson);
var _common = require("@skyway-sdk/common");
var _util = require("../../../util");
const log = new (0, _common.Logger)("packages/core/src/plugin/internal/person/util.ts");
const setEncodingParams = async (sender, newEncodings)=>{
    const info = log.createBlock({
        label: "setEncodingParams"
    });
    const params = sender.getParameters();
    info.debug("getParameters", {
        params,
        newEncodings
    });
    if (params.encodings == undefined) params.encodings = [];
    params.encodings = newEncodings.map((encoding, i)=>({
            ...params.encodings[i] || {},
            ...encoding
        }));
    await sender.setParameters(params);
};
const isSafari = ()=>(0, _util.detectDevice)() === "Safari12" || (0, _util.detectDevice)() === "Safari11";
function convertConnectionState(state) {
    switch(state){
        case "closed":
        case "disconnected":
        case "failed":
            return "disconnected";
        case "connected":
            return "connected";
        case "connecting":
            return "connecting";
        case "new":
            return "new";
        case "reconnecting":
            return "reconnecting";
    }
}
const statsToJson = (report)=>{
    const stats = [];
    report.forEach((stat)=>{
        stats.push(JSON.parse(JSON.stringify(stat)));
    });
    return stats;
};

},{"@skyway-sdk/common":"3hyrG","../../../util":"ey5Lv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6MzFO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DataChannelNegotiationLabel", ()=>DataChannelNegotiationLabel);
class DataChannelNegotiationLabel {
    constructor(publicationId, streamId){
        this.publicationId = publicationId;
        this.streamId = streamId;
    }
    static fromLabel(label) {
        const { p , s  } = JSON.parse(label);
        return new DataChannelNegotiationLabel(p, s);
    }
    toLabel() {
        return JSON.stringify({
            p: this.publicationId,
            s: this.streamId
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8RxiR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Peer", ()=>Peer);
var _common = require("@skyway-sdk/common");
var _token = require("@skyway-sdk/token");
var _errors = require("../../../../errors");
var _util = require("../../../../util");
var _util1 = require("../util");
const log = new (0, _common.Logger)("packages/core/src/plugin/internal/person/connection/peer.ts");
class Peer {
    constructor(_context, _iceManager, signaling, analytics, localPerson, endpoint, role){
        this._context = _context;
        this._iceManager = _iceManager;
        this.signaling = signaling;
        this.analytics = analytics;
        this.localPerson = localPerson;
        this.endpoint = endpoint;
        this.role = role;
        this._pendingCandidates = [];
        this.pc = new RTCPeerConnection({
            ...this._context.config.rtcConfig,
            iceTransportPolicy: this._context.config.rtcConfig.turnPolicy === "turnOnly" ? "relay" : undefined,
            iceServers: this._iceManager.iceServers
        });
        this.onSignalingStateChanged = new (0, _common.Event)();
        this.onPeerConnectionStateChanged = new (0, _common.Event)();
        this.onDisconnect = new (0, _common.Event)();
        this.connected = false;
        this.disconnected = false;
        this.rtcPeerConnectionId = (0, _token.uuidV4)();
        this._onICECandidate = async (ev)=>{
            if (ev.candidate == null || // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore firefox
            ev.candidate === "" || this.pc.connectionState === "closed") return;
            const message = {
                kind: "iceCandidateMessage",
                payload: {
                    candidate: ev.candidate,
                    role: this.role
                }
            };
            log.debug("[start] send candidate", {
                message,
                localPerson: this.localPerson
            });
            if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                rtcPeerConnectionId: this.rtcPeerConnectionId,
                type: "iceCandidate",
                data: {
                    candidate: JSON.stringify(ev.candidate)
                },
                createdAt: Date.now()
            });
            try {
                await this.signaling.send(this.endpoint, message);
                log.debug(`[end] send candidate`, {
                    message,
                    localPerson: this.localPerson
                });
            } catch (error) {
                log.warn(`[failed] send candidate`, (0, _util.createWarnPayload)({
                    operationName: "Peer._onICECandidate",
                    channel: this.localPerson.channel,
                    detail: "[failed] send candidate",
                    payload: {
                        message
                    }
                }), error);
            }
        };
        this._onICECandidateError = async (ev)=>{
            if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                rtcPeerConnectionId: this.rtcPeerConnectionId,
                type: "iceCandidateError",
                data: {
                    event: JSON.stringify(ev)
                },
                createdAt: Date.now()
            });
        };
        this._onIceGatheringStateChange = async (ev)=>{
            if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) {
                const state = this.pc.iceGatheringState;
                this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                    rtcPeerConnectionId: this.rtcPeerConnectionId,
                    type: "iceGatheringStateChange",
                    data: {
                        event: state
                    },
                    createdAt: Date.now()
                });
            }
        };
        this._onConnectionStateChange = async ()=>{
            const state = this.pc.connectionState;
            if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                rtcPeerConnectionId: this.rtcPeerConnectionId,
                type: "connectionStateChange",
                data: {
                    connectionState: state
                },
                createdAt: Date.now()
            });
            switch(state){
                case "connected":
                    this.connected = true;
                    this._pendingCandidates = [];
                    break;
            }
            this.onPeerConnectionStateChanged.emit(this.pc.connectionState);
        };
        this._onIceConnectionStateChange = async ()=>{
            if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) {
                const state = this.pc.iceConnectionState;
                this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                    rtcPeerConnectionId: this.rtcPeerConnectionId,
                    type: "iceConnectionStateChange",
                    data: {
                        iceConnectionState: state
                    },
                    createdAt: Date.now()
                });
            }
        };
        this._onSignalingStateChange = async ()=>{
            if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) {
                const state = this.pc.signalingState;
                this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                    rtcPeerConnectionId: this.rtcPeerConnectionId,
                    type: "signalingStateChange",
                    data: {
                        signalingState: state
                    },
                    createdAt: Date.now()
                });
            }
        };
        this.waitForSignalingState = async (state, /**ms */ timeout = 10000)=>{
            if (this.pc.signalingState === state) return;
            await this.onSignalingStateChanged.watch(()=>this.pc.signalingState === state, timeout).catch((err)=>{
                throw (0, _util.createError)({
                    operationName: "Peer.waitForSignalingState",
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "waitForSignalingState timeout"
                    },
                    path: log.prefix,
                    context: this._context,
                    channel: this.localPerson.channel,
                    error: err
                });
            });
        };
        this.waitForConnectionState = async (state, /**ms */ timeout = 10000)=>{
            if (state === this.pc.connectionState) return;
            await this.onPeerConnectionStateChanged.watch(()=>state === this.pc.connectionState, timeout).catch((err)=>{
                throw (0, _util.createError)({
                    operationName: "Peer.waitForConnectionState",
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "waitForConnectionState timeout"
                    },
                    path: log.prefix,
                    context: this._context,
                    channel: this.localPerson.channel,
                    error: err
                });
            });
        };
        this.waitForStats = async ({ track , cb , interval , timeout , logging  })=>{
            interval ??= 100;
            timeout ??= 10000;
            for(let elapsed = 0;; elapsed += interval){
                if (elapsed >= timeout) throw (0, _util.createError)({
                    operationName: "Peer.waitForStats",
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "waitForStats timeout"
                    },
                    path: log.prefix,
                    context: this._context,
                    channel: this.localPerson.channel
                });
                const report = await this.pc.getStats(track);
                const stats = (0, _util1.statsToJson)(report);
                if (logging) log.debug("Peer.waitForStats", stats);
                if (cb(stats)) break;
                await new Promise((r)=>setTimeout(r, interval));
            }
        };
        log.debug("peerConfig", this.pc.getConfiguration());
        this.setPeerConnectionListener();
        // suppress firefox [RTCPeerConnection is gone] Exception
        const peerIdentity = this.pc?.peerIdentity;
        if (peerIdentity) peerIdentity.catch((err)=>{
            log.debug("firefox peerIdentity", err);
        });
    }
    setPeerConnectionListener() {
        this.pc.onicecandidate = this._onICECandidate;
        this.pc.onicecandidateerror = this._onICECandidateError;
        this.pc.onicegatheringstatechange = this._onIceGatheringStateChange;
        this.pc.onconnectionstatechange = this._onConnectionStateChange;
        this.pc.oniceconnectionstatechange = this._onIceConnectionStateChange;
        this.pc.onsignalingstatechange = ()=>{
            this._onSignalingStateChange();
            this.onSignalingStateChanged.emit(this.pc.signalingState);
        };
    }
    unSetPeerConnectionListener() {
        this.pc.onicecandidate = null;
        this.pc.onicecandidateerror = null;
        this.pc.onicegatheringstatechange = null;
        this.pc.onconnectionstatechange = null;
        this.pc.oniceconnectionstatechange = null;
        this.pc.onsignalingstatechange = null;
    }
    async handleCandidate(candidate) {
        this._pendingCandidates.push(candidate);
        if (this.pc.remoteDescription) await this.resolveCandidates();
    }
    async resolveCandidates() {
        const candidates = [
            ...this._pendingCandidates
        ];
        this._pendingCandidates = [];
        log.debug("addIceCandidates", candidates);
        await Promise.all(candidates.map((candidate)=>{
            if (this.pc.signalingState === "closed") return;
            this.pc.addIceCandidate(candidate).catch((err)=>{
                log.warn("[failed] add ice candidate", (0, _util.createWarnPayload)({
                    operationName: "Peer.resolveCandidates",
                    channel: this.localPerson.channel,
                    detail: "[failed] send candidate",
                    payload: {
                        endpointId: this.endpoint.id
                    }
                }), err);
            });
        }));
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/token":"1nlc7","../../../../errors":"gDbIj","../../../../util":"ey5Lv","../util":"5vybP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"81DLa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Sender", ()=>Sender);
parcelHelpers.export(exports, "applyCodecCapabilities", ()=>applyCodecCapabilities);
var _common = require("@skyway-sdk/common");
var _isEqual = require("lodash/isEqual");
var _isEqualDefault = parcelHelpers.interopDefault(_isEqual);
var _sdpTransform = require("sdp-transform");
var _uuid = require("uuid");
var _errors = require("../../../../errors");
var _util = require("../../../../util");
var _util1 = require("../util");
var _datachannel = require("./datachannel");
var _peer = require("./peer");
const log = new (0, _common.Logger)("packages/core/src/plugin/internal/person/connection/sender.ts");
class Sender extends (0, _peer.Peer) {
    id = (0, _uuid.v4)();
    onConnectionStateChanged = new (0, _common.Event)();
    publications = {};
    transceivers = {};
    datachannels = {};
    _pendingPublications = [];
    _isNegotiating = false;
    promiseQueue = new (0, _common.PromiseQueue)();
    _disposer = new (0, _common.EventDisposer)();
    _ms = new MediaStream();
    _backoffIceRestarted = new (0, _common.BackOff)({
        times: 8,
        interval: 100,
        jitter: 100
    });
    _connectionState = "new";
    _log = log.createBlock({
        localPersonId: this.localPerson.id,
        id: this.id
    });
    _unsubscribeStreamEnableChange = {};
    _cleanupStreamCallbacks = {};
    constructor(context, iceManager, signaling, analytics, localPerson, endpoint){
        super(context, iceManager, signaling, analytics, localPerson, endpoint, "sender");
        this._log.debug("spawned");
        this.signaling.onMessage.add(async ({ src , data  })=>{
            if (!(src.id === endpoint.id && src.name === endpoint.name)) return;
            const message = data;
            switch(message.kind){
                case "receiverAnswerMessage":
                    this.promiseQueue.push(()=>this._handleReceiverAnswer(message.payload)).catch((err)=>this._log.error("handle receiverAnswerMessage", {
                            localPersonId: this.localPerson.id,
                            endpointId: this.endpoint.id,
                            err
                        }));
                    break;
                case "iceCandidateMessage":
                    {
                        const { role , candidate  } = message.payload;
                        if (role === "receiver") await this.handleCandidate(candidate);
                    }
                    break;
            }
        }).disposer(this._disposer);
        this.onPeerConnectionStateChanged.add(async (state)=>{
            try {
                log.debug("onPeerConnectionStateChanged", {
                    state
                });
                switch(state){
                    case "disconnected":
                    case "failed":
                        {
                            const e = await this.waitForConnectionState("connected", context.config.rtcConfig.iceDisconnectBufferTimeout).catch((e)=>e);
                            if (e && this._connectionState !== "reconnecting") await this.restartIce();
                        }
                        break;
                    case "connecting":
                    case "connected":
                        this._setConnectionState(state);
                        break;
                    case "closed":
                        this._setConnectionState("disconnected");
                        break;
                }
            } catch (error) {
                log.error("onPeerConnectionStateChanged", error, this.id);
            }
        }).disposer(this._disposer);
    }
    _setConnectionState(state) {
        if (this._connectionState === state) return;
        this._log.debug("onConnectionStateChanged", this.id, this._connectionState, state);
        this._connectionState = state;
        this.onConnectionStateChanged.emit(state);
    }
    /**@throws */ restartIce = async ()=>{
        if (this._backoffIceRestarted.exceeded) {
            this._log.error((0, _util.createError)({
                operationName: "Sender.restartIce",
                context: this._context,
                channel: this.localPerson.channel,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "restartIce limit exceeded"
                },
                path: log.prefix
            }));
            this._setConnectionState("disconnected");
            return;
        }
        this._log.warn("[start] restartIce", (0, _util.createWarnPayload)({
            operationName: "Sender.restartIce",
            detail: "start restartIce",
            channel: this.localPerson.channel,
            payload: {
                count: this._backoffIceRestarted.count
            }
        }));
        const checkNeedEnd = ()=>{
            if (this.endpoint.state === "left") {
                this._log.warn("endpointMemberLeft", (0, _util.createWarnPayload)({
                    operationName: "restartIce",
                    detail: "endpointMemberLeft",
                    channel: this.localPerson.channel,
                    payload: {
                        endpointId: this.endpoint.id
                    }
                }));
                this._setConnectionState("disconnected");
                return true;
            }
            if (this.pc.connectionState === "connected") {
                this._log.warn("[end] restartIce", (0, _util.createWarnPayload)({
                    operationName: "restartIce",
                    detail: "reconnected",
                    channel: this.localPerson.channel,
                    payload: {
                        count: this._backoffIceRestarted.count
                    }
                }));
                this._backoffIceRestarted.reset();
                this._setConnectionState("connected");
                if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                    rtcPeerConnectionId: this.id,
                    type: "restartIce",
                    data: undefined,
                    createdAt: Date.now()
                });
                return true;
            }
        };
        this._setConnectionState("reconnecting");
        await this._backoffIceRestarted.wait();
        if (checkNeedEnd()) return;
        let e = await this._iceManager.updateIceParams().catch((e)=>e);
        if (e) {
            this._log.warn("[failed] restartIce", (0, _util.createWarnPayload)({
                operationName: "restartIce",
                detail: "update IceParams failed",
                channel: this.localPerson.channel,
                payload: {
                    count: this._backoffIceRestarted.count
                }
            }), e);
            await this.restartIce();
            return;
        }
        if (this.pc.setConfiguration) {
            this.pc.setConfiguration({
                ...this.pc.getConfiguration(),
                iceServers: this._iceManager.iceServers
            });
            this._log.debug("<restartIce> setConfiguration", {
                iceServers: this._iceManager.iceServers
            });
        }
        if (checkNeedEnd()) return;
        if (this.signaling.connectionState !== "connected") {
            this._log.warn("<restartIce> reconnect signaling service", (0, _util.createWarnPayload)({
                operationName: "restartIce",
                detail: "reconnect signaling service",
                channel: this.localPerson.channel,
                payload: {
                    count: this._backoffIceRestarted.count
                }
            }));
            e = await this.signaling.onConnectionStateChanged.watch((s)=>s === "connected", 10000).catch((e)=>e).then(()=>{});
            if (e instanceof (0, _common.SkyWayError)) {
                await this.restartIce();
                return;
            }
            if (checkNeedEnd()) return;
        }
        const offer = await this.pc.createOffer({
            iceRestart: true
        });
        if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
            rtcPeerConnectionId: this.rtcPeerConnectionId,
            type: "offer",
            data: {
                offer: JSON.stringify(offer)
            },
            createdAt: Date.now()
        });
        await this.pc.setLocalDescription(offer);
        const message = {
            kind: "senderRestartIceMessage",
            payload: {
                sdp: this.pc.localDescription
            }
        };
        e = await this.signaling.send(this.endpoint, message, 10000).catch((e)=>e);
        if (e) {
            this._log.warn("<restartIce> [failed]", (0, _util.createWarnPayload)({
                operationName: "restartIce",
                detail: "timeout send signaling message",
                channel: this.localPerson.channel,
                payload: {
                    count: this._backoffIceRestarted.count
                }
            }), e);
            await this.restartIce();
            return;
        }
        e = await this.waitForConnectionState("connected", this._context.config.rtcConfig.iceDisconnectBufferTimeout).catch((e)=>e);
        if (!e) {
            if (checkNeedEnd()) return;
        }
        await this.restartIce();
    };
    get hasMedia() {
        const count = Object.keys(this.publications).length;
        this._log.debug("hasMedia", {
            count
        });
        if (count > 0) return true;
        return false;
    }
    _getMid(publication, sdpObject) {
        if (publication.contentType === "data") {
            const media = sdpObject.media.find((m)=>m.type === "application");
            if (media?.mid == undefined) throw (0, _util.createError)({
                operationName: "Sender._getMid",
                info: {
                    ...(0, _errors.errors).missingProperty,
                    detail: "datachannel mid undefined"
                },
                path: log.prefix,
                context: this._context,
                channel: this.localPerson.channel
            });
            return media.mid.toString();
        } else {
            const transceiver = this.transceivers[publication.id];
            const mid = transceiver.mid;
            if (mid == undefined) throw (0, _util.createError)({
                operationName: "Sender._getMid",
                info: {
                    ...(0, _errors.errors).missingProperty,
                    detail: "media mid undefined"
                },
                path: log.prefix,
                context: this._context,
                channel: this.localPerson.channel
            });
            return mid.toString();
        }
    }
    _listenStreamEnableChange(stream, publicationId) {
        if (this._unsubscribeStreamEnableChange[publicationId]) this._unsubscribeStreamEnableChange[publicationId]();
        const { removeListener  } = stream._onEnableChanged.add(async (track)=>{
            await this._replaceTrack(publicationId, track).catch((e)=>{
                log.warn((0, _util.createWarnPayload)({
                    member: this.localPerson,
                    detail: "_replaceTrack failed",
                    operationName: "Sender._listenStreamEnableChange",
                    payload: e
                }));
            });
        });
        this._unsubscribeStreamEnableChange[publicationId] = removeListener;
    }
    /**@throws {@link SkyWayError} */ async add(publication) {
        if (this._isNegotiating || this.pc.signalingState !== "stable") {
            this._pendingPublications.push(publication);
            this._log.debug("<add> isNegotiating", {
                publication,
                isNegotiating: this._isNegotiating,
                signalingState: this.pc.signalingState,
                pendingPublications: this._pendingPublications.length
            });
            return;
        }
        this._isNegotiating = true;
        this._log.debug("<add> add publication", {
            publication
        });
        this.publications[publication.id] = publication;
        const stream = publication.stream;
        if (!stream) throw (0, _util.createError)({
            operationName: "Sender.add",
            info: {
                ...(0, _errors.errors).missingProperty,
                detail: "<add> stream not found"
            },
            path: log.prefix,
            context: this._context,
            channel: this.localPerson.channel
        });
        this._cleanupStreamCallbacks[stream.id] = this._setupTransportAccessForStream(stream);
        if (stream.contentType === "data") {
            const dc = this.pc.createDataChannel(new (0, _datachannel.DataChannelNegotiationLabel)(publication.id, stream.id).toLabel(), stream.options);
            stream._onWriteData.add((data)=>{
                if (dc.readyState === "open") dc.send(data);
            }).disposer(this._disposer);
            this.datachannels[publication.id] = dc;
        } else {
            publication._onReplaceStream.add(async ({ newStream , oldStream  })=>{
                newStream._replacingTrack = true;
                this._listenStreamEnableChange(newStream, publication.id);
                if (this._cleanupStreamCallbacks[oldStream.id]) this._cleanupStreamCallbacks[oldStream.id]();
                this._cleanupStreamCallbacks[newStream.id] = this._setupTransportAccessForStream(newStream);
                await this._replaceTrack(publication.id, newStream.track);
                newStream._replacingTrack = false;
                newStream._onReplacingTrackDone.emit();
            }).disposer(this._disposer);
            this._listenStreamEnableChange(stream, publication.id);
            const transceiver = this.pc.addTransceiver(stream.track, {
                direction: "sendonly",
                streams: [
                    this._ms
                ]
            });
            publication._onEncodingsChanged.add(async (encodings)=>{
                await (0, _util1.setEncodingParams)(transceiver.sender, encodings).catch((e)=>{
                    this._log.error("_onEncodingsChanged failed", e);
                });
            }).disposer(this._disposer);
            this.transceivers[publication.id] = transceiver;
        }
        const offer = await this.pc.createOffer().catch((err)=>{
            throw (0, _util.createError)({
                operationName: "Sender.add",
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "can't create offer"
                },
                path: log.prefix,
                context: this._context,
                channel: this.localPerson.channel,
                error: err
            });
        });
        if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
            rtcPeerConnectionId: this.rtcPeerConnectionId,
            type: "offer",
            data: {
                offer: JSON.stringify(offer)
            },
            createdAt: Date.now()
        });
        await this.pc.setLocalDescription(offer);
        const sdpObject = _sdpTransform.parse(this.pc.localDescription.sdp);
        this._log.debug("<add> create offer base", sdpObject);
        const mid = this._getMid(publication, sdpObject);
        if (publication.contentType !== "data") {
            applyCodecCapabilities(publication.codecCapabilities ?? [], mid, sdpObject);
            const offerSdp = _sdpTransform.write(sdpObject);
            await this.pc.setLocalDescription({
                type: "offer",
                sdp: offerSdp
            });
            this._log.debug("<add> create offer", this.pc.localDescription);
            if (publication.encodings?.length > 0) {
                if ((0, _util1.isSafari)()) this._safariSetupEncoding(publication);
                else {
                    const transceiver = this.transceivers[publication.id];
                    await (0, _util1.setEncodingParams)(transceiver.sender, [
                        publication.encodings[0]
                    ]);
                }
            }
        }
        const message = {
            kind: "senderProduceMessage",
            payload: {
                sdp: this.pc.localDescription,
                publicationId: publication.id,
                info: {
                    publicationId: publication.id,
                    streamId: stream.id,
                    mid
                }
            }
        };
        this._log.debug("[start] send message", message);
        await this.signaling.send(this.endpoint, message).catch((error)=>{
            this._log.error("[failed] send message :", error, {
                localPersonId: this.localPerson.id,
                endpointId: this.endpoint.id
            });
            throw error;
        });
        this._log.debug("[end] send message", message);
    }
    _setupTransportAccessForStream(stream) {
        stream._getTransportCallbacks[this.endpoint.id] = ()=>({
                rtcPeerConnection: this.pc,
                connectionState: this._connectionState
            });
        stream._getStatsCallbacks[this.endpoint.id] = async ()=>{
            if (stream.contentType === "data") {
                const stats = await this.pc.getStats();
                const arr = (0, _util.statsToArray)(stats);
                return arr;
            }
            if (stream._replacingTrack) await stream._onReplacingTrackDone.asPromise(200);
            const stats = await this.pc.getStats(stream.track);
            const arr = (0, _util.statsToArray)(stats);
            return arr;
        };
        // replaceStream時に古いstreamに紐づくcallbackを削除するため、戻り値としてcallback削除用の関数を返し、replaceStream時に呼び出す
        const cleanupCallbacks = ()=>{
            delete stream._getTransportCallbacks[this.endpoint.id];
            delete stream._getStatsCallbacks[this.endpoint.id];
        };
        this._disposer.push(()=>{
            cleanupCallbacks();
        });
        this.onConnectionStateChanged.add((state)=>{
            stream._setConnectionState(this.endpoint, state);
            if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
                rtcPeerConnectionId: this.rtcPeerConnectionId,
                type: "skywayConnectionStateChange",
                data: {
                    skywayConnectionState: state
                },
                createdAt: Date.now()
            });
        }).disposer(this._disposer);
        return cleanupCallbacks;
    }
    /**@throws {SkyWayError} */ async remove(publicationId) {
        const publication = this.publications[publicationId];
        if (!publication) {
            this._log.warn("<remove> publication not found", (0, _util.createWarnPayload)({
                operationName: "Sender.remove",
                detail: "publication already removed",
                channel: this.localPerson.channel,
                payload: {
                    publicationId
                }
            }));
            return;
        }
        // 対向のConnectionがcloseされた際にanswerが帰ってこなくなり、
        // _isNegotiatingが永久にfalseにならなくなる。
        // この時点でpublicationを削除しないと、このConnectionのcloseIfNeedが
        // 正常に動作しなくなる
        delete this.publications[publicationId];
        if (this._isNegotiating || this.pc.signalingState !== "stable") {
            this._pendingPublications.push(publicationId);
            this._log.debug("<remove> isNegotiating", {
                publicationId,
                _isNegotiating: this._isNegotiating,
                signalingState: this.pc.signalingState
            });
            return;
        }
        this._isNegotiating = true;
        this._log.debug("<remove> [start]", {
            publicationId
        });
        const stream = publication.stream;
        if (!stream) throw (0, _util.createError)({
            operationName: "Sender.remove",
            info: {
                ...(0, _errors.errors).missingProperty,
                detail: "<remove> publication not have stream"
            },
            path: log.prefix,
            context: this._context,
            channel: this.localPerson.channel,
            payload: {
                publication
            }
        });
        if (stream.contentType === "data") {
            const dc = this.datachannels[publicationId];
            dc.close();
            delete this.datachannels[publicationId];
        } else {
            const transceiver = this.transceivers[publicationId];
            transceiver.stop();
            delete this.transceivers[publicationId];
        }
        const offer = await this.pc.createOffer().catch((err)=>{
            throw (0, _util.createError)({
                operationName: "Sender.remove",
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "<remove> can't create offer"
                },
                path: log.prefix,
                context: this._context,
                channel: this.localPerson.channel,
                error: err
            });
        });
        if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendRtcPeerConnectionEventReport({
            rtcPeerConnectionId: this.rtcPeerConnectionId,
            type: "offer",
            data: {
                offer: JSON.stringify(offer)
            },
            createdAt: Date.now()
        });
        await this.pc.setLocalDescription(offer);
        const message = {
            kind: "senderUnproduceMessage",
            payload: {
                sdp: this.pc.localDescription,
                publicationId
            }
        };
        this._log.debug("<remove> send message", {
            message
        });
        await this.signaling.send(this.endpoint, message).catch((error)=>{
            this._log.error("<remove> in remote error :", error, {
                localPersonId: this.localPerson.id,
                endpointId: this.endpoint.id
            });
            throw error;
        });
        this._log.debug("<remove> [end]", {
            publicationId
        });
    }
    async _replaceTrack(publicationId, track) {
        const transceiver = this.transceivers[publicationId];
        if (!transceiver) {
            this._log.warn("can't replace track, transceiver not found", (0, _util.createWarnPayload)({
                operationName: "Sender._replaceTrack",
                detail: "transceiver already removed",
                channel: this.localPerson.channel,
                payload: {
                    publicationId
                }
            }));
            return;
        }
        await transceiver.sender.replaceTrack(track).catch((e)=>{
            throw (0, _util.createError)({
                operationName: "Sender._replaceTrack",
                context: this._context,
                info: (0, _errors.errors).internal,
                error: e,
                path: log.prefix,
                channel: this.localPerson.channel
            });
        });
    }
    async _handleReceiverAnswer({ sdp  }) {
        if (this.pc.signalingState === "closed") return;
        this._log.debug("<handleReceiverAnswer> [start]");
        await this.pc.setRemoteDescription(new RTCSessionDescription(sdp)).catch((err)=>{
            const error = (0, _util.createError)({
                operationName: "Sender._handleReceiverAnswer",
                context: this._context,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "failed to setRemoteDescription"
                },
                path: log.prefix,
                payload: {
                    sdp
                },
                channel: this.localPerson.channel,
                error: err
            });
            this._log.error(error);
            throw error;
        });
        this._log.debug("<handleReceiverAnswer> sRD");
        await this.resolveCandidates();
        this._log.debug("<handleReceiverAnswer> resolveCandidates");
        await this.waitForSignalingState("stable");
        this._log.debug("<handleReceiverAnswer> waitForSignalingState");
        this._isNegotiating = false;
        await this._resolvePendingSender();
        this._log.debug("<handleReceiverAnswer> _resolvePendingSender", this._pendingPublications.length);
        this._log.debug("<handleReceiverAnswer> [end]");
    }
    _safariSetupEncoding(publication) {
        // 映像の送信が始まる前にEncodeの設定をするとEncodeの設定の更新ができなくなる
        const transceiver = this.transceivers[publication.id];
        const stream = publication.stream;
        this.waitForStats({
            track: stream.track,
            cb: (stats)=>{
                const outbound = stats.find((s)=>s.id.includes("RTCOutboundRTP") || s.type.includes("outbound-rtp"));
                if (outbound?.keyFramesEncoded > 0) return true;
                return false;
            },
            interval: 10,
            timeout: this._context.config.rtcConfig.timeout
        }).then(()=>{
            log.debug("safari wait for stats resolved, setEncodingParams");
            (0, _util1.setEncodingParams)(transceiver.sender, [
                publication.encodings[0]
            ]).catch((e)=>{
                this._log.error("setEncodingParams failed", e);
            });
        }).catch((e)=>{
            this._log.error("waitForStats", e);
        });
    }
    /**@throws {@link SkyWayError} */ async _resolvePendingSender() {
        const publication = this._pendingPublications.shift();
        if (!publication) return;
        this._log.debug("resolve pending sender", {
            publication
        });
        if (typeof publication === "string") await this.remove(publication);
        else await this.add(publication);
    }
    close() {
        this._log.debug("closed");
        this.unSetPeerConnectionListener();
        Object.values(this._unsubscribeStreamEnableChange).forEach((f)=>f());
        this.pc.close();
        this._setConnectionState("disconnected");
        this._disposer.dispose();
    }
}
function applyCodecCapabilities(codecCapabilities, mid, sdpObject) {
    const media = sdpObject.media.find((m)=>m.mid?.toString() === mid);
    if (!media) throw (0, _util.createError)({
        operationName: "applyCodecCapabilities",
        info: {
            ...(0, _errors.errors).notFound,
            detail: "media not found"
        },
        path: log.prefix
    });
    // parametersをfmtp形式に変換
    codecCapabilities.forEach((cap)=>{
        if (cap.parameters) for (const [key, value] of Object.entries(cap.parameters ?? {})){
            if (value === false || !cap.parameters[key]) return;
            if (key === "usedtx" && value) cap.parameters[key] = 1;
        }
    });
    /**codec名とparametersの一致するものを探す */ const findCodecFromCodecCapability = (cap, rtp, fmtp)=>{
        const rtpList = rtp.map((r)=>({
                ...r,
                parameters: (0, _util.getParameters)(fmtp, r.payload)
            }));
        const codecName = mimeTypeToCodec(cap.mimeType);
        if (!codecName) return undefined;
        const matched = rtpList.find((r)=>{
            if (r.codec.toLowerCase() !== codecName.toLowerCase()) return false;
            if (Object.keys(cap.parameters ?? {}).length === 0) return true;
            // audioはブラウザが勝手にfmtp configを足してくるので厳密にマッチさせる必要がない
            if (mimeTypeToContentType(cap.mimeType) === "audio") return true;
            return (0, _isEqualDefault.default)(r.parameters, cap.parameters ?? {});
        }) ?? undefined;
        return matched;
    };
    const preferredCodecs = codecCapabilities.map((cap)=>findCodecFromCodecCapability(cap, media.rtp, media.fmtp)).filter((v)=>v != undefined);
    const sorted = [
        ...preferredCodecs,
        ...media.rtp.filter((rtp)=>!preferredCodecs.find((p)=>p.payload === rtp.payload))
    ];
    // apply codec fmtp
    for (const fmtp of media.fmtp){
        const payloadType = fmtp.payload;
        const targetCodecWithPayload = sorted.find((c)=>c.payload === payloadType);
        if (targetCodecWithPayload) {
            const targetCodecCapability = codecCapabilities.find((c)=>findCodecFromCodecCapability(c, [
                    targetCodecWithPayload
                ], media.fmtp));
            if (targetCodecCapability) {
                if (targetCodecCapability.parameters && Object.keys(targetCodecCapability.parameters).length > 0) {
                    // codecCapabilitiesのfmtpを適用する
                    fmtp.config = "";
                    Object.entries(targetCodecCapability.parameters).forEach(([key, value])=>{
                        if (value === false || fmtp.config.includes(key)) return;
                        if (fmtp.config.length > 0) fmtp.config += `;${key}=${value}`;
                        else fmtp.config = `${key}=${value}`;
                    });
                }
            }
        }
        // opusDtxはデフォルトで有効に設定する
        const opus = sorted.find((rtp)=>rtp.codec.toLowerCase() === "opus");
        const opusDtx = codecCapabilities.find((f)=>mimeTypeToCodec(f.mimeType).toLowerCase() === "opus")?.parameters?.usedtx;
        if (opus && opusDtx !== false && fmtp.payload === opus.payload && !fmtp.config.includes("usedtx")) {
            if (fmtp.config.length > 0) fmtp.config += ";usedtx=1";
            else fmtp.config = "usedtx=1";
        }
    }
    media.payloads = sorted.map((rtp)=>rtp.payload.toString()).join(" ");
}
const mimeTypeToCodec = (mimeType)=>mimeType.split("/")[1];
const mimeTypeToContentType = (mimeType)=>mimeType.split("/")[0];

},{"@skyway-sdk/common":"3hyrG","lodash/isEqual":"9XEia","sdp-transform":"8vPQN","uuid":"bmRfK","../../../../errors":"gDbIj","../../../../util":"ey5Lv","../util":"5vybP","./datachannel":"6MzFO","./peer":"8RxiR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9XEia":[function(require,module,exports) {
var baseIsEqual = require("c129e99aaeb648b6");
/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */ function isEqual(value, other) {
    return baseIsEqual(value, other);
}
module.exports = isEqual;

},{"c129e99aaeb648b6":"7i3qr"}],"7i3qr":[function(require,module,exports) {
var baseIsEqualDeep = require("c892113dfbadf51c"), isObjectLike = require("d7c1785a054483a5");
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */ function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) return true;
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
module.exports = baseIsEqual;

},{"c892113dfbadf51c":"6GoQ9","d7c1785a054483a5":"3BLi4"}],"6GoQ9":[function(require,module,exports) {
var Stack = require("c8cd00d733c916e8"), equalArrays = require("4ba2668215b337f7"), equalByTag = require("1ee52dab894d1361"), equalObjects = require("cb6473ab866287d"), getTag = require("4c97a96a3d74d4fb"), isArray = require("4e0fef28a6cd9b62"), isBuffer = require("a4fc62e2eefbfa91"), isTypedArray = require("c1acd42d9fa5dc01");
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) return false;
        objIsArr = true;
        objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
    }
    if (!isSameTag) return false;
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
module.exports = baseIsEqualDeep;

},{"c8cd00d733c916e8":"atP87","4ba2668215b337f7":"dQBwf","1ee52dab894d1361":"iqa6H","cb6473ab866287d":"klCEf","4c97a96a3d74d4fb":"cRPhM","4e0fef28a6cd9b62":"dZaTH","a4fc62e2eefbfa91":"cn85h","c1acd42d9fa5dc01":"6SVKk"}],"atP87":[function(require,module,exports) {
var ListCache = require("ef569aa5081cabf8"), stackClear = require("8141ac03dab2ca65"), stackDelete = require("b366f7a805771155"), stackGet = require("1ae19cd3248c2c82"), stackHas = require("7e87ac88fd7f709d"), stackSet = require("989461b04040946c");
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

},{"ef569aa5081cabf8":"3UZeo","8141ac03dab2ca65":"6CpyN","b366f7a805771155":"dGFb0","1ae19cd3248c2c82":"6zFUp","7e87ac88fd7f709d":"3VJUX","989461b04040946c":"ZfrYM"}],"3UZeo":[function(require,module,exports) {
var listCacheClear = require("705b6e63748683bc"), listCacheDelete = require("8933c3ff8033958e"), listCacheGet = require("80829004f7f06d9f"), listCacheHas = require("76c8627bde6933e"), listCacheSet = require("633f8257cdb3e069");
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

},{"705b6e63748683bc":"7AKQv","8933c3ff8033958e":"j2Z5O","80829004f7f06d9f":"6Zrrs","76c8627bde6933e":"i1CBK","633f8257cdb3e069":"2Rcur"}],"7AKQv":[function(require,module,exports) {
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
module.exports = listCacheClear;

},{}],"j2Z5O":[function(require,module,exports) {
var assocIndexOf = require("8a6a670cf7426caa");
/** Used for built-in method references. */ var arrayProto = Array.prototype;
/** Built-in value references. */ var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    --this.size;
    return true;
}
module.exports = listCacheDelete;

},{"8a6a670cf7426caa":"cRVsl"}],"cRVsl":[function(require,module,exports) {
var eq = require("fc3a25be283c8b42");
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
module.exports = assocIndexOf;

},{"fc3a25be283c8b42":"aVz5f"}],"aVz5f":[function(require,module,exports) {
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
module.exports = eq;

},{}],"6Zrrs":[function(require,module,exports) {
var assocIndexOf = require("39c9686f825c557a");
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
module.exports = listCacheGet;

},{"39c9686f825c557a":"cRVsl"}],"i1CBK":[function(require,module,exports) {
var assocIndexOf = require("8c8e4f34440cf331");
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
module.exports = listCacheHas;

},{"8c8e4f34440cf331":"cRVsl"}],"2Rcur":[function(require,module,exports) {
var assocIndexOf = require("54a3ef645e735cb2");
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else data[index][1] = value;
    return this;
}
module.exports = listCacheSet;

},{"54a3ef645e735cb2":"cRVsl"}],"6CpyN":[function(require,module,exports) {
var ListCache = require("a067aee3defbe1ec");
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
}
module.exports = stackClear;

},{"a067aee3defbe1ec":"3UZeo"}],"dGFb0":[function(require,module,exports) {
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
}
module.exports = stackDelete;

},{}],"6zFUp":[function(require,module,exports) {
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
module.exports = stackGet;

},{}],"3VJUX":[function(require,module,exports) {
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
module.exports = stackHas;

},{}],"ZfrYM":[function(require,module,exports) {
var ListCache = require("20e8f3a52299f18"), Map = require("c4589f38e98e1680"), MapCache = require("29cd30d81f65e226");
/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
module.exports = stackSet;

},{"20e8f3a52299f18":"3UZeo","c4589f38e98e1680":"8YjF4","29cd30d81f65e226":"664I1"}],"8YjF4":[function(require,module,exports) {
var getNative = require("26709b33bb0caf3"), root = require("966ad4a1b32d7c7d");
/* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map");
module.exports = Map;

},{"26709b33bb0caf3":"9PCIl","966ad4a1b32d7c7d":"dSYUs"}],"9PCIl":[function(require,module,exports) {
var baseIsNative = require("77c99e67e73f55d1"), getValue = require("c0db70c2e6fa4100");
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
module.exports = getNative;

},{"77c99e67e73f55d1":"2U9Pn","c0db70c2e6fa4100":"kKx5I"}],"2U9Pn":[function(require,module,exports) {
var isFunction = require("801e650ecc4de4ba"), isMasked = require("ee608e2e875ed84e"), isObject = require("6e0865389bfe5033"), toSource = require("22e4fb0dfc90711a");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
module.exports = baseIsNative;

},{"801e650ecc4de4ba":"cfti6","ee608e2e875ed84e":"cMDzi","6e0865389bfe5033":"cGhqJ","22e4fb0dfc90711a":"bYHc7"}],"cfti6":[function(require,module,exports) {
var baseGetTag = require("54956149f888d8ba"), isObject = require("fdcfdd5f517a770f");
/** `Object#toString` result references. */ var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!isObject(value)) return false;
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
module.exports = isFunction;

},{"54956149f888d8ba":"lOnbo","fdcfdd5f517a770f":"cGhqJ"}],"lOnbo":[function(require,module,exports) {
var Symbol = require("ea2cfcecd5d2c605"), getRawTag = require("1804bd67dc1f6a13"), objectToString = require("9f27d625f7ceb07e");
/** `Object#toString` result references. */ var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) return value === undefined ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
module.exports = baseGetTag;

},{"ea2cfcecd5d2c605":"7lsL9","1804bd67dc1f6a13":"995sO","9f27d625f7ceb07e":"bmE3g"}],"7lsL9":[function(require,module,exports) {
var root = require("1d7edcce7b2f8f9c");
/** Built-in value references. */ var Symbol = root.Symbol;
module.exports = Symbol;

},{"1d7edcce7b2f8f9c":"dSYUs"}],"dSYUs":[function(require,module,exports) {
var freeGlobal = require("7354d20494c398f");
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
module.exports = root;

},{"7354d20494c398f":"kAk32"}],"kAk32":[function(require,module,exports) {
/** Detect free variable `global` from Node.js. */ var global = arguments[3];
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
module.exports = freeGlobal;

},{}],"995sO":[function(require,module,exports) {
var Symbol = require("3f04c602101c9f29");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) value[symToStringTag] = tag;
        else delete value[symToStringTag];
    }
    return result;
}
module.exports = getRawTag;

},{"3f04c602101c9f29":"7lsL9"}],"bmE3g":[function(require,module,exports) {
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
module.exports = objectToString;

},{}],"cGhqJ":[function(require,module,exports) {
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
}
module.exports = isObject;

},{}],"cMDzi":[function(require,module,exports) {
var coreJsData = require("2afbbd1669c020fe");
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
module.exports = isMasked;

},{"2afbbd1669c020fe":"6gJwQ"}],"6gJwQ":[function(require,module,exports) {
var root = require("1a141a64fc04ca0a");
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
module.exports = coreJsData;

},{"1a141a64fc04ca0a":"dSYUs"}],"bYHc7":[function(require,module,exports) {
/** Used for built-in method references. */ var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
module.exports = toSource;

},{}],"kKx5I":[function(require,module,exports) {
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
module.exports = getValue;

},{}],"664I1":[function(require,module,exports) {
var mapCacheClear = require("98f6367593fb3397"), mapCacheDelete = require("5caf7ec89465835d"), mapCacheGet = require("88a66bfcdb4b116f"), mapCacheHas = require("6db0b52c1292008f"), mapCacheSet = require("67bed8fafa229ddc");
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

},{"98f6367593fb3397":"7kHs4","5caf7ec89465835d":"4ny9y","88a66bfcdb4b116f":"gVeFY","6db0b52c1292008f":"idSOY","67bed8fafa229ddc":"lXUJT"}],"7kHs4":[function(require,module,exports) {
var Hash = require("3fa885b6c0a704ea"), ListCache = require("c5826aec946e8981"), Map = require("a6880041cea34d21");
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
module.exports = mapCacheClear;

},{"3fa885b6c0a704ea":"jFMT5","c5826aec946e8981":"3UZeo","a6880041cea34d21":"8YjF4"}],"jFMT5":[function(require,module,exports) {
var hashClear = require("4a01f92edf61c08a"), hashDelete = require("8bea5a30368119d9"), hashGet = require("84655dd86c49f4d4"), hashHas = require("d15043918f2fbd7a"), hashSet = require("68fe42321d557c40");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

},{"4a01f92edf61c08a":"f2NRo","8bea5a30368119d9":"cCdgz","84655dd86c49f4d4":"eKqTO","d15043918f2fbd7a":"ghnqP","68fe42321d557c40":"6i99R"}],"f2NRo":[function(require,module,exports) {
var nativeCreate = require("f45969606ac879d1");
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
}
module.exports = hashClear;

},{"f45969606ac879d1":"6i8Uf"}],"6i8Uf":[function(require,module,exports) {
var getNative = require("b7b812b53bef128");
/* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, "create");
module.exports = nativeCreate;

},{"b7b812b53bef128":"9PCIl"}],"cCdgz":[function(require,module,exports) {
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
module.exports = hashDelete;

},{}],"eKqTO":[function(require,module,exports) {
var nativeCreate = require("dab31681e8490996");
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
module.exports = hashGet;

},{"dab31681e8490996":"6i8Uf"}],"ghnqP":[function(require,module,exports) {
var nativeCreate = require("12ee77b2189d1ce8");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
module.exports = hashHas;

},{"12ee77b2189d1ce8":"6i8Uf"}],"6i99R":[function(require,module,exports) {
var nativeCreate = require("d0b1d841f91b42a5");
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
module.exports = hashSet;

},{"d0b1d841f91b42a5":"6i8Uf"}],"4ny9y":[function(require,module,exports) {
var getMapData = require("6b0c1ea6635ca71c");
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
}
module.exports = mapCacheDelete;

},{"6b0c1ea6635ca71c":"aptgk"}],"aptgk":[function(require,module,exports) {
var isKeyable = require("ab3f363b297217fc");
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
module.exports = getMapData;

},{"ab3f363b297217fc":"icylN"}],"icylN":[function(require,module,exports) {
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
module.exports = isKeyable;

},{}],"gVeFY":[function(require,module,exports) {
var getMapData = require("b0c3df964ac7583a");
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
module.exports = mapCacheGet;

},{"b0c3df964ac7583a":"aptgk"}],"idSOY":[function(require,module,exports) {
var getMapData = require("c86e6816aca89507");
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
module.exports = mapCacheHas;

},{"c86e6816aca89507":"aptgk"}],"lXUJT":[function(require,module,exports) {
var getMapData = require("968d9577b66f3cec");
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
module.exports = mapCacheSet;

},{"968d9577b66f3cec":"aptgk"}],"dQBwf":[function(require,module,exports) {
var SetCache = require("58df756ff0a392fb"), arraySome = require("1b00641940791b57"), cacheHas = require("a2a588f54afcaa20");
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
    stack.set(array, other);
    stack.set(other, array);
    // Ignore non-index properties.
    while(++index < arrLength){
        var arrValue = array[index], othValue = other[index];
        if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        if (compared !== undefined) {
            if (compared) continue;
            result = false;
            break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
            if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
        }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
}
module.exports = equalArrays;

},{"58df756ff0a392fb":"1SXrY","1b00641940791b57":"aLDHW","a2a588f54afcaa20":"70cVb"}],"1SXrY":[function(require,module,exports) {
var MapCache = require("c533afeadcd0b825"), setCacheAdd = require("af8114d01b46f88a"), setCacheHas = require("a5a34ba2804ca9fb");
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while(++index < length)this.add(values[index]);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

},{"c533afeadcd0b825":"664I1","af8114d01b46f88a":"cZViu","a5a34ba2804ca9fb":"4zNID"}],"cZViu":[function(require,module,exports) {
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
module.exports = setCacheAdd;

},{}],"4zNID":[function(require,module,exports) {
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
module.exports = setCacheHas;

},{}],"aLDHW":[function(require,module,exports) {
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */ function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (predicate(array[index], index, array)) return true;
    }
    return false;
}
module.exports = arraySome;

},{}],"70cVb":[function(require,module,exports) {
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
module.exports = cacheHas;

},{}],"iqa6H":[function(require,module,exports) {
var Symbol = require("1419f6c4bcc38058"), Uint8Array = require("efa3d7e61243e595"), eq = require("cb54379d65ba06cb"), equalArrays = require("80a9332e260a6db2"), mapToArray = require("91f1976d625a36cb"), setToArray = require("40f4a93eab936fdd");
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */ var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch(tag){
        case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
            object = object.buffer;
            other = other.buffer;
        case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) return false;
            return true;
        case boolTag:
        case dateTag:
        case numberTag:
            // Coerce booleans to `1` or `0` and dates to milliseconds.
            // Invalid dates are coerced to `NaN`.
            return eq(+object, +other);
        case errorTag:
            return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
            // Coerce regexes to strings and treat strings, primitives and objects,
            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
            // for more details.
            return object == other + "";
        case mapTag:
            var convert = mapToArray;
        case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) return false;
            // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked) return stacked == other;
            bitmask |= COMPARE_UNORDERED_FLAG;
            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
        case symbolTag:
            if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
    }
    return false;
}
module.exports = equalByTag;

},{"1419f6c4bcc38058":"7lsL9","efa3d7e61243e595":"6xFrA","cb54379d65ba06cb":"aVz5f","80a9332e260a6db2":"dQBwf","91f1976d625a36cb":"kAwkU","40f4a93eab936fdd":"2qJif"}],"6xFrA":[function(require,module,exports) {
var root = require("b40dbe18586c6eeb");
/** Built-in value references. */ var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

},{"b40dbe18586c6eeb":"dSYUs"}],"kAwkU":[function(require,module,exports) {
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
module.exports = mapToArray;

},{}],"2qJif":[function(require,module,exports) {
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
module.exports = setToArray;

},{}],"klCEf":[function(require,module,exports) {
var getAllKeys = require("41b0f8ba21ded77f");
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) return false;
    var index = objLength;
    while(index--){
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false;
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) return objStacked == other && othStacked == object;
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while(++index < objLength){
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
}
module.exports = equalObjects;

},{"41b0f8ba21ded77f":"d2kML"}],"d2kML":[function(require,module,exports) {
var baseGetAllKeys = require("fd98698c6ff5926b"), getSymbols = require("cc899a8a2c7929d2"), keys = require("93182435f1c1d22f");
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
module.exports = getAllKeys;

},{"fd98698c6ff5926b":"aeckf","cc899a8a2c7929d2":"5p5Yd","93182435f1c1d22f":"6fHVw"}],"aeckf":[function(require,module,exports) {
var arrayPush = require("58c67b0a0c1fec0f"), isArray = require("cc4bfa1da7da080c");
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
module.exports = baseGetAllKeys;

},{"58c67b0a0c1fec0f":"ivo5r","cc4bfa1da7da080c":"dZaTH"}],"ivo5r":[function(require,module,exports) {
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
module.exports = arrayPush;

},{}],"dZaTH":[function(require,module,exports) {
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
module.exports = isArray;

},{}],"5p5Yd":[function(require,module,exports) {
var arrayFilter = require("db8eadddc5ced029"), stubArray = require("59c3bb684de42c82");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) return [];
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
module.exports = getSymbols;

},{"db8eadddc5ced029":"hmIQ7","59c3bb684de42c82":"6TgRy"}],"hmIQ7":[function(require,module,exports) {
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */ function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while(++index < length){
        var value = array[index];
        if (predicate(value, index, array)) result[resIndex++] = value;
    }
    return result;
}
module.exports = arrayFilter;

},{}],"6TgRy":[function(require,module,exports) {
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
module.exports = stubArray;

},{}],"6fHVw":[function(require,module,exports) {
var arrayLikeKeys = require("fd5f9619f40fc48b"), baseKeys = require("62ba158fda08e3a2"), isArrayLike = require("6dede6a35f24a425");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
module.exports = keys;

},{"fd5f9619f40fc48b":"dquIQ","62ba158fda08e3a2":"c0eiI","6dede6a35f24a425":"gMCbp"}],"dquIQ":[function(require,module,exports) {
var baseTimes = require("aaab92d51fe46ab"), isArguments = require("67839ce7aaa8a653"), isArray = require("3dc3b8c03b7b4ac1"), isBuffer = require("693be256a8de63e3"), isIndex = require("64e94bc19be5a2d9"), isTypedArray = require("7612f163b4164767");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) result.push(key);
    return result;
}
module.exports = arrayLikeKeys;

},{"aaab92d51fe46ab":"odqYd","67839ce7aaa8a653":"8ReNj","3dc3b8c03b7b4ac1":"dZaTH","693be256a8de63e3":"cn85h","64e94bc19be5a2d9":"aJpx0","7612f163b4164767":"6SVKk"}],"odqYd":[function(require,module,exports) {
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
module.exports = baseTimes;

},{}],"8ReNj":[function(require,module,exports) {
var baseIsArguments = require("7894ba31e299a216"), isObjectLike = require("f3178a9697f2a37a");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ var isArguments = baseIsArguments(function() {
    return arguments;
}()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
module.exports = isArguments;

},{"7894ba31e299a216":"gx70P","f3178a9697f2a37a":"3BLi4"}],"gx70P":[function(require,module,exports) {
var baseGetTag = require("c358dcb738f466b6"), isObjectLike = require("c7ae1137c1d4bcbb");
/** `Object#toString` result references. */ var argsTag = "[object Arguments]";
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */ function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
}
module.exports = baseIsArguments;

},{"c358dcb738f466b6":"lOnbo","c7ae1137c1d4bcbb":"3BLi4"}],"3BLi4":[function(require,module,exports) {
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == "object";
}
module.exports = isObjectLike;

},{}],"cn85h":[function(require,module,exports) {
var root = require("9d7c9970932cdeca"), stubFalse = require("b51c73d91606cc7b");
/** Detect free variable `exports`. */ var freeExports = exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && true && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;

},{"9d7c9970932cdeca":"dSYUs","b51c73d91606cc7b":"dx4uy"}],"dx4uy":[function(require,module,exports) {
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = stubFalse;

},{}],"aJpx0":[function(require,module,exports) {
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
module.exports = isIndex;

},{}],"6SVKk":[function(require,module,exports) {
var baseIsTypedArray = require("d3af032589e048e2"), baseUnary = require("a872956ffc98f237"), nodeUtil = require("136a43494e356479");
/* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

},{"d3af032589e048e2":"lGSsl","a872956ffc98f237":"eJXq4","136a43494e356479":"5edNe"}],"lGSsl":[function(require,module,exports) {
var baseGetTag = require("38c630888f42b6c9"), isLength = require("e7959b810b4c574b"), isObjectLike = require("3b0ce2d0bc924326");
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */ function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
module.exports = baseIsTypedArray;

},{"38c630888f42b6c9":"lOnbo","e7959b810b4c574b":"hrTBx","3b0ce2d0bc924326":"3BLi4"}],"hrTBx":[function(require,module,exports) {
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
module.exports = isLength;

},{}],"eJXq4":[function(require,module,exports) {
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
module.exports = baseUnary;

},{}],"5edNe":[function(require,module,exports) {
var freeGlobal = require("9712283e05d29ef1");
/** Detect free variable `exports`. */ var freeExports = exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && true && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) return types;
        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {}
}();
module.exports = nodeUtil;

},{"9712283e05d29ef1":"kAk32"}],"c0eiI":[function(require,module,exports) {
var isPrototype = require("614bf3732407ce11"), nativeKeys = require("27c839c24828e6e5");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
    return result;
}
module.exports = baseKeys;

},{"614bf3732407ce11":"iG4eR","27c839c24828e6e5":"k97u2"}],"iG4eR":[function(require,module,exports) {
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
}
module.exports = isPrototype;

},{}],"k97u2":[function(require,module,exports) {
var overArg = require("f81aaf3866a98a4f");
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

},{"f81aaf3866a98a4f":"dpUvl"}],"dpUvl":[function(require,module,exports) {
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
module.exports = overArg;

},{}],"gMCbp":[function(require,module,exports) {
var isFunction = require("a4fb12a26633ca21"), isLength = require("364d1a4e1686ba8a");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
module.exports = isArrayLike;

},{"a4fb12a26633ca21":"cfti6","364d1a4e1686ba8a":"hrTBx"}],"cRPhM":[function(require,module,exports) {
var DataView = require("d018ec93c2ecce3a"), Map = require("80d07b7136830dd4"), Promise = require("c3b1bd7d3be54839"), Set = require("48561d4f6245a053"), WeakMap = require("e3e45401d0141d8d"), baseGetTag = require("b4b92435edb4f0b0"), toSource = require("11465fdb2992f794");
/** `Object#toString` result references. */ var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
module.exports = getTag;

},{"d018ec93c2ecce3a":"ejRu5","80d07b7136830dd4":"8YjF4","c3b1bd7d3be54839":"jbvCt","48561d4f6245a053":"4xGLf","e3e45401d0141d8d":"av50V","b4b92435edb4f0b0":"lOnbo","11465fdb2992f794":"bYHc7"}],"ejRu5":[function(require,module,exports) {
var getNative = require("8c01edb37aa5a94b"), root = require("3b693bde29873574");
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, "DataView");
module.exports = DataView;

},{"8c01edb37aa5a94b":"9PCIl","3b693bde29873574":"dSYUs"}],"jbvCt":[function(require,module,exports) {
var getNative = require("ecaabdebe771a7a6"), root = require("cd37b7c54587be24");
/* Built-in method references that are verified to be native. */ var Promise = getNative(root, "Promise");
module.exports = Promise;

},{"ecaabdebe771a7a6":"9PCIl","cd37b7c54587be24":"dSYUs"}],"4xGLf":[function(require,module,exports) {
var getNative = require("18153133d16945ec"), root = require("13230ac478a6bd8b");
/* Built-in method references that are verified to be native. */ var Set = getNative(root, "Set");
module.exports = Set;

},{"18153133d16945ec":"9PCIl","13230ac478a6bd8b":"dSYUs"}],"av50V":[function(require,module,exports) {
var getNative = require("3c6f2b2fd5b04a3a"), root = require("d184b619b6663ac4");
/* Built-in method references that are verified to be native. */ var WeakMap = getNative(root, "WeakMap");
module.exports = WeakMap;

},{"3c6f2b2fd5b04a3a":"9PCIl","d184b619b6663ac4":"dSYUs"}],"8IrOr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnknownPlugin", ()=>UnknownPlugin);
var _plugin = require("../../interface/plugin");
var _member = require("./member");
class UnknownPlugin extends (0, _plugin.SkyWayPlugin) {
    subtype = "unknown";
    _createRemoteMember = (channel, memberDto)=>{
        const person = new (0, _member.UnknownMemberImpl)({
            ...this._context,
            context: this._context,
            channel,
            metadata: memberDto.metadata,
            id: memberDto.id,
            name: memberDto.name,
            plugin: this,
            subtype: memberDto.subtype
        });
        return person;
    };
}

},{"../../interface/plugin":"3MSpg","./member":"4dKvO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3jBjn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PACKAGE_VERSION", ()=>PACKAGE_VERSION);
const PACKAGE_VERSION = "1.9.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hAK93":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "IceManager", ()=>IceManager);
var _common = require("@skyway-sdk/common");
const log = new (0, _common.Logger)("packages/core/src/external/ice.ts");
class IceManager {
    constructor(args){
        this.args = args;
        this.domain = this.args.domain;
        this.version = this.args.version;
        this.secure = this.args.secure;
        this.memberId = this.args.memberId;
        this.channelId = this.args.channelId;
        this.ttl = this.args.ttl;
        this.context = this.args.context;
        this._stunServers = [];
        this._turnServers = [];
        this._endpoint = `http${this.secure ? "s" : ""}://${this.domain}/v${this.version}`;
        this.http = new (0, _common.HttpClient)(this._endpoint);
    }
    async updateIceParams() {
        const body = {
            memberId: this.memberId,
            channelId: this.channelId,
            ttl: this.ttl
        };
        log.debug("[start] fetch iceParams");
        const backoff = new (0, _common.BackOff)({
            times: 6,
            interval: 500,
            jitter: 100
        });
        const { turn , stun  } = await this.http.post(`/ice-params`, body, {
            headers: {
                authorization: `Bearer ${this.context.authTokenString}`
            },
            retry: ()=>backoff.wait()
        });
        if (turn) this._turnServers = [
            {
                credential: turn.credential,
                urls: `turn:${turn.domain}:${turn.port}?transport=tcp`,
                username: turn.username
            },
            {
                credential: turn.credential,
                urls: `turn:${turn.domain}:${turn.port}?transport=udp`,
                username: turn.username
            },
            {
                credential: turn.credential,
                urls: `turns:${turn.domain}:${turn.port}?transport=tcp`,
                username: turn.username
            }
        ];
        this._stunServers = [
            {
                urls: `stun:${stun.domain}:${stun.port}`
            }
        ];
        log.debug("[end] fetch iceParams", {
            turn,
            stun
        });
    }
    get iceServers() {
        let iceServers = [
            ...this._stunServers
        ];
        const turnServers = this._turnServers.filter((t)=>{
            const url = t.urls;
            switch(this.context.config.rtcConfig.turnProtocol){
                case "all":
                    return true;
                case "udp":
                    return url.endsWith("udp");
                case "tcp":
                    return !url.startsWith("turns") && url.endsWith("tcp");
                case "tls":
                    return url.startsWith("turns");
            }
        });
        if (this.context.config.rtcConfig.turnPolicy !== "disable") iceServers = [
            ...iceServers,
            ...turnServers
        ];
        return iceServers;
    }
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gUNcI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setupSignalingSession", ()=>setupSignalingSession);
parcelHelpers.export(exports, "SignalingSession", ()=>SignalingSession);
var _common = require("@skyway-sdk/common");
var _signalingClient = require("@skyway-sdk/signaling-client");
var _token = require("@skyway-sdk/token");
var _errors = require("../errors");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/core/src/external/signaling.ts");
async function setupSignalingSession(context, channel, memberDto) {
    const { signalingService  } = context.config;
    const client = new (0, _signalingClient.SignalingClient)({
        token: context.authTokenString,
        channelId: channel.id,
        channelName: channel.name,
        memberId: memberDto.id,
        memberName: memberDto.name
    }, {
        logger: {
            error: async (error)=>{
                log.error("SignalingClient error", (0, _util.createError)({
                    operationName: "SignalingClient.logger",
                    context,
                    info: {
                        ...(0, _errors.errors).internal,
                        detail: "signalingClient error"
                    },
                    error,
                    path: log.prefix,
                    channel
                }));
            },
            debug: (s)=>{
            // log.debug('signaling service:', s);
            }
        },
        signalingServerDomain: signalingService.domain,
        secure: signalingService.secure
    });
    const signalingSession = new SignalingSession(client, context);
    await signalingSession.connect();
    return signalingSession;
}
class SignalingSession {
    constructor(_client, context){
        this._client = _client;
        this.context = context;
        this.onConnectionFailed = new (0, _common.Event)();
        this.onConnectionStateChanged = new (0, _common.Event)();
        this.onMessage = new (0, _common.Event)();
        this.closed = false;
        this._chunkedMessageBuffer = {};
        this._backoffUpdateSkyWayAuthToken = new (0, _common.BackOff)({
            times: 8,
            interval: 100,
            jitter: 100
        });
        this._disposer = new (0, _common.EventDisposer)();
        this._listen();
        context._onTokenUpdated.add(async (token)=>{
            await this._updateSkyWayAuthToken(token);
        }).disposer(this._disposer);
    }
    updateClient(client) {
        this._client = client;
        this._listen();
    }
    _listen() {
        this._client.onConnectionFailed.addOneTimeListener(()=>{
            this.onConnectionFailed.emit({});
        });
        this._client.onConnectionStateChanged.addListener((state)=>{
            log.debug("signalingClient onConnectionStateChanged", state);
            this.onConnectionStateChanged.emit(state);
        });
        this._client.onRequested.addListener(async ({ data , src , reply  })=>{
            const messageChunk = data;
            const { chunk , length , offset , id , type  } = messageChunk;
            if (type !== messageType) return;
            if (length === 0) this.onMessage.emit({
                src,
                data: JSON.parse(chunk)
            });
            else {
                this._chunkedMessageBuffer[id] = [
                    ...this._chunkedMessageBuffer[id] ?? [],
                    messageChunk.chunk
                ];
                if (length === offset) {
                    const message = this._chunkedMessageBuffer[id].join("");
                    delete this._chunkedMessageBuffer[id];
                    this.onMessage.emit({
                        src,
                        data: JSON.parse(message)
                    });
                }
            }
            await reply({}).catch((e)=>{
                if (this.closed) return;
                log.warn("failed to reply", (0, _util.createWarnPayload)({
                    operationName: "SignalingSession.reply",
                    detail: "SignalingClient failed to reply"
                }), e);
            });
        });
    }
    async _updateSkyWayAuthToken(token) {
        if (this._backoffUpdateSkyWayAuthToken.exceeded) {
            log.error("[failed] updateSkyWayAuthToken");
            return;
        }
        await this._backoffUpdateSkyWayAuthToken.wait();
        log.debug("[start] updateSkyWayAuthToken", {
            count: this._backoffUpdateSkyWayAuthToken.count
        });
        const e = await this._client.updateSkyWayAuthToken(token).catch((e)=>e);
        if (e) {
            log.warn("[retry] updateSkyWayAuthToken", (0, _util.createWarnPayload)({
                operationName: "SignalingSession._updateSkyWayAuthToken",
                detail: "[retry] updateSkyWayAuthToken"
            }), e);
            await this._updateSkyWayAuthToken(token);
            return;
        }
        log.debug("[end] updateSkyWayAuthToken");
        this._backoffUpdateSkyWayAuthToken.reset();
    }
    get connectionState() {
        return this._client.connectionState;
    }
    async connect() {
        log.debug("[start] connect signalingService");
        await this._client.connect().catch((err)=>{
            throw (0, _util.createError)({
                operationName: "signalingSession.connect",
                path: log.prefix,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "signalingClient failed to connect Server"
                },
                context: this.context,
                error: err
            });
        });
        log.debug("[end] connect signalingService");
    }
    close() {
        this.closed = true;
        this._disposer.dispose();
        this._client.disconnect();
    }
    /**@throws {@link SkyWayError} */ async send(target, data, /**ms */ timeout = 10000) {
        try {
            const payload = JSON.stringify(data);
            const id = (0, _token.uuidV4)();
            // chunking message
            if (payload.length > 20480) {
                const split = payload.match(/.{1,20480}/g) ?? [];
                let offset = 0;
                for (const chunk of split){
                    const chunkMessage = {
                        type: messageType,
                        length: split.length - 1,
                        offset: offset++,
                        chunk,
                        id
                    };
                    await this._client.request(target, chunkMessage, timeout / 1000);
                }
            } else {
                const chunkMessage = {
                    type: messageType,
                    length: 0,
                    offset: 0,
                    chunk: payload,
                    id
                };
                await this._client.request(target, chunkMessage, timeout / 1000);
            }
        } catch (error) {
            if (this.closed || target.state !== "joined") return;
            throw (0, _util.createError)({
                operationName: "SignalingSession.send",
                context: this.context,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "signalingClient"
                },
                error,
                path: log.prefix,
                payload: {
                    target,
                    data
                }
            });
        }
    }
}
const messageType = "signalingMessage";

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/signaling-client":"anDnl","@skyway-sdk/token":"1nlc7","../errors":"gDbIj","../util":"ey5Lv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"anDnl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConnectionState", ()=>(0, _socket.ConnectionState));
parcelHelpers.export(exports, "Event", ()=>(0, _event.Event));
parcelHelpers.export(exports, "Logger", ()=>(0, _logger.Logger));
var _signalingClient = require("./signalingClient");
parcelHelpers.exportAll(_signalingClient, exports);
var _socket = require("./socket");
var _event = require("./utils/event");
var _logger = require("./utils/logger");

},{"./signalingClient":"fi7ve","./socket":"eeCzV","./utils/event":"bkC2j","./utils/logger":"8AA80","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fi7ve":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SignalingClient", ()=>SignalingClient);
var _uuid = require("uuid");
var _clientEvent = require("./clientEvent");
var _payloadTypes = require("./payloadTypes");
var _socket = require("./socket");
var _event = require("./utils/event");
const SIGNALING_SERVER_DOMAIN = "signaling.skyway.ntt.com";
const API_VERSION = "v1";
class SignalingClient {
    onConnectionStateChanged = new (0, _event.Event)();
    onConnectionFailed = new (0, _event.Event)();
    onRequested = new (0, _event.Event)();
    _connectivityCheckTimers = new Map();
    _responseCallbacks = new Map();
    _acknowledgeCallbacks = new Map();
    constructor({ token , channelId , channelName , memberId , memberName  }, options){
        this._token = token;
        this._channelId = channelId;
        this._channelName = channelName;
        this._memberId = memberId;
        this._memberName = memberName;
        const defaultOptions = {
            connectivityCheckIntervalSec: 30,
            signalingServerDomain: SIGNALING_SERVER_DOMAIN,
            secure: true,
            logger: {
                debug: (message)=>{
                    console.debug(message);
                },
                error: (error)=>{
                    console.error(error);
                }
            }
        };
        this._options = Object.assign({}, defaultOptions, options ?? {});
        this._logger = this._options.logger;
        this._logger.debug(`Created instance with the options: ${this._options}`);
    }
    get connectionState() {
        return this._socket?.connectionState ?? "closed";
    }
    async connect() {
        const WSProtocol = this._options.secure ? "wss" : "ws";
        const signalingServerDomain = this._options.signalingServerDomain || SIGNALING_SERVER_DOMAIN;
        this._socket = new (0, _socket.Socket)({
            sessionEndpoint: `${WSProtocol}://${signalingServerDomain}/${API_VERSION}/ws`,
            channelId: this._channelId,
            channelName: this._channelName,
            memberId: this._memberId,
            memberName: this._memberName,
            token: this._token,
            logger: this._logger
        });
        this._socket.onEventReceived.addListener((data)=>{
            try {
                this._eventReceivedHandler(data);
            } catch (error) {
                this._logger.error("in _eventReceivedHandler", error);
            }
        });
        this._socket.onConnectionFailed.addListener(()=>{
            this.onConnectionFailed.emit();
        });
        this._socket.onConnectionStateChanged.addListener((state)=>{
            this.onConnectionStateChanged.emit(state);
        });
        await this._socket.onOpened.asPromise(15000);
        this._startConnectivityCheck();
    }
    disconnect() {
        this._stopConnectivityCheck();
        this._socket?.destroy();
        this._socket = undefined;
        this._responseCallbacks.clear();
        this._acknowledgeCallbacks.clear();
    }
    _startConnectivityCheck() {
        if (this._connectivityCheckInterval) {
            this._logger.debug("connectivity check timer is already set");
            return;
        }
        this._connectivityCheckInterval = setInterval(()=>{
            const clientEvent = new (0, _clientEvent.ClientEvent)("checkConnectivity");
            this._socket?.send(clientEvent).catch(()=>{
                this._acknowledgeCallbacks.delete(clientEvent.eventId);
            });
            this._connectivityCheckTimers.set(clientEvent.eventId, setTimeout(()=>{
                this._acknowledgeCallbacks.delete(clientEvent.eventId);
                this._socket?.reconnect();
                this._logger.debug("connectivity check timer is expired");
            }, 5000));
            this._setAcknowledgeCallback(clientEvent.eventId, (data)=>{
                const timer = this._connectivityCheckTimers.get(clientEvent.eventId);
                if (timer) {
                    clearTimeout(timer);
                    this._connectivityCheckTimers.delete(clientEvent.eventId);
                }
                if (!data.ok) {
                    this._socket?.reconnect();
                    this._logger.debug("connectivity check response from server was not ok");
                }
            });
        }, this._options.connectivityCheckIntervalSec * 1000);
        this._logger.debug("Started connectivity check timer");
    }
    _stopConnectivityCheck() {
        if (!this._connectivityCheckInterval) {
            this._logger.debug("connectivity check timer is not set");
            return;
        }
        clearInterval(this._connectivityCheckInterval);
        this._connectivityCheckInterval = undefined;
        this._logger.debug("Stopped connectivity check timer");
        for (const [_, timer] of this._connectivityCheckTimers)clearTimeout(timer);
        this._connectivityCheckTimers.clear();
    }
    request(target, data, timeoutSec = 10) {
        validateTarget(target);
        validateData(data);
        return new Promise((resolve, reject)=>{
            if (this._socket === undefined) {
                reject(new Error("websocket is not connected"));
                return;
            }
            const payload = {
                dst: target,
                data
            };
            const clientEvent = new (0, _clientEvent.ClientEvent)("sendRequestSignalingMessage", payload);
            const timer = setTimeout(()=>{
                this._acknowledgeCallbacks.delete(clientEvent.eventId);
                reject(new Error("request timeout"));
            }, timeoutSec * 1000);
            this._setResponseCallback(clientEvent.eventId, (data)=>{
                clearTimeout(timer);
                resolve(data);
            });
            this._setAcknowledgeCallback(clientEvent.eventId, (data)=>{
                if (!data.ok) {
                    clearTimeout(timer);
                    reject(data);
                }
            });
            this._socket.send(clientEvent).catch((err)=>{
                this._acknowledgeCallbacks.delete(clientEvent.eventId);
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    _response(target, requestEventId, data, timeoutSec) {
        return new Promise((resolve, reject)=>{
            validateData(data);
            if (this._socket === undefined) {
                reject(new Error("websocket is not connected"));
                return;
            }
            const payload = {
                dst: target,
                requestEventId,
                data
            };
            const clientEvent = new (0, _clientEvent.ClientEvent)("sendResponseSignalingMessage", payload);
            const timer = setTimeout(()=>{
                this._acknowledgeCallbacks.delete(clientEvent.eventId);
                reject(new Error("response timeout"));
            }, timeoutSec * 1000);
            this._setAcknowledgeCallback(clientEvent.eventId, (data)=>{
                clearTimeout(timer);
                if (data.ok) resolve();
                else reject(data);
            });
            this._socket.send(clientEvent).catch((err)=>{
                this._acknowledgeCallbacks.delete(clientEvent.eventId);
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    updateSkyWayAuthToken(token, timeoutSec = 10) {
        return new Promise((resolve, reject)=>{
            if (this._socket === undefined) {
                reject(new Error("websocket is not connected"));
                return;
            }
            const payload = {
                token
            };
            const clientEvent = new (0, _clientEvent.ClientEvent)("updateSkyWayAuthToken", payload);
            const timer = setTimeout(()=>{
                this._acknowledgeCallbacks.delete(clientEvent.eventId);
                reject(new Error("updateSkyWayAuthToken timeout"));
            }, timeoutSec * 1000);
            this._setAcknowledgeCallback(clientEvent.eventId, (data)=>{
                clearTimeout(timer);
                if (data.ok) {
                    if (this._socket === undefined) {
                        reject(new Error("websocket is not connected"));
                        return;
                    }
                    this._socket.updateAuthToken(token);
                    resolve();
                } else reject(data);
            });
            this._socket.send(clientEvent).catch((err)=>{
                this._acknowledgeCallbacks.delete(clientEvent.eventId);
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    _eventReceivedHandler(data) {
        switch(data.event){
            case "acknowledge":
                this._acknowledgeHandler(data.payload);
                break;
            case "sendRequestSignalingMessage":
                this._eventMessageRequestHandler(data.payload);
                break;
            case "sendResponseSignalingMessage":
                this._eventMessageResponseHandler(data.payload);
                break;
            case "open":
                break; // nop
            default:
                {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const _ = data.event;
                    this._logger.debug(`Unknown event: ${data.event}`);
                }
        }
    }
    _acknowledgeHandler(payload) {
        if (!(0, _payloadTypes.isAcknowledgePayload)(payload)) throw new Error("Invalid payload");
        const { eventId  } = payload;
        if (!this._acknowledgeCallbacks.has(eventId)) throw new Error(`acknowledge event has unknown eventId: ${eventId}`);
        const callback = this._acknowledgeCallbacks.get(eventId);
        if (callback) {
            this._acknowledgeCallbacks.delete(eventId);
            callback(payload);
        }
    }
    _eventMessageRequestHandler(payload) {
        if (!(0, _payloadTypes.isMessagePayload)(payload)) throw new Error("Invalid payload");
        if (!payload.requestEventId) throw new Error("Invalid payload");
        const src = payload.src;
        const requestEventId = payload.requestEventId;
        const reply = async (data, timeout = 10)=>{
            await this._response(src, requestEventId, data, timeout);
        };
        this.onRequested.emit({
            data: payload.data,
            reply: reply,
            requestEventId: payload.requestEventId,
            src: payload.src
        });
    }
    _eventMessageResponseHandler(payload) {
        if (!(0, _payloadTypes.isMessagePayload)(payload)) throw new Error("Invalid payload");
        if (!payload.requestEventId || !this._responseCallbacks.has(payload.requestEventId)) throw new Error(`received response has unknown eventId: ${payload.requestEventId}`);
        const callback = this._responseCallbacks.get(payload.requestEventId);
        if (callback) {
            this._responseCallbacks.delete(payload.requestEventId);
            callback(payload.data);
        }
    }
    _setResponseCallback(eventId, callback) {
        this._responseCallbacks.set(eventId, callback);
    }
    _setAcknowledgeCallback(eventId, callback) {
        this._acknowledgeCallbacks.set(eventId, callback);
    }
}
function validateData(data) {
    if (!data || typeof data !== "object") throw new Error("the type of data must be object");
}
function validateTarget(target) {
    if (!(0, _payloadTypes.isMember)(target)) throw new Error("the type of target must be {id: string, name: string}");
    if (!(0, _uuid.validate)(target.id)) throw new Error("the type of target.id must be uuid format");
}

},{"uuid":"3vIyX","./clientEvent":"8uFSA","./payloadTypes":"h4Qki","./socket":"eeCzV","./utils/event":"bkC2j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3vIyX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":false,"./v3.js":false,"./v4.js":"jnbtW","./v5.js":false,"./nil.js":false,"./version.js":false,"./validate.js":"bDhKU","./stringify.js":"kr9F1","./parse.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jnbtW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeJs = require("./native.js");
var _nativeJsDefault = parcelHelpers.interopDefault(_nativeJs);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
function v4(options, buf, offset) {
    if ((0, _nativeJsDefault.default).randomUUID && !buf && !options) return (0, _nativeJsDefault.default).randomUUID();
    options = options || {};
    const rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJs.unsafeStringify)(rnds);
}
exports.default = v4;

},{"./native.js":"4ScB5","./rng.js":"2pnTW","./stringify.js":"kr9F1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ScB5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports.default = {
    randomUUID
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2pnTW":[function(require,module,exports) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return getRandomValues(rnds8);
}
exports.default = rng;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kr9F1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeStringify", ()=>unsafeStringify);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"bDhKU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bDhKU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === "string" && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"95To2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"95To2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8uFSA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ClientEvent", ()=>ClientEvent);
var _uuid = require("uuid");
const MAX_PAYLOAD_LENGTH = 20480;
class ClientEvent {
    constructor(event, payload = {}){
        this.event = event;
        this.payload = payload;
        this.eventId = (0, _uuid.v4)();
        this.data = JSON.stringify({
            event: this.event,
            eventId: this.eventId,
            payload: this.payload
        });
        if (this.data.length > MAX_PAYLOAD_LENGTH) throw new Error("payload size exceeds the upper limit");
    }
}

},{"uuid":"3vIyX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4Qki":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isMessagePayload", ()=>isMessagePayload);
parcelHelpers.export(exports, "isAcknowledgePayload", ()=>isAcknowledgePayload);
parcelHelpers.export(exports, "isMember", ()=>isMember);
const AcknowledgeReason = [
    "rateLimitExceeded",
    "targetNotFound",
    "payloadLengthExceeded",
    "invalidPayload",
    "unknown",
    "parameterError",
    "permissionError"
];
function isMessagePayload(payload) {
    if (!payload || typeof payload !== "object") return false;
    if (!isMember(payload.src)) return false;
    if (!payload.data || typeof payload.data !== "object") return false;
    return true;
}
function isAcknowledgePayload(payload) {
    if (!payload || typeof payload !== "object") return false;
    if (typeof payload.eventId !== "string") return false;
    if (typeof payload.ok !== "boolean") return false;
    if (typeof payload.reason !== "undefined" && (typeof payload.reason !== "string" || !AcknowledgeReason.includes(payload.reason))) return false;
    return true;
}
function isMember(arg) {
    if (arg === undefined || Array.isArray(arg)) return false;
    if (typeof arg !== "object") return false;
    if (typeof arg.id !== "string") return false;
    if (typeof arg.name !== "undefined" && typeof arg.name !== "string") return false;
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eeCzV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Socket", ()=>Socket);
var _isomorphicWs = require("isomorphic-ws");
var _isomorphicWsDefault = parcelHelpers.interopDefault(_isomorphicWs);
var _event = require("./utils/event");
var _version = require("./version");
const ServerEventType = [
    "open",
    "sendRequestSignalingMessage",
    "sendResponseSignalingMessage",
    "acknowledge"
];
const getReconnectWaitTime = (reconnectCount)=>{
    return (2 ** reconnectCount + Math.random()) * 1000;
};
class Socket {
    _isOpen = false;
    _isDestroyed = false;
    _reconnectCount = 0;
    connectionState = "closed";
    onConnectionStateChanged = new (0, _event.Event)();
    onOpened = new (0, _event.Event)();
    onEventReceived = new (0, _event.Event)();
    onConnectionFailed = new (0, _event.Event)();
    constructor({ channelId , channelName , memberId , memberName , sessionEndpoint , token , logger  }){
        this._sessionEndpoint = sessionEndpoint;
        this._channelId = channelId;
        this._channelName = channelName;
        this._memberId = memberId;
        this._memberName = memberName;
        this._token = token;
        this._logger = logger;
        this._connect();
    }
    _setConnectionState(state) {
        this._logger.debug(`connectionState changed : ${state}`);
        this.connectionState = state;
        this.onConnectionStateChanged.emit(state);
    }
    _connect() {
        let ws;
        try {
            // We use the SubProtocol header to send the token.
            // This is because the browser's WebSocket class does not allow the header to be changed freely.
            const subProtocol = `SkyWayAuthToken!${this._token}`;
            const wsProperties = {
                channelId: this._channelId,
                channelName: this._channelName,
                memberId: this._memberId,
                memberName: this._memberName,
                platform: "javascript",
                version: (0, _version.PACKAGE_VERSION)
            };
            const queryString = Object.entries(wsProperties).filter(([_, v])=>v !== undefined).map((pair)=>pair.join("=")).join("&");
            const wsURL = `${this._sessionEndpoint}?${queryString}`;
            ws = new (0, _isomorphicWsDefault.default)(wsURL, subProtocol);
            this._logger.debug(`Connecting to signaling-server: ${this._sessionEndpoint}`);
            ws.onerror = (event)=>{
                this._logger.error("WebSocket error occurred", event.error);
                ws.close(4202);
            };
        } catch (err) {
            const error = err instanceof Error ? err : new Error();
            this._logger.error("Failed to create WebSocket instance", error);
            this.reconnect();
            return;
        }
        ws.onopen = ()=>{
            this._logger.debug("Connected to signaling-server");
        };
        ws.onclose = (event)=>{
            const logMessage = "Close event fired: " + JSON.stringify({
                code: event.code,
                reason: event.reason,
                type: event.type
            });
            // 1000, 4000~4099: normal case (should not reconnect)
            // 4100~4199: non-normal case (should not reconnect)
            // 4200~4299: non-normal case (should reconnect)
            // others: unexpected case (should reconnect)
            if (4100 <= event.code && event.code <= 4199) this._logger.error(logMessage, new Error());
            else this._logger.debug(logMessage);
            if (event.code !== 1000 && !(4000 <= event.code && event.code <= 4199)) {
                this.reconnect();
                return;
            }
            // Return not to destroy _ws successfully reconnected
            if (event.code === 4000) return;
            this._logger.debug("Closed the connection to signaling-server");
            this.onConnectionFailed.emit();
            this.destroy();
        };
        ws.onmessage = (event)=>{
            this._messageHandler(event.data);
        };
        this._ws = ws;
    }
    updateAuthToken(token) {
        this._token = token;
    }
    reconnect() {
        if (this._ws !== undefined) this._ws.close(4000);
        this._ws = undefined;
        this._isOpen = false;
        if (this._reconnectCount >= 8) {
            this.onConnectionFailed.emit();
            this.destroy();
            this._logger.error("Failed to reconnect for eight times", new Error());
        } else {
            this._setConnectionState("reconnecting");
            const waitTime = getReconnectWaitTime(this._reconnectCount);
            this._reconnectTimer = setTimeout(()=>{
                this._connect();
                this._reconnectCount++;
                this._logger.debug(`Try to reconnect: count = ${this._reconnectCount}`);
            }, waitTime);
        }
    }
    destroy() {
        this._isDestroyed = true;
        this._setConnectionState("closed");
        this.onConnectionStateChanged.removeAllListeners();
        this.onOpened.removeAllListeners();
        this.onEventReceived.removeAllListeners();
        this.onConnectionFailed.removeAllListeners();
        if (this._reconnectTimer) clearTimeout(this._reconnectTimer);
        if (this._ws !== undefined) this._ws.close(1000);
    }
    send(clientEvent) {
        return new Promise((resolve, reject)=>{
            const retrySend = ()=>{
                this.onOpened.addOneTimeListener(()=>{
                    this.send(clientEvent).then(()=>{
                        resolve();
                    }).catch((err)=>{
                        reject(err);
                    });
                });
                this.onConnectionFailed.addOneTimeListener(()=>{
                    reject(new Error("Connection failed"));
                });
            };
            if (this._isDestroyed) {
                reject(new Error("The socket is already destroyed"));
                return;
            }
            if (this._ws === undefined || !this._isOpen) {
                // Call send method again after connected
                this._logger.debug("Retry send the client event when connected because WebSocket is undefined or isOpen = false");
                retrySend();
                return;
            }
            this._logger.debug(`Send the event: ${clientEvent.data}`);
            this._ws.send(clientEvent.data, (err)=>{
                if (err) {
                    // If state is invalid, call send method again after reconnected
                    if (this._ws === undefined || !this._isOpen || this._ws.readyState !== (0, _isomorphicWsDefault.default).OPEN) {
                        this._logger.debug("Retry send the client event when connected because WebSocket.send failed");
                        retrySend();
                        return;
                    }
                    reject(err);
                } else resolve();
            });
        });
    }
    _messageHandler(data) {
        if (typeof data !== "string") {
            this._logger.error("Received invalid message: not string", new Error());
            return;
        }
        let parsedData;
        try {
            parsedData = JSON.parse(data);
        } catch (err) {
            const error = err instanceof Error ? err : new Error();
            this._logger.error("Received invalid message: parse error", error);
            return;
        }
        if (!isServerEvent(parsedData)) {
            this._logger.error(`Received invalid message: ${parsedData}`, new Error());
            return;
        }
        if (parsedData.event === "open") {
            this._logger.debug("Received a open event");
            this._isOpen = true;
            this._setConnectionState("connected");
            if (this._reconnectCount !== 0) {
                this._reconnectCount = 0;
                this._logger.debug("Succeeded to reconnect");
            }
            this.onOpened.emit();
        } else {
            this._logger.debug(`Received the event: ${parsedData.event}, payload: ${JSON.stringify(parsedData.payload)}`);
            this.onEventReceived.emit(parsedData);
        }
    }
}
function isServerEvent(data) {
    if (!data || typeof data !== "object") return false;
    if (typeof data.event !== "string" || !ServerEventType.includes(data.event)) return false;
    if (typeof data.eventId !== "string") return false;
    if (data.payload && typeof data.payload !== "object") return false;
    return true;
}

},{"isomorphic-ws":"5nVUE","./utils/event":"bkC2j","./version":"j0Hgp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bkC2j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Event", ()=>Event);
class Event {
    _listeners = new Map();
    _listenerIndex = 0;
    emit = (arg)=>{
        this._listeners.forEach((listener)=>listener(arg));
    };
    removeAllListeners = ()=>{
        this._listeners.clear();
    };
    addListener = (listener)=>{
        const id = this._listenerIndex;
        this._listeners.set(id, listener);
        this._listenerIndex++;
        const removeListener = ()=>{
            this._listeners.delete(id);
        };
        return {
            removeListener
        };
    };
    addOneTimeListener = (listener)=>{
        const off = this.addListener((arg)=>{
            off.removeListener();
            listener(arg);
        });
        return off;
    };
    asPromise = (timeLimit)=>new Promise((resolve, reject)=>{
            let removeListener = ()=>{};
            const timeout = timeLimit && setTimeout(()=>{
                reject("Event asPromise timeout");
                removeListener();
            }, timeLimit);
            const off = this.addOneTimeListener((arg)=>{
                if (timeout) clearTimeout(timeout);
                resolve(arg);
            });
            removeListener = off.removeListener;
        });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j0Hgp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PACKAGE_VERSION", ()=>PACKAGE_VERSION);
const PACKAGE_VERSION = "1.0.4";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8AA80":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"89UU8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "createSubscription", ()=>createSubscription);
var _ = require(".");
function createSubscription(channel, { subscriberId , publicationId , id  }) {
    const exist = channel._getSubscription(id);
    if (exist) return exist;
    const publication = channel._getPublication(publicationId);
    const contentType = publication.contentType;
    const subscription = new (0, _.SubscriptionImpl)({
        channel,
        id,
        subscriber: channel._getMember(subscriberId),
        publication: channel._getPublication(publicationId),
        contentType
    });
    return subscription;
}

},{".":"5Tclz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Tclz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "SubscriptionImpl", ()=>SubscriptionImpl);
var _common = require("@skyway-sdk/common");
var _errors = require("../errors");
var _util = require("../util");
var _factory = require("./factory");
parcelHelpers.exportAll(_factory, exports);
const log = new (0, _common.Logger)("packages/core/src/subscription/index.ts");
class SubscriptionImpl {
    _disposer = new (0, _common.EventDisposer)();
    _state = "enabled";
    get state() {
        return this._state;
    }
    onCanceled = new (0, _common.Event)();
    onStreamAttached = new (0, _common.Event)();
    onConnectionStateChanged = new (0, _common.Event)();
    /**@internal */ _onChangeEncoding = new (0, _common.Event)();
    constructor(args){
        this._channel = args.channel;
        this._context = this._channel._context;
        this.id = args.id;
        this.contentType = args.contentType;
        this.subscriber = args.subscriber;
        this.publication = args.publication;
        log.debug("subscription spawned", this.toJSON());
        this._handlePublicationEnabled();
    }
    _handlePublicationEnabled() {
        this.publication.onDisabled.add(()=>{
            if (this.stream) {
                log.debug("disabled", this);
                this.stream.setIsEnabled(false);
            }
        }).disposer(this._disposer);
        this.publication.onEnabled.add(()=>{
            if (this.stream) {
                log.debug("enabled", this);
                this.stream.setIsEnabled(true);
            }
        }).disposer(this._disposer);
        if (this.stream) this.stream.setIsEnabled(this.publication.state === "enabled");
    }
    /**@internal */ _setStream(stream) {
        this._stream = stream;
        this.onStreamAttached.emit();
        stream._onConnectionStateChanged.add((e)=>{
            log.debug("onConnectionStateChanged", this.id, e);
            this.onConnectionStateChanged.emit(e);
        });
    }
    get stream() {
        return this._stream;
    }
    toJSON() {
        return {
            id: this.id,
            contentType: this.contentType,
            subscriber: this.subscriber,
            publication: this.publication,
            channelId: this._channel.id,
            state: this.state,
            stream: this.stream
        };
    }
    /**@private */ _canceled() {
        this._state = "canceled";
        this.onCanceled.emit();
        this._disposer.dispose();
    }
    cancel = ()=>new Promise((r, f)=>{
            let failed = false;
            this._channel._unsubscribe(this.id).catch((e)=>{
                failed = true;
                f(e);
            });
            this.onCanceled.asPromise(this._context.config.rtcApi.timeout).then(()=>r()).catch((e)=>{
                if (!failed) f(e);
            });
        });
    changePreferredEncoding(id) {
        if (!this.stream) throw (0, _util.createError)({
            operationName: "SubscriptionImpl.changePreferredEncoding",
            info: (0, _errors.errors).streamNotExistInSubscription,
            path: log.prefix,
            context: this._context,
            channel: this._channel
        });
        if (this.stream.contentType === "data") throw (0, _util.createError)({
            operationName: "SubscriptionImpl.changePreferredEncoding",
            info: (0, _errors.errors).dataStreamNotSupportEncoding,
            path: log.prefix,
            context: this._context,
            channel: this._channel
        });
        if (!this.publication.encodings.map((e)=>e.id).includes(id)) throw (0, _util.createError)({
            operationName: "SubscriptionImpl.changePreferredEncoding",
            info: (0, _errors.errors).correspondingEncodeNotExistForId,
            path: log.prefix,
            context: this._context,
            channel: this._channel
        });
        this.preferredEncoding = id;
        this._onChangeEncoding.emit();
    }
    getStats() {
        if (!this.stream) throw (0, _util.createError)({
            operationName: "SubscriptionImpl.getStats",
            info: (0, _errors.errors).streamNotExistInSubscription,
            path: log.prefix,
            context: this._context,
            channel: this._channel
        });
        return this.stream._getStats();
    }
    getRTCPeerConnection() {
        if (!this.stream) throw (0, _util.createError)({
            operationName: "SubscriptionImpl.getRTCPeerConnection",
            info: (0, _errors.errors).streamNotExistInSubscription,
            path: log.prefix,
            context: this._context,
            channel: this._channel
        });
        return this.stream._getRTCPeerConnection();
    }
    getConnectionState() {
        if (!this.stream) throw (0, _util.createError)({
            operationName: "SubscriptionImpl.getConnectionState",
            info: (0, _errors.errors).streamNotExistInSubscription,
            path: log.prefix,
            context: this._context,
            channel: this._channel
        });
        return this.stream._getConnectionState();
    }
}

},{"@skyway-sdk/common":"3hyrG","../errors":"gDbIj","../util":"ey5Lv","./factory":"89UU8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"963Vz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kj0Km":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"qXbjM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StreamFactory", ()=>StreamFactory);
parcelHelpers.export(exports, "SkyWayStreamFactory", ()=>SkyWayStreamFactory);
/**@internal */ parcelHelpers.export(exports, "MediaDevice", ()=>MediaDevice);
var _common = require("@skyway-sdk/common");
var _errors = require("../errors");
var _util = require("../util");
var _audio = require("./stream/local/audio");
var _customVideo = require("./stream/local/customVideo");
var _data = require("./stream/local/data");
var _video = require("./stream/local/video");
const log = new (0, _common.Logger)("packages/core/src/media/factory.ts");
class StreamFactory {
    /**
   * @description [japanese] 一度参照した種類のデバイスの状態が変化した時に発火するイベント
   */ onDeviceChange = new (0, _common.Event)();
    _devices = [];
    /**@private */ constructor(){
        if (!navigator?.mediaDevices) throw (0, _util.createError)({
            operationName: "StreamFactory.constructor",
            info: (0, _errors.errors).mediaDevicesNotFound,
            path: log.prefix
        });
        navigator.mediaDevices.addEventListener("devicechange", async ()=>{
            const devices = await this._enumerateDevicesArray();
            const removed = [];
            this._devices.forEach((prev)=>{
                if (!devices.map((d)=>d.id).includes(prev.id)) removed.push(prev);
            });
            const added = [];
            devices.map((d)=>d.id).forEach((next)=>{
                if (!this._devices.map((d)=>d.id).includes(next)) added.push(devices.find((d)=>d.id === next));
            });
            log.debug("device changed", {
                added,
                removed
            });
            removed.forEach((device)=>{
                this.onDeviceChange.emit({
                    state: "removed",
                    device
                });
            });
            added.forEach((device)=>{
                this.onDeviceChange.emit({
                    state: "added",
                    device
                });
            });
            this._devices = devices;
        });
    }
    async _enumerateDevicesArray() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        return devices.map((d)=>new MediaDevice(d)).filter((d)=>d.id.length > 0);
    }
    async _enumerateDevicesWithAuth({ video , audio  } = {
        audio: true,
        video: true
    }) {
        let tracks = [];
        if (video || audio) {
            const stream = await navigator.mediaDevices.getUserMedia({
                video,
                audio
            });
            tracks = stream.getTracks();
        }
        this._devices = await this._enumerateDevicesArray();
        tracks.forEach((t)=>t.stop());
        return this._devices;
    }
    /**
   * @description [japanese] デバイスの一覧を取得する
   */ async enumerateDevices() {
        const devices = await this._enumerateDevicesWithAuth();
        return devices;
    }
    /**
   * @description [japanese] 映像入力デバイスの一覧を取得する
   */ async enumerateInputVideoDevices() {
        const devices = await this._enumerateDevicesWithAuth({
            video: true
        });
        return devices.filter((d)=>d.kind === "videoinput");
    }
    /**
   * @description [japanese] 音声入力デバイスの一覧を取得する
   */ async enumerateInputAudioDevices() {
        const devices = await this._enumerateDevicesWithAuth({
            audio: true
        });
        return devices.filter((d)=>d.kind === "audioinput");
    }
    /**
   * @description [japanese] 音声出力デバイスの一覧を取得する
   */ async enumerateOutputAudioDevices() {
        const devices = await this._enumerateDevicesWithAuth({
            audio: true
        });
        return devices.filter((d)=>d.kind === "audiooutput");
    }
    /**
   * @description [japanese] CameraのVideoStreamを作成する
   */ async createCameraVideoStream(options = {}) {
        options.stopTrackWhenDisabled = options.stopTrackWhenDisabled ?? true;
        const [track] = (await navigator.mediaDevices.getUserMedia({
            video: options
        })).getTracks();
        const stream = new (0, _video.LocalVideoStream)(track, options);
        stream._setLabel("camera");
        return stream;
    }
    /**
   * @description [japanese] マイクのAudioStreamを作成する
   */ async createMicrophoneAudioStream(options = {}) {
        options.stopTrackWhenDisabled = options.stopTrackWhenDisabled ?? true;
        const [track] = (await navigator.mediaDevices.getUserMedia({
            audio: options
        })).getTracks();
        const stream = new (0, _audio.LocalAudioStream)(track, options);
        stream._setLabel("microphone");
        return stream;
    }
    /**
   * @description [japanese]
   * PCブラウザでのみ利用可能なAPI。
   * VideoStreamは常に取得される（AudioStreamのみ取得することはできない）
   * audioオプションを有効にするとAudioStreamを取得することができる。
   * audioオプションはWindowsのChromeにしか対応しておらず、
   * それ以外の環境では有効にしても戻り値のaudioにはundefinedが返される。
   */ async createDisplayStreams(options = {}) {
        const videoOption = options.video ?? {};
        videoOption.stopTrackWhenDisabled ??= true;
        let audioOption = options.audio;
        if (audioOption) {
            audioOption = typeof audioOption === "boolean" ? {} : audioOption;
            audioOption.stopTrackWhenDisabled ??= true;
        }
        options = {
            audio: audioOption,
            video: videoOption
        };
        const stream = await navigator.mediaDevices.getDisplayMedia(options);
        const [video] = stream.getVideoTracks();
        const [audio] = stream.getAudioTracks();
        if (options.audio && !audio) log.warn((0, _util.createWarnPayload)({
            operationName: "StreamFactory.createDisplayStreams",
            detail: "This client does not support device audio capture"
        }));
        const videoStream = new (0, _video.LocalVideoStream)(video, {
            ...videoOption,
            isDisplayMedia: true
        });
        videoStream._setLabel("displayVideo");
        const audioStream = audio ? new (0, _audio.LocalAudioStream)(audio, {
            ...audioOption,
            isDisplayMedia: true
        }) : undefined;
        if (audioStream) audioStream._setLabel("displayAudio");
        return {
            video: videoStream,
            audio: audioStream
        };
    }
    /**
   * @description [japanese] DataStreamを作成する
   */ async createDataStream(options = {}) {
        return new (0, _data.LocalDataStream)(options);
    }
    /**
   * @description [japanese] CameraのVideoStreamとマイクのAudioStreamを作成する
   */ async createMicrophoneAudioAndCameraStream({ audio , video  } = {}) {
        const stream = await navigator.mediaDevices.getUserMedia({
            audio: audio ?? true,
            video: video ?? true
        });
        const [audioTrack] = stream.getAudioTracks();
        const [videoTrack] = stream.getVideoTracks();
        audio = audio ?? {};
        audio.stopTrackWhenDisabled = audio.stopTrackWhenDisabled ?? true;
        const audioStream = new (0, _audio.LocalAudioStream)(audioTrack, audio);
        audioStream._setLabel("microphone");
        video = video ?? {};
        video.stopTrackWhenDisabled = video.stopTrackWhenDisabled ?? true;
        const videoStream = new (0, _video.LocalVideoStream)(videoTrack, video);
        videoStream._setLabel("camera");
        return {
            audio: audioStream,
            video: videoStream
        };
    }
    /**
   * @description [japanese] CustomVideoStreamを作成する
   */ async createCustomVideoStream(processor, options = {}) {
        options.stopTrackWhenDisabled = options.stopTrackWhenDisabled ?? true;
        const stream = new (0, _customVideo.LocalCustomVideoStream)(options);
        const processedStream = await processor.createProcessedStream({
            constraints: options.constraints ?? {},
            stopTrackWhenDisabled: options.stopTrackWhenDisabled,
            onUpdateTrack: (track)=>{
                return stream.updateTrack(track);
            }
        });
        await stream.setStream(processedStream);
        return stream;
    }
}
const SkyWayStreamFactory = new StreamFactory();
class MediaDevice {
    /**@private */ constructor(info){
        this.id = info.deviceId;
        this.label = info.label;
        this.kind = info.kind;
    }
}

},{"@skyway-sdk/common":"3hyrG","../errors":"gDbIj","../util":"ey5Lv","./stream/local/audio":"bIWhI","./stream/local/customVideo":"1Q3u4","./stream/local/data":"T39q0","./stream/local/video":"hcUYM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lWTWB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _base = require("./base");
parcelHelpers.exportAll(_base, exports);
var _local = require("./local");
parcelHelpers.exportAll(_local, exports);
var _remote = require("./remote");
parcelHelpers.exportAll(_remote, exports);

},{"./base":"6o4hs","./local":"gov7A","./remote":"du0SC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"du0SC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RemoteAudioStream", ()=>(0, _audio.RemoteAudioStream));
parcelHelpers.export(exports, "RemoteDataStream", ()=>(0, _data.RemoteDataStream));
parcelHelpers.export(exports, "RemoteMediaStreamBase", ()=>(0, _media.RemoteMediaStreamBase));
parcelHelpers.export(exports, "RemoteStreamBase", ()=>(0, _base.RemoteStreamBase));
parcelHelpers.export(exports, "RemoteVideoStream", ()=>(0, _video.RemoteVideoStream));
var _audio = require("./audio");
var _base = require("./base");
var _data = require("./data");
var _media = require("./media");
var _video = require("./video");

},{"./audio":"8TpY5","./base":"jN2dr","./data":"8kcOV","./media":"llk9G","./video":"bjaWL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"giYd5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k9reH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fgRbl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _connection = require("./connection");
parcelHelpers.exportAll(_connection, exports);
var _errors = require("./errors");
parcelHelpers.exportAll(_errors, exports);
var _forwarding = require("./forwarding");
parcelHelpers.exportAll(_forwarding, exports);
var _member = require("./member");
parcelHelpers.exportAll(_member, exports);
var _option = require("./option");
parcelHelpers.exportAll(_option, exports);
var _plugin = require("./plugin");
parcelHelpers.exportAll(_plugin, exports);
var _version = require("./version");
parcelHelpers.exportAll(_version, exports);

},{"./connection":"kXn1I","./errors":"7iQ6i","./forwarding":"5RgEB","./member":"cH6eo","./option":"kXeui","./plugin":"dgOkC","./version":"cC3mT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXn1I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "SFUConnection", ()=>SFUConnection);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _errors = require("../errors");
var _util = require("../util");
var _receiver = require("./receiver");
var _sender = require("./sender");
const log = new (0, _common.Logger)("packages/sfu-bot/src/connection/index.ts");
class SFUConnection {
    /**@internal */ constructor(_api, channel, localPerson, remoteMember, _transportRepository, _context){
        this._api = _api;
        this.channel = channel;
        this.localPerson = localPerson;
        this.remoteMember = remoteMember;
        this._transportRepository = _transportRepository;
        this._context = _context;
        this.type = "sfu";
        this.onDisconnect = new (0, _common.Event)();
        this.onClose = new (0, _common.Event)();
        this.closed = false;
        this./**@private */ _receivers = {};
        this./**@private */ _senders = {};
    }
    /**@internal */ addSender(publication) {
        const sender = new (0, _sender.Sender)(publication, this.channel, this._api, this._transportRepository, this.localPerson, this.remoteMember, this.localPerson.iceManager, this._context);
        this._senders[publication.id] = sender;
        return sender;
    }
    /**@internal */ removeSender(originPublicationId) {
        log.debug("removeSender", originPublicationId);
        const sender = this._senders[originPublicationId];
        if (!sender) return;
        sender.unproduce();
    }
    async startSubscribing(subscription) {
        const receiver = new (0, _receiver.Receiver)(subscription, this._api, this._transportRepository, this.localPerson, this.remoteMember, this.localPerson.iceManager, this._context);
        this._receivers[subscription.id] = receiver;
        const ts = log.debug("[start] _startSubscribing consume");
        const { stream , codec  } = await receiver.consume().catch((e)=>{
            log.error("[failed] _startSubscribing consume", (0, _core.createError)({
                operationName: "SFUConnection.startSubscribing",
                context: this._context,
                channel: this.channel,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "failed to receiver.consume"
                },
                error: e,
                path: log.prefix,
                payload: {
                    subscription: subscription.toJSON()
                }
            }));
            throw e;
        });
        log.elapsed(ts, "[end] _startSubscribing consume");
        stream.setIsEnabled(subscription.publication.state === "enabled");
        subscription.codec = codec;
        subscription._setStream(stream);
        if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) {
            const preferredEncoding = subscription.preferredEncoding;
            const encodings = subscription.publication.origin?.encodings;
            if (!preferredEncoding || !encodings || encodings.length === 0) return;
            const layer = (0, _util.getLayerFromEncodings)(preferredEncoding, encodings);
            this.localPerson._analytics.client.sendSubscriptionUpdatePreferredEncodingReport({
                subscriptionId: subscription.id,
                preferredEncodingIndex: layer,
                updatedAt: Date.now()
            });
        }
    }
    /**@internal */ async stopSubscribing(subscription) {
        const connection = this._receivers[subscription.id];
        if (!connection) return;
        connection.unconsume();
    }
    /**@internal */ async stopPublishing(publication) {
        this.removeSender(publication.id);
    }
    /**@internal */ close({ reason  } = {}) {
        if (this.closed) return;
        log.debug("close sfu connection", {
            remote: this.remoteMember,
            local: this.localPerson,
            reason
        });
        this.closed = true;
        Object.values(this._senders).forEach((sender)=>{
            sender.close();
        });
        Object.values(this._receivers).forEach((receiver)=>{
            receiver.close();
        });
        this._senders = {};
        this._receivers = {};
        this.onClose.emit();
    }
    _getReceiver(subscriptionId) {
        return this._receivers[subscriptionId];
    }
    async changePreferredEncoding(subscription) {
        const preferredEncoding = subscription.preferredEncoding;
        const encodings = subscription.publication.origin?.encodings;
        log.debug("changePreferredEncoding", {
            preferredEncoding,
            encodings,
            subscription
        });
        if (!preferredEncoding) throw (0, _core.createError)({
            operationName: "SFUConnection.changePreferredEncoding",
            context: this._context,
            channel: this.channel,
            info: (0, _errors.errors).invalidPreferredEncoding,
            path: log.prefix,
            payload: {
                subscription
            }
        });
        if (!encodings || encodings.length === 0) throw (0, _core.createError)({
            operationName: "SFUConnection.changePreferredEncoding",
            context: this._context,
            channel: this.channel,
            info: (0, _errors.errors).invalidEncodings,
            path: log.prefix,
            payload: {
                subscription
            }
        });
        const layer = (0, _util.getLayerFromEncodings)(preferredEncoding, encodings);
        const receiver = this._getReceiver(subscription.id);
        if (!receiver) throw (0, _core.createError)({
            operationName: "SFUConnection.changePreferredEncoding",
            context: this._context,
            channel: this.channel,
            info: (0, _errors.errors).receiverNotFound,
            path: log.prefix,
            payload: {
                subscription
            }
        });
        const transport = receiver.transport;
        if (!transport) throw (0, _core.createError)({
            operationName: "SFUConnection.changePreferredEncoding",
            context: this._context,
            channel: this.channel,
            info: {
                ...(0, _errors.errors).internal,
                detail: "transport not found"
            },
            path: log.prefix,
            payload: {
                subscription
            }
        });
        const consumer = receiver.consumer;
        if (!consumer) throw (0, _core.createError)({
            operationName: "SFUConnection.changePreferredEncoding",
            context: this._context,
            channel: this.channel,
            info: (0, _errors.errors).consumerNotFound,
            path: log.prefix,
            payload: {
                subscription
            }
        });
        await this._api.changeConsumerLayer({
            transportId: transport.id,
            consumerId: consumer.id,
            publicationId: subscription.publication.id,
            spatialLayer: layer
        });
        if (this.localPerson._analytics && !this.localPerson._analytics.isClosed()) this.localPerson._analytics.client.sendSubscriptionUpdatePreferredEncodingReport({
            subscriptionId: subscription.id,
            preferredEncodingIndex: layer,
            updatedAt: Date.now()
        });
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","../errors":"7iQ6i","../util":"57OJM","./receiver":"cgzj1","./sender":"9P4qq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7iQ6i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errors", ()=>errors);
var _sfuApiClient = require("@skyway-sdk/sfu-api-client");
const errors = {
    ...(0, _sfuApiClient.errors),
    invalidParameter: {
        name: "invalidParameter",
        detail: "",
        solution: ""
    },
    timeout: {
        name: "timeout",
        detail: "",
        solution: ""
    },
    internal: {
        name: "internal",
        detail: "",
        solution: ""
    },
    sfuBotNotInChannel: {
        name: "sfuBotNotInChannel",
        detail: "SfuBotがChannelに存在しません",
        solution: "操作しようとしているSfuBotが正しいか確かめてください"
    },
    maxSubscribersMustNotBeZero: {
        name: "maxSubscribersMustNotBeZero",
        detail: "maxSubscribersは１以上である必要があります",
        solution: "正しい値を入力してください"
    },
    remotePublisherId: {
        name: "remotePublisherId",
        detail: "publisherがremoteのPublicationをForwardingすることはできません",
        solution: "PublicationがLocalでPublishされたものか確かめてください"
    },
    dataStreamNotSupported: {
        name: "dataStreamNotSupported",
        detail: "dataStreamはSFUに対応していません",
        solution: "ありません"
    },
    streamNotExistInPublication: {
        name: "streamNotExistInPublication",
        detail: "PublicationにStreamがありません。RemoteMemberのPublicationのStreamにはアクセスできません",
        solution: "参照しているPublicationが目的のものか確かめてください。"
    },
    invalidPreferredEncoding: {
        name: "invalidPreferredEncoding",
        detail: "preferredEncodingの値が不正です。エンコード設定切り替え機能が使えません",
        solution: "正しい文字列を入力してください"
    },
    invalidEncodings: {
        name: "invalidEncodings",
        detail: "エンコード設定が設定されていません。エンコード設定切り替え機能が使えません",
        solution: "エンコード設定切り替え機能を利用する場合はエンコード設定をしたPublicationをForwardingしてください"
    },
    receiverNotFound: {
        name: "receiverNotFound",
        detail: "SFUはRemoteMemberのSubscriptionを操作できません",
        solution: "SFUでsubscriptionの操作をする際にはLocalPersonがSubscribeしているSubscriptionインスタンスを利用してください"
    },
    consumerNotFound: {
        name: "consumerNotFound",
        detail: "SFUはLocalPersonがUnsubscribeしたSubscriptionを操出来ません",
        solution: "操作対象のSubscriptionが正しいか確かめてください"
    },
    forwardingNotFound: {
        name: "forwardingNotFound",
        detail: "存在しないForwardingを操作しようとしています",
        solution: "対象のForwardingが正しいか確かめてください"
    },
    netWorkError: {
        name: "netWorkError",
        detail: "通信環境に問題があります",
        solution: "ネットワーク接続状況を確認してください"
    },
    confirmSubscriptionFailed: {
        name: "confirmSubscriptionFailed",
        detail: "Forwardingのconsume許可を出すのに失敗しました",
        solution: "ありません"
    }
};

},{"@skyway-sdk/sfu-api-client":"bSWdL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSWdL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _api = require("./api");
parcelHelpers.exportAll(_api, exports);
var _const = require("./const");
parcelHelpers.exportAll(_const, exports);
var _errors = require("./errors");
parcelHelpers.exportAll(_errors, exports);

},{"./api":"cvsWE","./const":"aWjfw","./errors":"eImEv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cvsWE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SfuRestApiClient", ()=>SfuRestApiClient);
var _common = require("@skyway-sdk/common");
var _const = require("./const");
var _errors = require("./errors");
var _util = require("./util");
const log = new (0, _common.Logger)("packages/sfu-api-client/src/api.ts");
class SfuRestApiClient {
    constructor(_token, _options){
        this._token = _token;
        this._headers = {
            authorization: `Bearer ${this._token}`
        };
        this.options = {
            ...(0, _const.defaultSfuApiOptions),
            ..._options
        };
        this.endpoint = `http${this.options.secure ? "s" : ""}://${this.options.domain}/v${this.options.version}`;
        this.http = new (0, _common.HttpClient)(this.endpoint);
        (0, _common.Logger).level = this.options.log.level;
        (0, _common.Logger).format = this.options.log.format;
        log.debug("SfuRestApiClient spawned", {
            endpoint: this.endpoint
        });
    }
    updateToken(token) {
        this._token = token;
    }
    _commonErrorHandler(e, operationName) {
        switch(e?.status){
            case 401:
                return (0, _util.createError)({
                    operationName,
                    info: (0, _errors.errors).invalidRequestParameter,
                    path: log.prefix,
                    payload: e
                });
            case 403:
                return (0, _util.createError)({
                    operationName,
                    info: (0, _errors.errors).insufficientPermissions,
                    path: log.prefix,
                    payload: e
                });
            case 404:
                return (0, _util.createError)({
                    operationName,
                    info: (0, _errors.errors).notFound,
                    path: log.prefix,
                    payload: e
                });
            case 429:
                return (0, _util.createError)({
                    operationName,
                    info: (0, _errors.errors).quotaExceededError,
                    path: log.prefix,
                    payload: e
                });
            default:
                return (0, _util.createError)({
                    operationName,
                    info: (0, _errors.errors).backendError,
                    path: log.prefix,
                    payload: e
                });
        }
    }
    async createBot({ appId , channelId  }) {
        const res = await this.http.post("/bots", {
            appId,
            channelId
        }, {
            headers: {
                authorization: `Bearer ${this._token}`
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.createBot");
        });
        return res.id;
    }
    async deleteBot({ botId  }) {
        await this.http.delete(`/bots/${botId}`, {
            headers: {
                authorization: `Bearer ${this._token}`
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.deleteBot");
        });
    }
    async startForwarding({ botId , publicationId , maxSubscribers , contentType , publisherId  }) {
        const backOff = new (0, _common.BackOff)();
        const body = {
            publicationId,
            maxSubscribers,
            contentType: contentType[0].toUpperCase() + contentType.slice(1),
            publisherId
        };
        const res = await this.http.post(`/bots/${botId}/forwardings`, body, {
            headers: {
                authorization: `Bearer ${this._token}`
            },
            retry: async (err)=>{
                if ([
                    400,
                    403,
                    429
                ].includes(err.status)) return false;
                return await backOff.wait();
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.startForwarding");
        });
        if (backOff.count > 0) log.warn("success to retry startForwarding", (0, _util.createWarnPayload)({
            operationName: "SfuRestApiClient.startForwarding",
            detail: "success to retry startForwarding",
            botId,
            memberId: publisherId,
            payload: {
                publicationId,
                count: backOff.count
            }
        }));
        return res;
    }
    async createProducer({ botId , forwardingId , transportId , producerOptions  }) {
        const backOff = new (0, _common.BackOff)();
        const res = await this.http.put(`/bots/${botId}/forwardings/${forwardingId}/transports/producers`, {
            transportId,
            producerOptions
        }, {
            headers: {
                authorization: `Bearer ${this._token}`
            },
            retry: async ()=>{
                return await backOff.wait();
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.createProducer");
        });
        if (backOff.count > 0) log.warn("success to retry createProducer", (0, _util.createWarnPayload)({
            operationName: "SfuRestApiClient.createProducer",
            detail: "success to retry createProducer",
            botId,
            payload: {
                forwardingId,
                transportId,
                count: backOff.count
            }
        }));
        return res;
    }
    /**@throws {maxSubscriberExceededError,} */ async createConsumer({ botId , forwardingId , rtpCapabilities , subscriptionId , subscriberId , spatialLayer , originPublicationId  }) {
        const backOff = new (0, _common.BackOff)({
            times: 5,
            interval: 100
        }); // 5.5sec
        const requestPayload = {
            rtpCapabilities,
            subscriptionId,
            subscriberId,
            spatialLayer,
            originPublicationId
        };
        const res = await this.http.post(`/bots/${botId}/forwardings/${forwardingId}/transports/consumers`, requestPayload, {
            retry: async (err)=>{
                if ([
                    400,
                    403,
                    //  404,
                    429
                ].includes(err.status)) return false;
                return await backOff.wait();
            },
            headers: {
                authorization: `Bearer ${this._token}`
            }
        }).catch((e)=>{
            if (e.status === 429) throw (0, _util.createError)({
                operationName: "SfuRestApiClient.createConsumer",
                info: (0, _errors.errors).maxSubscriberExceededError,
                path: log.prefix,
                payload: e
            });
            else if (e.status === 403) throw (0, _util.createError)({
                operationName: "SfuRestApiClient.createConsumer",
                info: (0, _errors.errors).notAllowedConsumeError,
                path: log.prefix,
                payload: e
            });
            else throw this._commonErrorHandler(e, "SfuRestApiClient.createConsumer");
        });
        if (backOff.count > 0) log.warn("success to retry createConsumer", (0, _util.createWarnPayload)({
            operationName: "SfuRestApiClient.createConsumer",
            detail: "success to retry createConsumer",
            botId,
            payload: {
                forwardingId,
                count: backOff.count
            }
        }));
        log.debug("response of createConsumer", res);
        return res;
    }
    async connect({ transportId , dtlsParameters  }) {
        const backOff = new (0, _common.BackOff)();
        const body = {
            transportId,
            dtlsParameters
        };
        const res = await this.http.put(`/transports/connections`, body, {
            headers: {
                authorization: `Bearer ${this._token}`
            },
            retry: async ()=>{
                return await backOff.wait();
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.connect");
        });
        if (backOff.count > 0) log.warn("success to retry connect", (0, _util.createWarnPayload)({
            operationName: "SfuRestApiClient.connect",
            detail: "success to retry connect",
            payload: {
                transportId,
                count: backOff.count
            }
        }));
        return res;
    }
    async changeConsumerLayer({ transportId , consumerId , spatialLayer , publicationId  }) {
        const res = await this.http.put(`transports/consumers/${consumerId}/layers`, {
            transportId,
            spatialLayer,
            publicationId
        }, {
            headers: {
                authorization: `Bearer ${this._token}`
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.changeConsumerLayer");
        });
        return res;
    }
    stopForwarding({ botId , forwardingId  }) {
        let fulfilled = false;
        const promise = this.http.delete(`/bots/${botId}/forwardings/${forwardingId}`, {
            headers: {
                authorization: `Bearer ${this._token}`
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.stopForwarding");
        }).then((res)=>{
            fulfilled = res;
        });
        return {
            promise,
            fulfilled
        };
    }
    async iceRestart({ transportId  }) {
        const res = await this.http.put(`/transports/connections/ice`, {
            transportId
        }, {
            headers: this._headers
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.iceRestart");
        });
        return res.iceParameters;
    }
    async getRtpCapabilities({ botId , forwardingId , originPublicationId  }) {
        const backOff = new (0, _common.BackOff)();
        const res = await this.http.get(`/bots/${botId}/forwardings/${forwardingId}/transports/rtp-capabilities?originPublicationId=${originPublicationId}`, {
            headers: {
                authorization: `Bearer ${this._token}`
            },
            retry: async ()=>{
                return await backOff.wait();
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.getRtpCapabilities");
        });
        if (backOff.count > 0) log.warn("getCapabilities to retry connect", (0, _util.createWarnPayload)({
            operationName: "SfuRestApiClient.getRtpCapabilities",
            detail: "getCapabilities to retry connect",
            botId,
            payload: {
                forwardingId,
                count: backOff.count
            }
        }));
        return res.rtpCapabilities;
    }
    async confirmSubscription({ forwardingId , subscriptionId , identifierKey  }) {
        const requestPayload = {
            forwardingId,
            subscriptionId,
            identifierKey
        };
        const res = await this.http.post("/confirm-subscription", requestPayload, {
            headers: {
                authorization: `Bearer ${this._token}`
            }
        }).catch((e)=>{
            throw this._commonErrorHandler(e, "SfuRestApiClient.confirmSubscription");
        });
        log.debug("response of confirmSubscription", res);
        return res;
    }
}

},{"@skyway-sdk/common":"3hyrG","./const":"aWjfw","./errors":"eImEv","./util":"9nDL8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aWjfw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultSfuApiOptions", ()=>defaultSfuApiOptions);
const defaultSfuApiOptions = {
    domain: "sfu.skyway.ntt.com",
    secure: true,
    version: 4
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eImEv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errors", ()=>errors);
const errors = {
    invalidParameter: {
        name: "invalidParameter",
        detail: "",
        solution: ""
    },
    invalidRequestParameter: {
        name: "invalidRequestParameter",
        detail: "リクエストの値が不正です",
        solution: "正しい値を入力してください"
    },
    notFound: {
        name: "notFound",
        detail: "対象のリソースが見つかりません",
        solution: "対象のリソースが存在するか確かめてください"
    },
    maxSubscriberExceededError: {
        name: "maxSubscribersExceededError",
        detail: "forwardingのmaxSubscribersの制限を超えています。maxSubscribersの値を超えてSubscribeすることはできません",
        solution: "maxSubscribersの範囲内でご利用ください"
    },
    quotaExceededError: {
        name: "quotaExceededError",
        detail: "リソースの制限量を超えてリソースを利用することはできません",
        solution: "リソース制限量の範囲内でご利用ください"
    },
    timeout: {
        name: "timeout",
        detail: "",
        solution: ""
    },
    insufficientPermissions: {
        name: "insufficientPermissions",
        detail: "tokenの権限が不足しています",
        solution: "tokenに必要な権限を付与してください"
    },
    backendError: {
        name: "backendError:",
        detail: "",
        solution: ""
    },
    notAllowedConsumeError: {
        name: "notAllowedConsumeError",
        detail: "ForwardingからのConsume許可がありません",
        solution: "Forwardingしているmemberによる許可操作が必要です"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9nDL8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createError", ()=>createError);
parcelHelpers.export(exports, "createWarnPayload", ()=>createWarnPayload);
var _common = require("@skyway-sdk/common");
function createError({ operationName , info , error , path , payload  }) {
    return new (0, _common.SkyWayError)({
        error,
        info: info,
        payload: {
            payload,
            operationName
        },
        path
    });
}
function createWarnPayload({ appId , detail , channelId , operationName , payload , memberId , botId  }) {
    const warn = {
        operationName,
        payload,
        detail,
        appId,
        channelId,
        memberId,
        botId
    };
    return warn;
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"57OJM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getLayerFromEncodings", ()=>getLayerFromEncodings);
parcelHelpers.export(exports, "moveToHead", ()=>moveToHead);
parcelHelpers.export(exports, "createWarnPayload", ()=>createWarnPayload);
function getLayerFromEncodings(id, encodings) {
    let layer = 0;
    for(; layer < encodings.length; layer++){
        const encoding = encodings[layer];
        if (encoding.id === id) break;
    }
    return layer;
}
function moveToHead(arr, selector) {
    const target = arr.find(selector);
    return [
        target,
        ...arr.filter((o)=>!selector(o))
    ];
}
function createWarnPayload({ channel , detail , operationName , payload , bot  }) {
    const warn = {
        operationName,
        payload,
        detail
    };
    if (channel) {
        warn["appId"] = channel.appId;
        warn["channelId"] = channel.id;
        if (channel.localPerson) warn["memberId"] = channel.localPerson.id;
    }
    if (bot) {
        warn["botId"] = bot.id;
        warn["appId"] = bot.channel.appId;
        warn["channelId"] = bot.channel.id;
        warn["memberId"] = bot.channel.localPerson?.id;
    }
    return warn;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgzj1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Receiver", ()=>Receiver);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _errors = require("../errors");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/sfu-bot/src/connection/receiver.ts");
class Receiver {
    constructor(subscription, _api, _transportRepository, _localPerson, _bot, _iceManager, _context){
        this.subscription = subscription;
        this._api = _api;
        this._transportRepository = _transportRepository;
        this._localPerson = _localPerson;
        this._bot = _bot;
        this._iceManager = _iceManager;
        this._context = _context;
        this._disposer = new (0, _common.EventDisposer)();
        this.sendSubscriptionStatsReportTimer = null;
        this._waitingSendSubscriptionStatsReports = [];
        const analyticsSession = this._localPerson._analytics;
        if (analyticsSession) analyticsSession.onConnectionStateChanged.add((state)=>{
            if (state === "connected" && this._waitingSendSubscriptionStatsReports.length > 0) {
                for (const consumerId of this._waitingSendSubscriptionStatsReports)if (this.consumer && this.consumer.id === consumerId) this.startSendSubscriptionStatsReportTimer();
                this._waitingSendSubscriptionStatsReports = [];
            }
        });
    }
    toJSON() {
        return {
            transport: this.transport,
            subscription: this.subscription
        };
    }
    /**@throws {maxSubscriberExceededError} */ async consume() {
        let rtpCapabilities = this._transportRepository.rtpCapabilities;
        if (!rtpCapabilities) {
            log.debug("[start] getCapabilities");
            rtpCapabilities = await this._api.getRtpCapabilities({
                botId: this._bot.id,
                forwardingId: this.subscription.publication.id,
                originPublicationId: this.subscription.publication.origin.id
            });
            log.debug("[end] getCapabilities");
            await this._transportRepository.loadDevice(rtpCapabilities).catch((e)=>{
                throw (0, _core.createError)({
                    operationName: "Receiver.consume",
                    context: this._context,
                    channel: this._localPerson.channel,
                    info: {
                        ...(0, _errors.errors).internal,
                        detail: "sfu loadDevice failed"
                    },
                    path: log.prefix,
                    error: e
                });
            });
        }
        const spatialLayer = this.subscription.preferredEncoding ? (0, _util.getLayerFromEncodings)(this.subscription.preferredEncoding, this.subscription.publication.origin?.encodings ?? []) : undefined;
        log.debug("[start] createConsumer", {
            subscription: this.subscription
        });
        const { consumerOptions , transportOptions , transportId , producerId  } = await this._api.createConsumer({
            botId: this._bot.id,
            forwardingId: this.subscription.publication.id,
            rtpCapabilities,
            subscriptionId: this.subscription.id,
            subscriberId: this.subscription.subscriber.id,
            spatialLayer,
            originPublicationId: this.subscription.publication.origin.id
        });
        if (transportOptions) this._transportRepository.createTransport(this._localPerson.id, this._bot, transportOptions, "recv", this._iceManager, this._localPerson._analytics);
        this.transport = this._transportRepository.getTransport(this._localPerson.id, transportId);
        if (!this.transport) {
            log.warn("transport is under race condition", {
                transportId
            });
            await this._transportRepository.onTransportCreated.watch((id)=>id === transportId, this._bot.options.endpointTimeout).catch((e)=>{
                throw (0, _core.createError)({
                    operationName: "Receiver.consume",
                    context: this._context,
                    channel: this._localPerson.channel,
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "receiver sfuTransport not found"
                    },
                    path: log.prefix,
                    error: e,
                    payload: {
                        transportOptions,
                        transportId,
                        producerId,
                        consumerOptions,
                        subscription: this.subscription
                    }
                });
            });
            this.transport = this._transportRepository.getTransport(this._localPerson.id, transportId);
        }
        if (this._localPerson._analytics && !this._localPerson._analytics.isClosed()) this._localPerson._analytics.client.sendBindingRtcPeerConnectionToSubscription({
            subscriptionId: this.subscription.id,
            role: "receiver",
            rtcPeerConnectionId: this.transport.id
        });
        log.debug("[end] createConsumer");
        log.debug("[start] consume", {
            consumerOptions,
            subscription: this.subscription
        });
        const consumer = await this.transport.msTransport.consume({
            ...consumerOptions,
            producerId
        }).catch((e)=>{
            throw (0, _core.createError)({
                operationName: "Receiver.consume",
                context: this._context,
                channel: this._localPerson.channel,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "consume failed, maybe subscribing unsupported codec"
                },
                path: log.prefix,
                error: e
            });
        });
        this.consumer = consumer;
        log.debug("[end] consume", {
            subscription: this.subscription
        });
        const [selectedCodec] = consumer.rtpParameters.codecs;
        const stream = (0, _core.createRemoteStream)((0, _core.uuidV4)(), consumer.track, selectedCodec);
        const codec = {
            mimeType: selectedCodec.mimeType,
            parameters: selectedCodec.parameters
        };
        this._setupTransportAccessForStream(stream, consumer);
        const analyticsSession = this._localPerson._analytics;
        if (analyticsSession && !analyticsSession.isClosed()) {
            if (analyticsSession.client.isConnectionEstablished()) this.startSendSubscriptionStatsReportTimer();
            else // AnalyticsServerに初回接続できなかった場合はキューに入れる
            this._waitingSendSubscriptionStatsReports.push(consumer.id);
        }
        return {
            stream,
            codec
        };
    }
    _setupTransportAccessForStream(stream, consumer) {
        const transport = this.transport;
        const pc = this.pc;
        stream._getTransport = ()=>({
                rtcPeerConnection: pc,
                connectionState: transport.connectionState,
                info: this
            });
        stream._getStats = async ()=>{
            const stats = await consumer.getStats();
            let arr = (0, _core.statsToArray)(stats);
            arr = arr.map((stats)=>{
                stats["sfuTransportId"] = transport.id;
                return stats;
            });
            return arr;
        };
        this._disposer.push(()=>{
            stream._getTransport = ()=>undefined;
        });
        transport.onConnectionStateChanged.add((state)=>{
            log.debug("transport connection state changed", transport.id, state);
            stream._setConnectionState(state);
        });
    }
    unconsume() {
        if (!this.consumer) {
            log.debug("unconsume failed, consumer not exist", {
                subscription: this.subscription
            });
            return;
        }
        this.consumer.close();
        this.consumer = undefined;
        if (this.sendSubscriptionStatsReportTimer) clearInterval(this.sendSubscriptionStatsReportTimer);
    }
    close() {
        this._disposer.dispose();
    }
    get pc() {
        return this.transport?.pc;
    }
    startSendSubscriptionStatsReportTimer() {
        const analyticsSession = this._localPerson._analytics;
        if (analyticsSession) {
            const intervalSec = analyticsSession.client.getIntervalSec();
            this.sendSubscriptionStatsReportTimer = setInterval(async ()=>{
                // AnalyticsSessionがcloseされていたらタイマーを止める
                if (!analyticsSession || analyticsSession.isClosed()) {
                    if (this.sendSubscriptionStatsReportTimer) clearInterval(this.sendSubscriptionStatsReportTimer);
                    return;
                }
                if (this.consumer) {
                    const stats = await this.consumer.getStats();
                    if (stats) analyticsSession.client.sendSubscriptionStatsReport(stats, {
                        subscriptionId: this.subscription.id,
                        role: "receiver",
                        createdAt: Date.now()
                    });
                }
            }, intervalSec * 1000);
        }
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","../errors":"7iQ6i","../util":"57OJM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9P4qq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Sender", ()=>Sender);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _isEqual = require("lodash/isEqual");
var _isEqualDefault = parcelHelpers.interopDefault(_isEqual);
var _errors = require("../errors");
var _forwarding = require("../forwarding");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/sfu-bot/src/connection/sender.ts");
class Sender {
    constructor(publication, channel, _api, _transportRepository, _localPerson, _bot, _iceManager, _context){
        this.publication = publication;
        this.channel = channel;
        this._api = _api;
        this._transportRepository = _transportRepository;
        this._localPerson = _localPerson;
        this._bot = _bot;
        this._iceManager = _iceManager;
        this._context = _context;
        this._disposer = new (0, _common.EventDisposer)();
        this._connectionState = "new";
        this.onConnectionStateChanged = new (0, _common.Event)();
        this.closed = false;
        this.sendSubscriptionStatsReportTimer = null;
        this._waitingSendSubscriptionStatsReports = [];
        const analyticsSession = this._localPerson._analytics;
        if (analyticsSession) // AnalyticsServerに初回接続できなかった場合のタイマー再セット処理
        analyticsSession.onConnectionStateChanged.add((state)=>{
            if (state === "connected" && this._waitingSendSubscriptionStatsReports.length > 0) {
                for (const producerId of this._waitingSendSubscriptionStatsReports)if (this._producer && this._producer.id === producerId) this.startSendSubscriptionStatsReportTimer();
                this._waitingSendSubscriptionStatsReports = [];
            }
        });
    }
    _setConnectionState(state) {
        if (this._connectionState === state) return;
        log.debug("_setConnectionState", {
            state,
            forwardingId: this.forwardingId
        });
        this._connectionState = state;
        this.onConnectionStateChanged.emit(state);
    }
    toJSON() {
        return {
            forwarding: this.forwarding,
            broadcasterTransport: this._broadcasterTransport,
            _connectionState: this._connectionState
        };
    }
    /**@throws {SkyWayError} */ async startForwarding(configure) {
        if (this.publication.contentType === "data") throw (0, _core.createError)({
            operationName: "Sender.startForwarding",
            context: this._context,
            info: (0, _errors.errors).dataStreamNotSupported,
            path: log.prefix,
            channel: this.channel
        });
        const stream = this.publication.stream;
        if (!stream) throw (0, _core.createError)({
            operationName: "Sender.startForwarding",
            context: this._context,
            info: (0, _errors.errors).streamNotExistInPublication,
            path: log.prefix,
            channel: this.channel
        });
        this.onConnectionStateChanged.add((state)=>{
            log.debug("transport connection state changed", this._broadcasterTransport?.id, state);
            stream._setConnectionState(this._bot, state);
        }).disposer(this._disposer);
        log.debug("[start] Sender startForwarding", {
            botId: this._bot.id,
            publicationId: this.publication.id,
            contentType: this.publication.contentType,
            maxSubscribers: configure.maxSubscribers
        });
        const { forwardingId , broadcasterTransportId , // optional
        broadcasterTransportOptions , rtpCapabilities , identifierKey  } = await this._api.startForwarding({
            botId: this._bot.id,
            publicationId: this.publication.id,
            contentType: this.publication.contentType,
            maxSubscribers: configure.maxSubscribers,
            publisherId: this.publication.publisher.id
        });
        this.forwardingId = forwardingId;
        if (broadcasterTransportOptions) {
            log.debug("sender create new transport", {
                broadcasterTransportOptions
            });
            await this._transportRepository.loadDevice(rtpCapabilities);
            this._broadcasterTransport = this._transportRepository.createTransport(this._localPerson.id, this._bot, broadcasterTransportOptions, "send", this._iceManager, this._localPerson._analytics);
        }
        this._broadcasterTransport = this._transportRepository.getTransport(this._localPerson.id, broadcasterTransportId);
        if (!this._broadcasterTransport) throw (0, _core.createError)({
            operationName: "Sender.startForwarding",
            context: this._context,
            info: {
                ...(0, _errors.errors).internal,
                detail: "_broadcasterTransport not found"
            },
            path: log.prefix,
            channel: this.channel,
            payload: {
                broadcasterTransportOptions
            }
        });
        this._broadcasterTransport.onConnectionStateChanged.add((state)=>{
            this._setConnectionState(state);
        }).disposer(this._disposer);
        this._setConnectionState(this._broadcasterTransport.connectionState);
        const producer = await this._produce(stream, this._broadcasterTransport);
        this._cleanupStreamCallbacks = this._setupTransportAccessForStream(stream, this._broadcasterTransport, producer);
        const analyticsSession = this._localPerson._analytics;
        if (analyticsSession && !analyticsSession.isClosed()) {
            if (analyticsSession.client.isConnectionEstablished()) this.startSendSubscriptionStatsReportTimer();
            else // AnalyticsServerに初回接続できなかった場合はキューに入れる
            this._waitingSendSubscriptionStatsReports.push(producer.id);
        }
        log.debug("[end] Sender startForwarding", {
            forwardingId
        });
        let relayingPublication = this.channel._getPublication(forwardingId);
        if (!relayingPublication) relayingPublication = (await this.channel.onStreamPublished.watch((e)=>e.publication.id === forwardingId, this._context.config.rtcApi.timeout).catch(()=>{
            throw (0, _core.createError)({
                operationName: "Sender.startForwarding",
                context: this._context,
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "SfuBotMember onStreamPublished"
                },
                path: log.prefix,
                channel: this.channel,
                payload: {
                    forwardingId
                }
            });
        })).publication;
        const forwarding = new (0, _forwarding.Forwarding)({
            configure,
            originPublication: this.publication,
            relayingPublication,
            api: this._api,
            context: this._context,
            identifierKey
        });
        this.forwarding = forwarding;
        const botSubscribing = this.channel.subscriptions.find((s)=>s.publication.id === this.publication.id);
        const [codec] = producer.rtpParameters.codecs;
        botSubscribing.codec = codec;
        if (this._localPerson._analytics && this._localPerson._analytics.client.connectionState !== "closed") this._localPerson._analytics.client.sendBindingRtcPeerConnectionToSubscription({
            subscriptionId: botSubscribing.id,
            role: "sender",
            rtcPeerConnectionId: this._broadcasterTransport.id
        });
        if ((0, _core.isSafari)()) (0, _core.waitForLocalStats)({
            stream,
            remoteMember: this._bot.id,
            end: (stats)=>{
                const outbound = stats.find((s)=>s.id.includes("RTCOutboundRTP") || s.type.includes("outbound-rtp"));
                if (outbound?.keyFramesEncoded > 0) return true;
                return false;
            },
            interval: 10
        }).then(async ()=>{
            const encodings = this.publication.encodings;
            if (encodings?.length > 0) await (0, _core.setEncodingParams)(producer.rtpSender, encodings).catch((e)=>{
                log.error("_onEncodingsChanged failed", e, this);
            });
        }).catch((err)=>{
            log.error("setEncodingParams waitForLocalStats failed", err, this);
        });
        (0, _core.waitForLocalStats)({
            stream,
            remoteMember: this._bot.id,
            end: (stats)=>!!stats.find((s)=>s.type.includes("local-candidate"))
        }).then(async ()=>{
            const payload = await (0, _core.createLogPayload)({
                operationName: "startForwarding/waitForLocalStats",
                channel: this.channel
            });
            log.debug(payload, "forwarding connection connected", {
                broadcasterTransportId
            });
        }).catch(()=>{});
        return forwarding;
    }
    _listenStreamEnableChange(stream) {
        if (this._unsubscribeStreamEnableChange) this._unsubscribeStreamEnableChange();
        const { removeListener  } = stream._onEnableChanged.add(async (track)=>{
            await this._replaceTrack(track).catch((e)=>{
                log.warn((0, _util.createWarnPayload)({
                    detail: "replaceTrack failed",
                    operationName: "Sender._listenStreamEnableChange",
                    bot: this._bot,
                    payload: e
                }));
            });
        });
        this._unsubscribeStreamEnableChange = removeListener;
    }
    async _produce(stream, transport) {
        this.publication._onReplaceStream.add(async ({ newStream  })=>{
            if (!this._broadcasterTransport) throw (0, _core.createError)({
                operationName: "Sender._produce",
                context: this._context,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "_broadcasterTransport not found"
                },
                path: log.prefix,
                channel: this.channel
            });
            this._listenStreamEnableChange(newStream);
            if (this._cleanupStreamCallbacks) this._cleanupStreamCallbacks();
            this._cleanupStreamCallbacks = this._setupTransportAccessForStream(newStream, this._broadcasterTransport, producer);
            await this._replaceTrack(newStream.track);
        }).disposer(this._disposer);
        this._listenStreamEnableChange(stream);
        const transactionId = (0, _core.uuidV4)();
        const producerOptions = {
            track: stream.track,
            // mediasoup-clientはデフォルトでunproduce時にtrack.stopを実行する
            stopTracks: false,
            appData: {
                transactionId
            },
            // デフォルトで一度mutedなTrackをProduceするとreplaceTrackしたTrackがDisableされる
            disableTrackOnPause: false
        };
        const encodings = this.publication.encodings;
        if (encodings) producerOptions.encodings = encodings;
        this.publication._onEncodingsChanged.add(async (encodings)=>{
            await (0, _core.setEncodingParams)(producer.rtpSender, encodings).catch((e)=>{
                log.error("_onEncodingsChanged failed", e, this);
            });
        }).disposer(this._disposer);
        const codecCapabilities = this.publication.codecCapabilities;
        const deviceCodecs = this._transportRepository.rtpCapabilities?.codecs ?? [];
        log.debug("select codec", {
            codecCapabilities,
            deviceCodecs
        });
        const [codec] = codecCapabilities.map((cap)=>{
            if (cap.mimeType.toLowerCase().includes("video")) {
                const codec = deviceCodecs.find((c)=>{
                    if (c.mimeType.toLowerCase() !== cap.mimeType.toLowerCase()) return false;
                    if (Object.keys(cap.parameters ?? {}).length > 0 && !(0, _isEqualDefault.default)(cap.parameters, c.parameters)) return false;
                    return true;
                });
                return codec;
            }
            const codec = deviceCodecs.find((c)=>c.mimeType.toLowerCase() === cap.mimeType.toLowerCase());
            return codec;
        });
        log.debug("selected codec", {
            codec
        });
        if (codec) {
            const [codecType, codecName] = codec.mimeType.split("/");
            producerOptions.codec = {
                ...codec,
                mimeType: `${codecType}/${codecName.toUpperCase()}`
            };
            if (stream.contentType === "video") this._fixVideoCodecWithParametersOrder(codec);
        } else if (codecCapabilities.length > 0) log.warn("preferred codec not supported", (0, _util.createWarnPayload)({
            channel: this.channel,
            detail: "preferred codec not supported",
            operationName: "Sender._produce",
            bot: this._bot,
            payload: {
                codecCapabilities,
                deviceCodecs
            }
        }));
        if (stream.contentType === "audio") {
            // apply opusDtx
            const opusDtx = codecCapabilities.find((c)=>c.mimeType.toLowerCase() === "audio/opus")?.parameters?.usedtx;
            if (opusDtx !== false) producerOptions.codecOptions = {
                ...producerOptions.codecOptions,
                opusDtx: true
            };
            // apply opusStereo
            const opusStereo = codecCapabilities.find((c)=>c.mimeType.toLowerCase() === "audio/opus")?.parameters?.stereo;
            if (opusStereo) producerOptions.codecOptions = {
                ...producerOptions.codecOptions,
                opusStereo: true
            };
            // apply opusFec
            const opusFec = codecCapabilities.find((c)=>c.mimeType.toLowerCase() === "audio/opus")?.parameters?.useinbandfec;
            if (opusFec) producerOptions.codecOptions = {
                ...producerOptions.codecOptions,
                opusFec: true
            };
        }
        transport.onProduce.watch((p)=>p.producerOptions.appData?.transactionId === transactionId, this._context.config.rtcConfig.timeout).then(async (producer)=>{
            try {
                const { producerId  } = await this._api.createProducer({
                    botId: this._bot.id,
                    transportId: transport.id,
                    forwardingId: this.forwardingId,
                    producerOptions: producer.producerOptions
                });
                producer.callback({
                    id: producerId
                });
            } catch (error) {
                producer.errback(error);
            }
        }).catch((e)=>{
            log.error("onProduce failed", e, this);
        });
        log.debug("[start] msTransport.produce", this);
        const producer = await transport.msTransport.produce(producerOptions).catch((err)=>{
            throw (0, _core.createError)({
                operationName: "Sender._produce",
                context: this._context,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "msTransport.produce failed"
                },
                path: log.prefix,
                channel: this.channel,
                error: err
            });
        });
        log.debug("[end] msTransport.produce", this);
        this._producer = producer;
        return producer;
    }
    /** @description 引数のParametersを持ったCodecを優先度配列の先頭に持ってくる
   *  @description H264対応のため
   */ _fixVideoCodecWithParametersOrder(codec) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        const handler = this._broadcasterTransport.msTransport._handler;
        const findCodecWithParameters = (c)=>{
            if (c.mimeType === codec.mimeType) {
                if (codec.parameters && Object.keys(codec.parameters).length > 0) {
                    if ((0, _isEqualDefault.default)(c.parameters, codec.parameters)) return true;
                    return false;
                }
                return true;
            }
            return false;
        };
        const copyCodecExceptPayloadType = (target, src)=>{
            for (const key of Object.keys(target)){
                if (key === "payloadType") continue;
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                //@ts-ignore
                target[key] = src[key];
            }
        };
        if (handler._sendingRtpParametersByKind) {
            const parameters = handler._sendingRtpParametersByKind["video"];
            const target = parameters.codecs.find(findCodecWithParameters);
            if (parameters && target) {
                const origin = JSON.parse(JSON.stringify(parameters));
                const [head] = parameters.codecs;
                const copyOfHead = JSON.parse(JSON.stringify(head));
                // 目的のRtpCodecParametersと先頭のRtpCodecParametersを入れ替える
                copyCodecExceptPayloadType(head, target);
                copyCodecExceptPayloadType(target, copyOfHead);
                log.debug("sort _sendingRtpParametersByKind", {
                    origin,
                    new: parameters.codecs
                });
            }
        }
        if (handler._sendingRemoteRtpParametersByKind) {
            const parameters = handler._sendingRemoteRtpParametersByKind["video"];
            const target = parameters.codecs.find(findCodecWithParameters);
            if (parameters && target) {
                const origin = JSON.parse(JSON.stringify(parameters));
                const [head] = parameters.codecs;
                const copyOfHead = JSON.parse(JSON.stringify(head));
                // 目的のRtpCodecParametersと先頭のRtpCodecParametersを入れ替える
                copyCodecExceptPayloadType(head, target);
                copyCodecExceptPayloadType(target, copyOfHead);
                log.debug("sort _sendingRemoteRtpParametersByKind", {
                    origin,
                    new: parameters.codecs
                });
            }
        }
    }
    _setupTransportAccessForStream(stream, transport, producer) {
        stream._getTransportCallbacks[this._bot.id] = ()=>({
                rtcPeerConnection: transport.pc,
                connectionState: transport.connectionState,
                info: this
            });
        stream._getStatsCallbacks[this._bot.id] = async ()=>{
            if (producer.closed) {
                delete stream._getStatsCallbacks[this._bot.id];
                return [];
            }
            const stats = await producer.getStats();
            let arr = (0, _core.statsToArray)(stats);
            arr = arr.map((stats)=>{
                stats["sfuTransportId"] = transport.id;
                return stats;
            });
            return arr;
        };
        // replaceStream時に古いstreamに紐づくcallbackを削除するため、戻り値としてcallback削除用の関数を返し、replaceStream時に呼び出す
        const cleanupCallbacks = ()=>{
            delete stream._getTransportCallbacks[this._bot.id];
            delete stream._getStatsCallbacks[this._bot.id];
        };
        this._disposer.push(()=>{
            cleanupCallbacks();
        });
        return cleanupCallbacks;
    }
    unproduce() {
        if (!this._producer) return;
        this._producer.close();
        this._producer = undefined;
        if (this.sendSubscriptionStatsReportTimer) clearInterval(this.sendSubscriptionStatsReportTimer);
    }
    async _replaceTrack(track) {
        await this._producer?.replaceTrack?.({
            track
        }).catch((e)=>{
            throw (0, _core.createError)({
                operationName: "Sender._replaceTrack",
                context: this._context,
                info: (0, _errors.errors).internal,
                error: e,
                path: log.prefix,
                channel: this.channel
            });
        });
    }
    close() {
        this.closed = true;
        if (this._unsubscribeStreamEnableChange) this._unsubscribeStreamEnableChange();
        this._setConnectionState("disconnected");
        this._disposer.dispose();
    }
    get pc() {
        return this._broadcasterTransport?.pc;
    }
    startSendSubscriptionStatsReportTimer() {
        const analyticsSession = this._localPerson._analytics;
        const subscription = this._bot.subscriptions.find((s)=>s.publication.id === this.publication.id);
        if (subscription && analyticsSession) {
            const intervalSec = analyticsSession.client.getIntervalSec();
            this.sendSubscriptionStatsReportTimer = setInterval(async ()=>{
                // AnalyticsSessionがcloseされていたらタイマーを止める
                if (!analyticsSession || analyticsSession.isClosed()) {
                    if (this.sendSubscriptionStatsReportTimer) clearInterval(this.sendSubscriptionStatsReportTimer);
                    return;
                }
                if (this._producer) {
                    const stats = await this._producer.getStats();
                    if (stats) analyticsSession.client.sendSubscriptionStatsReport(stats, {
                        subscriptionId: subscription.id,
                        role: "sender",
                        createdAt: Date.now()
                    });
                }
            }, intervalSec * 1000);
        }
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","lodash/isEqual":"9XEia","../errors":"7iQ6i","../forwarding":"5RgEB","../util":"57OJM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5RgEB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Forwarding", ()=>Forwarding);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _errors = require("./errors");
const log = new (0, _common.Logger)("packages/sfu-bot/src/connection/sender.ts");
class Forwarding {
    /**@internal */ constructor(props){
        this.props = props;
        this.state = "started";
        this.configure = this.props.configure;
        this.originPublication = this.props.originPublication;
        this.relayingPublication = this.props.relayingPublication;
        this._identifierKey = this.props.identifierKey;
        this._api = this.props.api;
        this._context = this.props.context;
        this.onStopped = new (0, _common.Event)();
        this.relayingPublication.onSubscribed.add(async (e)=>{
            await this.confirmSubscription(e.subscription).catch((e)=>e);
        });
        this.relayingPublication.subscriptions.forEach(async (subscription)=>{
            await this.confirmSubscription(subscription).catch((e)=>e);
        });
    }
    get id() {
        return this.relayingPublication.id;
    }
    /**@private */ _stop() {
        this.state = "stopped";
        this.onStopped.emit();
    }
    /**@internal */ toJSON() {
        return {
            id: this.id,
            configure: this.configure,
            originPublication: this.originPublication,
            relayingPublication: this.relayingPublication
        };
    }
    async confirmSubscription(subscription) {
        log.debug("[start] Forwarding confirmSubscription");
        const { message  } = await this._api.confirmSubscription({
            forwardingId: this.id,
            subscriptionId: subscription.id,
            identifierKey: this._identifierKey
        }).catch((error)=>{
            log.error("Forwarding confirmSubscription failed:", error);
            throw (0, _core.createError)({
                operationName: "Forwarding.confirmSubscription",
                context: this._context,
                info: (0, _errors.errors).confirmSubscriptionFailed,
                path: log.prefix,
                payload: error
            });
        });
        log.debug("[end] Forwarding confirmSubscription", {
            message
        });
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","./errors":"7iQ6i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cH6eo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SfuBotMember", ()=>SfuBotMember);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _connection = require("./connection");
var _const = require("./const");
var _errors = require("./errors");
const log = new (0, _common.Logger)("packages/sfu-bot/src/member.ts");
class SfuBotMember extends (0, _core.MemberImpl) {
    side = "remote";
    static subtype = "sfu";
    subtype = SfuBotMember.subtype;
    type = "bot";
    _connections = {};
    /** @description [japanese] forwardingを開始した時に発火するイベント */ onForwardingStarted = new (0, _common.Event)();
    /** @description [japanese] forwardingを終了した時に発火するイベント */ onForwardingStopped = new (0, _common.Event)();
    /** @description [japanese] forwardingの数が変化した時に発火するイベント */ onForwardingListChanged = new (0, _common.Event)();
    _startForwardQueue = new (0, _common.PromiseQueue)();
    _forwardings = {};
    get forwardings() {
        return Object.values(this._forwardings);
    }
    /**@internal */ constructor(args){
        super(args);
        this._api = args.api;
        this._context = args.context;
        this._transportRepository = args.transportRepository;
        this.options = args.options;
        this.onLeft.once(()=>{
            log.debug("SfuBotMember left: ", {
                id: this.id
            });
            Object.values(this._connections).forEach((c)=>{
                c.close({
                    reason: "sfu bot left"
                });
            });
            this._connections = {};
        });
    }
    /**@private */ _getConnection(localPersonId) {
        return this._connections[localPersonId];
    }
    /**@private */ _getOrCreateConnection(localPerson) {
        const connection = this._getConnection(localPerson.id) ?? this._createConnection(this.channel, localPerson, this);
        return connection;
    }
    /**@private */ _createConnection(channel, localPerson, endpointBot) {
        const connection = new (0, _connection.SFUConnection)(endpointBot._api, channel, localPerson, endpointBot, this._transportRepository, this._context);
        connection.onClose.once(()=>{
            delete this._connections[localPerson.id];
        });
        this._connections[localPerson.id] = connection;
        return connection;
    }
    /**
   * @description [japanese] StreamのPublicationをForwardingする
   * @throws {SkyWayError}
   * @example
   * const forwarding = await bot.startForwarding(publication, { maxSubscribers: 99 });
   */ async startForwarding(publication, configure = {}) {
        const timestamp = log.info("[start] startForwarding", await (0, _core.createLogPayload)({
            operationName: "SfuBotMember.startForwarding",
            channel: this.channel
        }));
        const res = await this._startForwardQueue.push(()=>this._startForwarding(publication, configure));
        log.elapsed(timestamp, "[end] startForwarding", await (0, _core.createLogPayload)({
            operationName: "SfuBotMember.startForwarding",
            channel: this.channel
        }));
        return res;
    }
    async _startForwarding(relayed, configure) {
        if (configure.maxSubscribers == undefined) configure.maxSubscribers = (0, _const.defaultMaxSubscribers);
        if (configure.maxSubscribers === 0) throw (0, _core.createError)({
            operationName: "SfuBotMember._startForwarding",
            context: this._context,
            channel: this.channel,
            info: (0, _errors.errors).maxSubscribersMustNotBeZero,
            path: log.prefix,
            payload: {
                configure
            }
        });
        if (this.state !== "joined") throw (0, _core.createError)({
            operationName: "SfuBotMember._startForwarding",
            context: this._context,
            channel: this.channel,
            info: (0, _errors.errors).sfuBotNotInChannel,
            path: log.prefix,
            payload: {
                status: this.state
            }
        });
        if (!this.channel._getPublication(relayed.id)) throw (0, _core.createError)({
            operationName: "SfuBotMember._startForwarding",
            context: this._context,
            channel: this.channel,
            info: (0, _core.errors).publicationNotExist,
            path: log.prefix
        });
        const localPerson = this.channel.localPerson;
        if (!localPerson) throw (0, _core.createError)({
            operationName: "SfuBotMember._startForwarding",
            context: this._context,
            channel: this.channel,
            info: (0, _core.errors).localPersonNotJoinedChannel,
            path: log.prefix
        });
        if (localPerson.id !== relayed.publisher.id) throw (0, _core.createError)({
            operationName: "SfuBotMember._startForwarding",
            context: this._context,
            info: (0, _errors.errors).remotePublisherId,
            path: log.prefix,
            channel: this.channel
        });
        const ts = log.debug("[start] SfuBotMember startForwarding", {
            publication: relayed.toJSON(),
            configure
        });
        const connection = this._getOrCreateConnection(localPerson);
        const sender = connection.addSender(relayed);
        const forwarding = await sender.startForwarding(configure).catch((error)=>{
            throw (0, _core.createError)({
                operationName: "SfuBotMember._startForwarding",
                context: this._context,
                info: {
                    ...(0, _errors.errors).internal,
                    detail: "[failed] SfuBotMember startForwarding"
                },
                path: log.prefix,
                channel: this.channel,
                error,
                payload: {
                    publication: relayed.toJSON()
                }
            });
        });
        this._forwardings[forwarding.id] = forwarding;
        this.listenStopForwardEvent(forwarding);
        this.onForwardingStarted.emit({
            forwarding
        });
        this.onForwardingListChanged.emit();
        log.elapsed(ts, "[end] SfuBotMember startForwarding", {
            forwarding: forwarding.toJSON()
        });
        return forwarding;
    }
    listenStopForwardEvent(forwarding) {
        const { removeListener  } = this.channel.onStreamUnpublished.add((e)=>{
            if (e.publication.id === forwarding.id) {
                removeListener();
                forwarding._stop();
                const origin = forwarding.originPublication;
                const connection = this._getConnection(origin.publisher.id);
                if (connection) connection.removeSender(origin.id);
                this.onForwardingStopped.emit({
                    forwarding
                });
                this.onForwardingListChanged.emit();
            }
        });
    }
    /**
   * @description [japanese] Forwardingを停止する
   */ stopForwarding = (target)=>new Promise(async (r, f)=>{
            const timestamp = log.info("[start] stopForwarding", await (0, _core.createLogPayload)({
                operationName: "SfuBotMember.stopForwarding",
                channel: this.channel
            }));
            if (this.state !== "joined") {
                f((0, _core.createError)({
                    operationName: "SfuBotMember.stopForwarding",
                    context: this._context,
                    info: (0, _errors.errors).sfuBotNotInChannel,
                    path: log.prefix,
                    channel: this.channel,
                    payload: {
                        status: this.state
                    }
                }));
                return;
            }
            const forwardingId = typeof target === "string" ? target : target.id;
            const forwarding = this._forwardings[forwardingId];
            if (!forwarding) {
                f((0, _core.createError)({
                    operationName: "SfuBotMember.stopForwarding",
                    context: this._context,
                    info: (0, _errors.errors).forwardingNotFound,
                    path: log.prefix,
                    channel: this.channel,
                    payload: {
                        forwardingId,
                        _forwardings: Object.keys(this._forwardings)
                    }
                }));
                return;
            }
            delete this._forwardings[forwarding.id];
            const { promise , fulfilled  } = this._api.stopForwarding({
                botId: this.id,
                forwardingId
            });
            let failed = false;
            promise.catch((e)=>{
                failed = true;
                f(e);
            });
            this.onForwardingStopped.watch((e)=>e.forwarding.id === forwardingId, this._context.config.rtcApi.timeout).then(async ()=>{
                log.elapsed(timestamp, "[end] stopForwarding", await (0, _core.createLogPayload)({
                    operationName: "SfuBotMember.stopForwarding",
                    channel: this.channel
                }));
                r();
            }).catch((error)=>{
                if (!failed) f((0, _core.createError)({
                    operationName: "SfuBotMember.stopForwarding",
                    context: this._context,
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "onForwardingStopped"
                    },
                    path: log.prefix,
                    channel: this.channel,
                    payload: {
                        fulfilled
                    },
                    error
                }));
            });
        });
    /**@private */ _dispose() {}
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","./connection":"kXn1I","./const":"fx5BU","./errors":"7iQ6i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fx5BU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultMaxSubscribers", ()=>defaultMaxSubscribers);
const defaultMaxSubscribers = 10;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXeui":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultSfuBotPluginOptions", ()=>defaultSfuBotPluginOptions);
var _sfuApiClient = require("@skyway-sdk/sfu-api-client");
const defaultSfuBotPluginOptions = {
    ...(0, _sfuApiClient.defaultSfuApiOptions),
    endpointTimeout: 30000,
    ackTimeout: 10000,
    disableRestartIce: false
};

},{"@skyway-sdk/sfu-api-client":"bSWdL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dgOkC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SfuBotPlugin", ()=>SfuBotPlugin);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _sfuApiClient = require("@skyway-sdk/sfu-api-client");
var _transportRepository = require("./connection/transport/transportRepository");
var _errors = require("./errors");
var _member = require("./member");
var _option = require("./option");
var _version = require("./version");
const log = new (0, _common.Logger)("packages/sfu-bot/src/plugin.ts");
class SfuBotPlugin extends (0, _core.SkyWayPlugin) {
    static subtype = (0, _member.SfuBotMember).subtype;
    subtype = SfuBotPlugin.subtype;
    constructor(_options = {}){
        super();
        this.options = {
            ...(0, _option.defaultSfuBotPluginOptions),
            ..._options
        };
        this._onContextAttached.once((context)=>{
            (0, _common.Logger).level = context.config.log.level;
            (0, _common.Logger).format = context.config.log.format;
            log.info("SfuBotPlugin spawned", {
                operationName: "SfuBotPlugin.constructor",
                endpoint: {
                    sfu: this.options.domain
                },
                options: this.options,
                sdkName: "sfu-bot",
                sdkVersion: (0, _version.PACKAGE_VERSION)
            });
            this._api = new (0, _sfuApiClient.SfuRestApiClient)(context.authTokenString, {
                ...this.options,
                log: context.config.log
            });
            this._transportRepository = new (0, _transportRepository.TransportRepository)(context, this._api);
            context._onTokenUpdated.add((token)=>{
                this._api.updateToken(token);
            });
        });
        this._whenDisposeLocalPerson = async (person)=>{
            this._transportRepository.deleteTransports(person.id);
        };
    }
    /**@private */ _createRemoteMember = (channel, sfuBot)=>{
        const member = new (0, _member.SfuBotMember)({
            ...this._context,
            channel,
            id: sfuBot.id,
            name: sfuBot.name,
            metadata: sfuBot.metadata,
            plugin: this,
            api: this._api,
            context: this._context,
            transportRepository: this._transportRepository,
            options: this.options
        });
        return member;
    };
    /**
   * @description [japanese] SFU BotをChannelに呼び出す
   */ createBot = async (channel)=>{
        const timestamp = log.info("[start] createBot", await (0, _core.createLogPayload)({
            operationName: "SfuBotPlugin.createBot",
            channel: channel
        }));
        const botId = await this._api.createBot({
            appId: this._context.authToken.scope.app.id,
            channelId: channel.id
        });
        const member = channel._getMember(botId) ?? (await channel.onMemberJoined.watch((e)=>e.member.id === botId, this._context.config.rtcApi.timeout).catch((error)=>{
            throw (0, _core.createError)({
                operationName: "SfuBotPlugin.createBot",
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onMemberJoined"
                },
                path: log.prefix,
                error,
                context: this._context
            });
        })).member;
        log.elapsed(timestamp, "[end] createBot", await (0, _core.createLogPayload)({
            operationName: "SfuBotPlugin.createBot",
            channel
        }));
        return member;
    };
    /**
   * @description [japanese] SFU BotをChannelから削除する
   */ deleteBot = async (channel, botId)=>new Promise(async (r, f)=>{
            const timestamp = log.info("[start] deleteBot", await (0, _core.createLogPayload)({
                operationName: "SfuBotPlugin.deleteBot",
                channel
            }));
            let failed = false;
            this._api.deleteBot({
                botId
            }).catch((e)=>{
                failed = true;
                f(e);
            });
            channel.onMemberLeft.watch((e)=>e.member.id === botId, this._context.config.rtcApi.timeout).then(async ()=>{
                log.elapsed(timestamp, "[end] deleteBot", await (0, _core.createLogPayload)({
                    operationName: "SfuBotPlugin.deleteBot",
                    channel
                }));
                r();
            }).catch((error)=>{
                if (!failed) f((0, _core.createError)({
                    operationName: "SfuBotPlugin.deleteBot",
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "onMemberLeft"
                    },
                    path: log.prefix,
                    channel,
                    error,
                    context: this._context
                }));
            });
        });
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","@skyway-sdk/sfu-api-client":"bSWdL","./connection/transport/transportRepository":"bWXTQ","./errors":"7iQ6i","./member":"cH6eo","./option":"kXeui","./version":"cC3mT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bWXTQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TransportRepository", ()=>TransportRepository);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _mediasoupClient = require("mediasoup-client");
var _errors = require("../../errors");
var _transport = require("./transport");
const log = new (0, _common.Logger)("packages/sfu-bot/src/connection/transport/transportRepository.ts");
class TransportRepository {
    get rtpCapabilities() {
        if (!this._device.loaded) return undefined;
        return this._device.rtpCapabilities;
    }
    constructor(_context, _api){
        this._context = _context;
        this._api = _api;
        this.onTransportCreated = new (0, _common.Event)();
        this./**@private */ _transports = {};
        this.getTransport = (personId, id)=>this._transports[personId + id];
        const { browserName , browserVersion  } = (0, _core.getRuntimeInfo)();
        log.debug("runtime info", {
            browserName,
            browserVersion
        });
        // wkwebview対応
        if (browserName === "Safari" && browserVersion == undefined) this._device = new (0, _mediasoupClient.Device)({
            handlerName: "Safari12"
        });
        else this._device = new (0, _mediasoupClient.Device)();
    }
    async loadDevice(rtpCapabilities) {
        if (!this._device.loaded) {
            await this._device.load({
                routerRtpCapabilities: rtpCapabilities
            }).catch((err)=>{
                throw (0, _core.createError)({
                    operationName: "TransportRepository.loadDevice",
                    context: this._context,
                    info: {
                        ...(0, _errors.errors).internal,
                        detail: "loadDevice failed"
                    },
                    path: log.prefix,
                    payload: {
                        rtpCapabilities
                    },
                    error: err
                });
            });
            log.debug("device loaded", {
                routerRtpCapabilities: rtpCapabilities,
                rtpCapabilities: this._device.rtpCapabilities
            });
        }
    }
    /**worker内にmemberIdに紐つくTransportが無ければ新しいTransportが作られる */ createTransport(personId, bot, transportOptions, direction, iceManager, analyticsSession) {
        const createTransport = direction === "send" ? (o)=>this._device.createSendTransport(o) : (o)=>this._device.createRecvTransport(o);
        const msTransport = createTransport({
            ...transportOptions,
            iceServers: iceManager.iceServers,
            iceTransportPolicy: this._context.config.rtcConfig.turnPolicy === "turnOnly" ? "relay" : undefined,
            additionalSettings: this._context.config.rtcConfig
        });
        const transport = new (0, _transport.SfuTransport)(msTransport, bot, iceManager, this._api, this._context, analyticsSession);
        this._transports[personId + msTransport.id] = transport;
        this.onTransportCreated.emit(msTransport.id);
        return transport;
    }
    deleteTransports(personId) {
        Object.entries({
            ...this._transports
        }).forEach(([id, transport])=>{
            if (id.includes(personId)) {
                transport.close();
                delete this._transports[id];
            }
        });
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","mediasoup-client":"jaXUe","../../errors":"7iQ6i","./transport":"gWOO4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jaXUe":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
const debug_1 = __importDefault(require("c3b105930b79edec"));
exports.debug = debug_1.default;
const Device_1 = require("fec5f4820de4f4aa");
Object.defineProperty(exports, "Device", {
    enumerable: true,
    get: function() {
        return Device_1.Device;
    }
});
Object.defineProperty(exports, "detectDevice", {
    enumerable: true,
    get: function() {
        return Device_1.detectDevice;
    }
});
const types = __importStar(require("61a16a06df9c227b"));
exports.types = types;
/**
 * Expose mediasoup-client version.
 */ exports.version = "3.6.82";
/**
 * Expose parseScalabilityMode() function.
 */ var scalabilityModes_1 = require("86b37405055c46ff");
Object.defineProperty(exports, "parseScalabilityMode", {
    enumerable: true,
    get: function() {
        return scalabilityModes_1.parse;
    }
});

},{"c3b105930b79edec":"l0oUb","fec5f4820de4f4aa":"jvSOG","61a16a06df9c227b":"03TIr","86b37405055c46ff":"hE1NO"}],"l0oUb":[function(require,module,exports) {
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ var process = require("907f662bd10b9333");
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) return;
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === "%%") return;
        index++;
        if (match === "%c") // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) exports.storage.setItem("debug", namespaces);
        else exports.storage.removeItem("debug");
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem("debug");
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== "undefined" && "env" in process) r = undefined;
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = require("c6130e4f7c4df84c")(exports);
const { formatters  } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
    }
};

},{"907f662bd10b9333":"d5jf4","c6130e4f7c4df84c":"6Yq2n"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"6Yq2n":[function(require,module,exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require("ce49a7015f7de6a1");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) return;
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") // Anything else let's inspect with %O
            args.unshift("%O");
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === "%%") return "%";
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) return enableOverride;
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === "function") createDebug.init(debug);
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) continue;
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            else createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>"-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === "*") return true;
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) return false;
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) return true;
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;

},{"ce49a7015f7de6a1":"jauEe"}],"jauEe":[function(require,module,exports) {
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) return parse(val);
    else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch(type){
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
            return n * y;
        case "weeks":
        case "week":
        case "w":
            return n * w;
        case "days":
        case "day":
        case "d":
            return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
            return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
            return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
            return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return Math.round(ms / d) + "d";
    if (msAbs >= h) return Math.round(ms / h) + "h";
    if (msAbs >= m) return Math.round(ms / m) + "m";
    if (msAbs >= s) return Math.round(ms / s) + "s";
    return ms + "ms";
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return plural(ms, msAbs, d, "day");
    if (msAbs >= h) return plural(ms, msAbs, h, "hour");
    if (msAbs >= m) return plural(ms, msAbs, m, "minute");
    if (msAbs >= s) return plural(ms, msAbs, s, "second");
    return ms + " ms";
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
}

},{}],"jvSOG":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Device = exports.detectDevice = void 0;
const bowser_1 = __importDefault(require("5c2cb40e3f5131c7"));
const Logger_1 = require("11e8db7f9aae46e");
const EnhancedEventEmitter_1 = require("609a2d9952f927f");
const errors_1 = require("384dfb34e7eda40c");
const utils = __importStar(require("bf68e1647dd88a56"));
const ortc = __importStar(require("600b1e8e5b070cee"));
const Transport_1 = require("bf465834950514e2");
const Chrome111_1 = require("e0e9dcc146f7dfa5");
const Chrome74_1 = require("9b18c59fcfc4d2f4");
const Chrome70_1 = require("57c48a6c15e599c4");
const Chrome67_1 = require("427badd2da87c252");
const Chrome55_1 = require("cce4e8a3381386ec");
const Firefox60_1 = require("52c06db3efba48f3");
const Safari12_1 = require("1cd417875928c455");
const Safari11_1 = require("db332bd1a830525e");
const Edge11_1 = require("a477170d3c273d84");
const ReactNativeUnifiedPlan_1 = require("72700695cd587cef");
const ReactNative_1 = require("85c445787eafc171");
const logger = new Logger_1.Logger("Device");
function detectDevice() {
    // React-Native.
    // NOTE: react-native-webrtc >= 1.75.0 is required.
    // NOTE: react-native-webrtc with Unified Plan requires version >= 106.0.0.
    if (typeof navigator === "object" && navigator.product === "ReactNative") {
        if (typeof RTCPeerConnection === "undefined") {
            logger.warn("this._detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?");
            return undefined;
        }
        if (typeof RTCRtpTransceiver !== "undefined") {
            logger.debug("this._detectDevice() | ReactNative UnifiedPlan handler chosen");
            return "ReactNativeUnifiedPlan";
        } else {
            logger.debug("this._detectDevice() | ReactNative PlanB handler chosen");
            return "ReactNative";
        }
    } else if (typeof navigator === "object" && typeof navigator.userAgent === "string") {
        const ua = navigator.userAgent;
        const browser = bowser_1.default.getParser(ua);
        const engine = browser.getEngine();
        // Chrome, Chromium, and Edge.
        if (browser.satisfies({
            chrome: ">=111",
            chromium: ">=111",
            "microsoft edge": ">=111"
        })) return "Chrome111";
        else if (browser.satisfies({
            chrome: ">=74",
            chromium: ">=74",
            "microsoft edge": ">=88"
        })) return "Chrome74";
        else if (browser.satisfies({
            chrome: ">=70",
            chromium: ">=70"
        })) return "Chrome70";
        else if (browser.satisfies({
            chrome: ">=67",
            chromium: ">=67"
        })) return "Chrome67";
        else if (browser.satisfies({
            chrome: ">=55",
            chromium: ">=55"
        })) return "Chrome55";
        else if (browser.satisfies({
            firefox: ">=60"
        })) return "Firefox60";
        else if (browser.satisfies({
            ios: {
                OS: ">=14.3",
                firefox: ">=30.0"
            }
        })) return "Safari12";
        else if (browser.satisfies({
            safari: ">=12.0"
        }) && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) return "Safari12";
        else if (browser.satisfies({
            safari: ">=11"
        })) return "Safari11";
        else if (browser.satisfies({
            "microsoft edge": ">=11"
        }) && browser.satisfies({
            "microsoft edge": "<=18"
        })) return "Edge11";
        else if (engine.name && engine.name.toLowerCase() === "blink") {
            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
                const version = Number(match[1]);
                if (version >= 111) return "Chrome111";
                else if (version >= 74) return "Chrome74";
                else if (version >= 70) return "Chrome70";
                else if (version >= 67) return "Chrome67";
                else return "Chrome55";
            } else return "Chrome111";
        } else {
            logger.warn("this._detectDevice() | browser not supported [name:%s, version:%s]", browser.getBrowserName(), browser.getBrowserVersion());
            return undefined;
        }
    } else {
        logger.warn("this._detectDevice() | unknown device");
        return undefined;
    }
}
exports.detectDevice = detectDevice;
class Device {
    /**
     * Create a new Device to connect to mediasoup server.
     *
     * @throws {UnsupportedError} if device is not supported.
     */ constructor({ handlerName , handlerFactory , Handler  } = {}){
        // Loaded flag.
        this._loaded = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug("constructor()");
        // Handle deprecated option.
        if (Handler) {
            logger.warn("constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead");
            if (typeof Handler === "string") handlerName = Handler;
            else throw new TypeError("non string Handler option no longer supported, use handlerFactory instead");
        }
        if (handlerName && handlerFactory) throw new TypeError("just one of handlerName or handlerInterface can be given");
        if (handlerFactory) this._handlerFactory = handlerFactory;
        else {
            if (handlerName) logger.debug("constructor() | handler given: %s", handlerName);
            else {
                handlerName = detectDevice();
                if (handlerName) logger.debug("constructor() | detected handler: %s", handlerName);
                else throw new errors_1.UnsupportedError("device not supported");
            }
            switch(handlerName){
                case "Chrome111":
                    this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                    break;
                case "Chrome74":
                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                    break;
                case "Chrome70":
                    this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                    break;
                case "Chrome67":
                    this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                    break;
                case "Chrome55":
                    this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                    break;
                case "Firefox60":
                    this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                    break;
                case "Safari12":
                    this._handlerFactory = Safari12_1.Safari12.createFactory();
                    break;
                case "Safari11":
                    this._handlerFactory = Safari11_1.Safari11.createFactory();
                    break;
                case "Edge11":
                    this._handlerFactory = Edge11_1.Edge11.createFactory();
                    break;
                case "ReactNativeUnifiedPlan":
                    this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
                    break;
                case "ReactNative":
                    this._handlerFactory = ReactNative_1.ReactNative.createFactory();
                    break;
                default:
                    throw new TypeError(`unknown handlerName "${handlerName}"`);
            }
        }
        // Create a temporal handler to get its name.
        const handler = this._handlerFactory();
        this._handlerName = handler.name;
        handler.close();
        this._extendedRtpCapabilities = undefined;
        this._recvRtpCapabilities = undefined;
        this._canProduceByKind = {
            audio: false,
            video: false
        };
        this._sctpCapabilities = undefined;
    }
    /**
     * The RTC handler name.
     */ get handlerName() {
        return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */ get loaded() {
        return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */ get rtpCapabilities() {
        if (!this._loaded) throw new errors_1.InvalidStateError("not loaded");
        return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */ get sctpCapabilities() {
        if (!this._loaded) throw new errors_1.InvalidStateError("not loaded");
        return this._sctpCapabilities;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Initialize the Device.
     */ async load({ routerRtpCapabilities  }) {
        logger.debug("load() [routerRtpCapabilities:%o]", routerRtpCapabilities);
        routerRtpCapabilities = utils.clone(routerRtpCapabilities, undefined);
        // Temporal handler to get its capabilities.
        let handler;
        try {
            if (this._loaded) throw new errors_1.InvalidStateError("already loaded");
            // This may throw.
            ortc.validateRtpCapabilities(routerRtpCapabilities);
            handler = this._handlerFactory();
            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();
            logger.debug("load() | got native RTP capabilities:%o", nativeRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(nativeRtpCapabilities);
            // Get extended RTP capabilities.
            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);
            logger.debug("load() | got extended RTP capabilities:%o", this._extendedRtpCapabilities);
            // Check whether we can produce audio/video.
            this._canProduceByKind.audio = ortc.canSend("audio", this._extendedRtpCapabilities);
            this._canProduceByKind.video = ortc.canSend("video", this._extendedRtpCapabilities);
            // Generate our receiving RTP capabilities for receiving media.
            this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
            // This may throw.
            ortc.validateRtpCapabilities(this._recvRtpCapabilities);
            logger.debug("load() | got receiving RTP capabilities:%o", this._recvRtpCapabilities);
            // Generate our SCTP capabilities.
            this._sctpCapabilities = await handler.getNativeSctpCapabilities();
            logger.debug("load() | got native SCTP capabilities:%o", this._sctpCapabilities);
            // This may throw.
            ortc.validateSctpCapabilities(this._sctpCapabilities);
            logger.debug("load() succeeded");
            this._loaded = true;
            handler.close();
        } catch (error) {
            if (handler) handler.close();
            throw error;
        }
    }
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */ canProduce(kind) {
        if (!this._loaded) throw new errors_1.InvalidStateError("not loaded");
        else if (kind !== "audio" && kind !== "video") throw new TypeError(`invalid kind "${kind}"`);
        return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */ createSendTransport({ id , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , appData  }) {
        logger.debug("createSendTransport()");
        return this.createTransport({
            direction: "send",
            id: id,
            iceParameters: iceParameters,
            iceCandidates: iceCandidates,
            dtlsParameters: dtlsParameters,
            sctpParameters: sctpParameters,
            iceServers: iceServers,
            iceTransportPolicy: iceTransportPolicy,
            additionalSettings: additionalSettings,
            proprietaryConstraints: proprietaryConstraints,
            appData: appData
        });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */ createRecvTransport({ id , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , appData  }) {
        logger.debug("createRecvTransport()");
        return this.createTransport({
            direction: "recv",
            id: id,
            iceParameters: iceParameters,
            iceCandidates: iceCandidates,
            dtlsParameters: dtlsParameters,
            sctpParameters: sctpParameters,
            iceServers: iceServers,
            iceTransportPolicy: iceTransportPolicy,
            additionalSettings: additionalSettings,
            proprietaryConstraints: proprietaryConstraints,
            appData: appData
        });
    }
    createTransport({ direction , id , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , appData  }) {
        if (!this._loaded) throw new errors_1.InvalidStateError("not loaded");
        else if (typeof id !== "string") throw new TypeError("missing id");
        else if (typeof iceParameters !== "object") throw new TypeError("missing iceParameters");
        else if (!Array.isArray(iceCandidates)) throw new TypeError("missing iceCandidates");
        else if (typeof dtlsParameters !== "object") throw new TypeError("missing dtlsParameters");
        else if (sctpParameters && typeof sctpParameters !== "object") throw new TypeError("wrong sctpParameters");
        else if (appData && typeof appData !== "object") throw new TypeError("if given, appData must be an object");
        // Create a new Transport.
        const transport = new Transport_1.Transport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
            handlerFactory: this._handlerFactory,
            extendedRtpCapabilities: this._extendedRtpCapabilities,
            canProduceByKind: this._canProduceByKind
        });
        // Emit observer event.
        this._observer.safeEmit("newtransport", transport);
        return transport;
    }
}
exports.Device = Device;

},{"5c2cb40e3f5131c7":"5jYCf","11e8db7f9aae46e":"co3ME","609a2d9952f927f":"4Z8Ic","384dfb34e7eda40c":"Xq57d","bf68e1647dd88a56":"6bv4j","600b1e8e5b070cee":"jtITX","bf465834950514e2":"cWahd","e0e9dcc146f7dfa5":"bmuYv","9b18c59fcfc4d2f4":"6XG5D","57c48a6c15e599c4":"h1bb1","427badd2da87c252":"leQQE","cce4e8a3381386ec":"a0ORI","52c06db3efba48f3":"1E5rC","1cd417875928c455":"c427S","db332bd1a830525e":"6eg0I","a477170d3c273d84":"2IvZ5","72700695cd587cef":"uwD4F","85c445787eafc171":"8x6NC"}],"co3ME":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Logger = void 0;
const debug_1 = __importDefault(require("b58940ede10c6e70"));
const APP_NAME = "mediasoup-client";
class Logger {
    constructor(prefix){
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        } else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */ this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
    /* eslint-enable no-console */ }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;

},{"b58940ede10c6e70":"l0oUb"}],"4Z8Ic":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EnhancedEventEmitter = void 0;
const events_1 = require("7c2aa781fd16af1e");
const Logger_1 = require("7a5c0f78828d40");
const logger = new Logger_1.Logger("EnhancedEventEmitter");
class EnhancedEventEmitter extends events_1.EventEmitter {
    constructor(){
        super();
        this.setMaxListeners(Infinity);
    }
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * Special addition to the EventEmitter API.
     */ safeEmit(eventName, ...args) {
        const numListeners = super.listenerCount(eventName);
        try {
            return super.emit(eventName, ...args);
        } catch (error) {
            logger.error("safeEmit() | event listener threw an error [eventName:%s]:%o", eventName, error);
            return Boolean(numListeners);
        }
    }
    on(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    off(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    addListener(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    prependListener(eventName, listener) {
        super.prependListener(eventName, listener);
        return this;
    }
    once(eventName, listener) {
        super.once(eventName, listener);
        return this;
    }
    prependOnceListener(eventName, listener) {
        super.prependOnceListener(eventName, listener);
        return this;
    }
    removeListener(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    removeAllListeners(eventName) {
        super.removeAllListeners(eventName);
        return this;
    }
    listenerCount(eventName) {
        return super.listenerCount(eventName);
    }
    listeners(eventName) {
        return super.listeners(eventName);
    }
    rawListeners(eventName) {
        return super.rawListeners(eventName);
    }
}
exports.EnhancedEventEmitter = EnhancedEventEmitter;

},{"7c2aa781fd16af1e":"1VQLm","7a5c0f78828d40":"co3ME"}],"1VQLm":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === "function") // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"Xq57d":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */ class UnsupportedError extends Error {
    constructor(message){
        super(message);
        this.name = "UnsupportedError";
        if (Error.hasOwnProperty("captureStackTrace")) // @ts-ignore
        Error.captureStackTrace(this, UnsupportedError);
        else this.stack = new Error(message).stack;
    }
}
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */ class InvalidStateError extends Error {
    constructor(message){
        super(message);
        this.name = "InvalidStateError";
        if (Error.hasOwnProperty("captureStackTrace")) // @ts-ignore
        Error.captureStackTrace(this, InvalidStateError);
        else this.stack = new Error(message).stack;
    }
}
exports.InvalidStateError = InvalidStateError;

},{}],"6bv4j":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateRandomNumber = exports.clone = void 0;
/**
 * Clones the given data.
 */ function clone(data, defaultValue) {
    if (typeof data === "undefined") return defaultValue;
    return JSON.parse(JSON.stringify(data));
}
exports.clone = clone;
/**
 * Generates a random positive integer.
 */ function generateRandomNumber() {
    return Math.round(Math.random() * 10000000);
}
exports.generateRandomNumber = generateRandomNumber;

},{}],"jtITX":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;
const h264 = __importStar(require("7f75b0114ee974ce"));
const utils = __importStar(require("d84998caa791f0ed"));
const RTP_PROBATOR_MID = "probator";
const RTP_PROBATOR_SSRC = 1234;
const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtpCapabilities(caps) {
    if (typeof caps !== "object") throw new TypeError("caps is not an object");
    // codecs is optional. If unset, fill with an empty array.
    if (caps.codecs && !Array.isArray(caps.codecs)) throw new TypeError("caps.codecs is not an array");
    else if (!caps.codecs) caps.codecs = [];
    for (const codec of caps.codecs)validateRtpCodecCapability(codec);
    // headerExtensions is optional. If unset, fill with an empty array.
    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) throw new TypeError("caps.headerExtensions is not an array");
    else if (!caps.headerExtensions) caps.headerExtensions = [];
    for (const ext of caps.headerExtensions)validateRtpHeaderExtension(ext);
}
exports.validateRtpCapabilities = validateRtpCapabilities;
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtpCodecCapability(codec) {
    const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
    if (typeof codec !== "object") throw new TypeError("codec is not an object");
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== "string") throw new TypeError("missing codec.mimeType");
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) throw new TypeError("invalid codec.mimeType");
    // Just override kind with media component of mimeType.
    codec.kind = mimeTypeMatch[1].toLowerCase();
    // preferredPayloadType is optional.
    if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== "number") throw new TypeError("invalid codec.preferredPayloadType");
    // clockRate is mandatory.
    if (typeof codec.clockRate !== "number") throw new TypeError("missing codec.clockRate");
    // channels is optional. If unset, set it to 1 (just if audio).
    if (codec.kind === "audio") {
        if (typeof codec.channels !== "number") codec.channels = 1;
    } else delete codec.channels;
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== "object") codec.parameters = {};
    for (const key of Object.keys(codec.parameters)){
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = "";
            value = "";
        }
        if (typeof value !== "string" && typeof value !== "number") throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        // Specific parameters validation.
        if (key === "apt") {
            if (typeof value !== "number") throw new TypeError("invalid codec apt parameter");
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];
    for (const fb of codec.rtcpFeedback)validateRtcpFeedback(fb);
}
exports.validateRtpCodecCapability = validateRtpCodecCapability;
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtcpFeedback(fb) {
    if (typeof fb !== "object") throw new TypeError("fb is not an object");
    // type is mandatory.
    if (!fb.type || typeof fb.type !== "string") throw new TypeError("missing fb.type");
    // parameter is optional. If unset set it to an empty string.
    if (!fb.parameter || typeof fb.parameter !== "string") fb.parameter = "";
}
exports.validateRtcpFeedback = validateRtcpFeedback;
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtpHeaderExtension(ext) {
    if (typeof ext !== "object") throw new TypeError("ext is not an object");
    // kind is mandatory.
    if (ext.kind !== "audio" && ext.kind !== "video") throw new TypeError("invalid ext.kind");
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== "string") throw new TypeError("missing ext.uri");
    // preferredId is mandatory.
    if (typeof ext.preferredId !== "number") throw new TypeError("missing ext.preferredId");
    // preferredEncrypt is optional. If unset set it to false.
    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== "boolean") throw new TypeError("invalid ext.preferredEncrypt");
    else if (!ext.preferredEncrypt) ext.preferredEncrypt = false;
    // direction is optional. If unset set it to sendrecv.
    if (ext.direction && typeof ext.direction !== "string") throw new TypeError("invalid ext.direction");
    else if (!ext.direction) ext.direction = "sendrecv";
}
exports.validateRtpHeaderExtension = validateRtpHeaderExtension;
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtpParameters(params) {
    if (typeof params !== "object") throw new TypeError("params is not an object");
    // mid is optional.
    if (params.mid && typeof params.mid !== "string") throw new TypeError("params.mid is not a string");
    // codecs is mandatory.
    if (!Array.isArray(params.codecs)) throw new TypeError("missing params.codecs");
    for (const codec of params.codecs)validateRtpCodecParameters(codec);
    // headerExtensions is optional. If unset, fill with an empty array.
    if (params.headerExtensions && !Array.isArray(params.headerExtensions)) throw new TypeError("params.headerExtensions is not an array");
    else if (!params.headerExtensions) params.headerExtensions = [];
    for (const ext of params.headerExtensions)validateRtpHeaderExtensionParameters(ext);
    // encodings is optional. If unset, fill with an empty array.
    if (params.encodings && !Array.isArray(params.encodings)) throw new TypeError("params.encodings is not an array");
    else if (!params.encodings) params.encodings = [];
    for (const encoding of params.encodings)validateRtpEncodingParameters(encoding);
    // rtcp is optional. If unset, fill with an empty object.
    if (params.rtcp && typeof params.rtcp !== "object") throw new TypeError("params.rtcp is not an object");
    else if (!params.rtcp) params.rtcp = {};
    validateRtcpParameters(params.rtcp);
}
exports.validateRtpParameters = validateRtpParameters;
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtpCodecParameters(codec) {
    const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
    if (typeof codec !== "object") throw new TypeError("codec is not an object");
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== "string") throw new TypeError("missing codec.mimeType");
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) throw new TypeError("invalid codec.mimeType");
    // payloadType is mandatory.
    if (typeof codec.payloadType !== "number") throw new TypeError("missing codec.payloadType");
    // clockRate is mandatory.
    if (typeof codec.clockRate !== "number") throw new TypeError("missing codec.clockRate");
    const kind = mimeTypeMatch[1].toLowerCase();
    // channels is optional. If unset, set it to 1 (just if audio).
    if (kind === "audio") {
        if (typeof codec.channels !== "number") codec.channels = 1;
    } else delete codec.channels;
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== "object") codec.parameters = {};
    for (const key of Object.keys(codec.parameters)){
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = "";
            value = "";
        }
        if (typeof value !== "string" && typeof value !== "number") throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        // Specific parameters validation.
        if (key === "apt") {
            if (typeof value !== "number") throw new TypeError("invalid codec apt parameter");
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];
    for (const fb of codec.rtcpFeedback)validateRtcpFeedback(fb);
}
exports.validateRtpCodecParameters = validateRtpCodecParameters;
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtpHeaderExtensionParameters(ext) {
    if (typeof ext !== "object") throw new TypeError("ext is not an object");
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== "string") throw new TypeError("missing ext.uri");
    // id is mandatory.
    if (typeof ext.id !== "number") throw new TypeError("missing ext.id");
    // encrypt is optional. If unset set it to false.
    if (ext.encrypt && typeof ext.encrypt !== "boolean") throw new TypeError("invalid ext.encrypt");
    else if (!ext.encrypt) ext.encrypt = false;
    // parameters is optional. If unset, set it to an empty object.
    if (!ext.parameters || typeof ext.parameters !== "object") ext.parameters = {};
    for (const key of Object.keys(ext.parameters)){
        let value = ext.parameters[key];
        if (value === undefined) {
            ext.parameters[key] = "";
            value = "";
        }
        if (typeof value !== "string" && typeof value !== "number") throw new TypeError("invalid header extension parameter");
    }
}
exports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtpEncodingParameters(encoding) {
    if (typeof encoding !== "object") throw new TypeError("encoding is not an object");
    // ssrc is optional.
    if (encoding.ssrc && typeof encoding.ssrc !== "number") throw new TypeError("invalid encoding.ssrc");
    // rid is optional.
    if (encoding.rid && typeof encoding.rid !== "string") throw new TypeError("invalid encoding.rid");
    // rtx is optional.
    if (encoding.rtx && typeof encoding.rtx !== "object") throw new TypeError("invalid encoding.rtx");
    else if (encoding.rtx) {
        // RTX ssrc is mandatory if rtx is present.
        if (typeof encoding.rtx.ssrc !== "number") throw new TypeError("missing encoding.rtx.ssrc");
    }
    // dtx is optional. If unset set it to false.
    if (!encoding.dtx || typeof encoding.dtx !== "boolean") encoding.dtx = false;
    // scalabilityMode is optional.
    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== "string") throw new TypeError("invalid encoding.scalabilityMode");
}
exports.validateRtpEncodingParameters = validateRtpEncodingParameters;
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateRtcpParameters(rtcp) {
    if (typeof rtcp !== "object") throw new TypeError("rtcp is not an object");
    // cname is optional.
    if (rtcp.cname && typeof rtcp.cname !== "string") throw new TypeError("invalid rtcp.cname");
    // reducedSize is optional. If unset set it to true.
    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== "boolean") rtcp.reducedSize = true;
}
exports.validateRtcpParameters = validateRtcpParameters;
/**
 * Validates SctpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateSctpCapabilities(caps) {
    if (typeof caps !== "object") throw new TypeError("caps is not an object");
    // numStreams is mandatory.
    if (!caps.numStreams || typeof caps.numStreams !== "object") throw new TypeError("missing caps.numStreams");
    validateNumSctpStreams(caps.numStreams);
}
exports.validateSctpCapabilities = validateSctpCapabilities;
/**
 * Validates NumSctpStreams. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateNumSctpStreams(numStreams) {
    if (typeof numStreams !== "object") throw new TypeError("numStreams is not an object");
    // OS is mandatory.
    if (typeof numStreams.OS !== "number") throw new TypeError("missing numStreams.OS");
    // MIS is mandatory.
    if (typeof numStreams.MIS !== "number") throw new TypeError("missing numStreams.MIS");
}
exports.validateNumSctpStreams = validateNumSctpStreams;
/**
 * Validates SctpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateSctpParameters(params) {
    if (typeof params !== "object") throw new TypeError("params is not an object");
    // port is mandatory.
    if (typeof params.port !== "number") throw new TypeError("missing params.port");
    // OS is mandatory.
    if (typeof params.OS !== "number") throw new TypeError("missing params.OS");
    // MIS is mandatory.
    if (typeof params.MIS !== "number") throw new TypeError("missing params.MIS");
    // maxMessageSize is mandatory.
    if (typeof params.maxMessageSize !== "number") throw new TypeError("missing params.maxMessageSize");
}
exports.validateSctpParameters = validateSctpParameters;
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */ function validateSctpStreamParameters(params) {
    if (typeof params !== "object") throw new TypeError("params is not an object");
    // streamId is mandatory.
    if (typeof params.streamId !== "number") throw new TypeError("missing params.streamId");
    // ordered is optional.
    let orderedGiven = false;
    if (typeof params.ordered === "boolean") orderedGiven = true;
    else params.ordered = true;
    // maxPacketLifeTime is optional.
    if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== "number") throw new TypeError("invalid params.maxPacketLifeTime");
    // maxRetransmits is optional.
    if (params.maxRetransmits && typeof params.maxRetransmits !== "number") throw new TypeError("invalid params.maxRetransmits");
    if (params.maxPacketLifeTime && params.maxRetransmits) throw new TypeError("cannot provide both maxPacketLifeTime and maxRetransmits");
    if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) throw new TypeError("cannot be ordered with maxPacketLifeTime or maxRetransmits");
    else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) params.ordered = false;
    // label is optional.
    if (params.label && typeof params.label !== "string") throw new TypeError("invalid params.label");
    // protocol is optional.
    if (params.protocol && typeof params.protocol !== "string") throw new TypeError("invalid params.protocol");
}
exports.validateSctpStreamParameters = validateSctpStreamParameters;
/**
 * Generate extended RTP capabilities for sending and receiving.
 */ function getExtendedRtpCapabilities(localCaps, remoteCaps) {
    const extendedRtpCapabilities = {
        codecs: [],
        headerExtensions: []
    };
    // Match media codecs and keep the order preferred by remoteCaps.
    for (const remoteCodec of remoteCaps.codecs || []){
        if (isRtxCodec(remoteCodec)) continue;
        const matchingLocalCodec = (localCaps.codecs || []).find((localCodec)=>matchCodecs(localCodec, remoteCodec, {
                strict: true,
                modify: true
            }));
        if (!matchingLocalCodec) continue;
        const extendedCodec = {
            mimeType: matchingLocalCodec.mimeType,
            kind: matchingLocalCodec.kind,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: undefined,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: undefined,
            localParameters: matchingLocalCodec.parameters,
            remoteParameters: remoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
        };
        extendedRtpCapabilities.codecs.push(extendedCodec);
    }
    // Match RTX codecs.
    for (const extendedCodec of extendedRtpCapabilities.codecs){
        const matchingLocalRtxCodec = localCaps.codecs.find((localCodec)=>isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType);
        const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec)=>isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType);
        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
        }
    }
    // Match header extensions.
    for (const remoteExt of remoteCaps.headerExtensions){
        const matchingLocalExt = localCaps.headerExtensions.find((localExt)=>matchHeaderExtensions(localExt, remoteExt));
        if (!matchingLocalExt) continue;
        const extendedExt = {
            kind: remoteExt.kind,
            uri: remoteExt.uri,
            sendId: matchingLocalExt.preferredId,
            recvId: remoteExt.preferredId,
            encrypt: matchingLocalExt.preferredEncrypt,
            direction: "sendrecv"
        };
        switch(remoteExt.direction){
            case "sendrecv":
                extendedExt.direction = "sendrecv";
                break;
            case "recvonly":
                extendedExt.direction = "sendonly";
                break;
            case "sendonly":
                extendedExt.direction = "recvonly";
                break;
            case "inactive":
                extendedExt.direction = "inactive";
                break;
        }
        extendedRtpCapabilities.headerExtensions.push(extendedExt);
    }
    return extendedRtpCapabilities;
}
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */ function getRecvRtpCapabilities(extendedRtpCapabilities) {
    const rtpCapabilities = {
        codecs: [],
        headerExtensions: []
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs){
        const codec = {
            mimeType: extendedCodec.mimeType,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remotePayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpCapabilities.codecs.push(codec);
        // Add RTX codec.
        if (!extendedCodec.remoteRtxPayloadType) continue;
        const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remoteRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
                apt: extendedCodec.remotePayloadType
            },
            rtcpFeedback: []
        };
        rtpCapabilities.codecs.push(rtxCodec);
    // TODO: In the future, we need to add FEC, CN, etc, codecs.
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions){
        // Ignore RTP extensions not valid for receiving.
        if (extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "recvonly") continue;
        const ext = {
            kind: extendedExtension.kind,
            uri: extendedExtension.uri,
            preferredId: extendedExtension.recvId,
            preferredEncrypt: extendedExtension.encrypt,
            direction: extendedExtension.direction
        };
        rtpCapabilities.headerExtensions.push(ext);
    }
    return rtpCapabilities;
}
exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */ function getSendingRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {}
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs){
        if (extendedCodec.kind !== kind) continue;
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType
                },
                rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions){
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") continue;
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
        };
        rtpParameters.headerExtensions.push(ext);
    }
    return rtpParameters;
}
exports.getSendingRtpParameters = getSendingRtpParameters;
/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */ function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {}
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs){
        if (extendedCodec.kind !== kind) continue;
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.remoteParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType
                },
                rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions){
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") continue;
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
        };
        rtpParameters.headerExtensions.push(ext);
    }
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
    if (rtpParameters.headerExtensions.some((ext)=>ext.uri === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01")) for (const codec of rtpParameters.codecs)codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb)=>fb.type !== "goog-remb");
    else if (rtpParameters.headerExtensions.some((ext)=>ext.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time")) for (const codec of rtpParameters.codecs)codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb)=>fb.type !== "transport-cc");
    else for (const codec of rtpParameters.codecs)codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb)=>fb.type !== "transport-cc" && fb.type !== "goog-remb");
    return rtpParameters;
}
exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */ function reduceCodecs(codecs, capCodec) {
    const filteredCodecs = [];
    // If no capability codec is given, take the first one (and RTX).
    if (!capCodec) {
        filteredCodecs.push(codecs[0]);
        if (isRtxCodec(codecs[1])) filteredCodecs.push(codecs[1]);
    } else {
        for(let idx = 0; idx < codecs.length; ++idx)if (matchCodecs(codecs[idx], capCodec)) {
            filteredCodecs.push(codecs[idx]);
            if (isRtxCodec(codecs[idx + 1])) filteredCodecs.push(codecs[idx + 1]);
            break;
        }
        if (filteredCodecs.length === 0) throw new TypeError("no matching codec found");
    }
    return filteredCodecs;
}
exports.reduceCodecs = reduceCodecs;
/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */ function generateProbatorRtpParameters(videoRtpParameters) {
    // Clone given reference video RTP parameters.
    videoRtpParameters = utils.clone(videoRtpParameters, {});
    // This may throw.
    validateRtpParameters(videoRtpParameters);
    const rtpParameters = {
        mid: RTP_PROBATOR_MID,
        codecs: [],
        headerExtensions: [],
        encodings: [
            {
                ssrc: RTP_PROBATOR_SSRC
            }
        ],
        rtcp: {
            cname: "probator"
        }
    };
    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
    return rtpParameters;
}
exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
/**
 * Whether media can be sent based on the given RTP capabilities.
 */ function canSend(kind, extendedRtpCapabilities) {
    return extendedRtpCapabilities.codecs.some((codec)=>codec.kind === kind);
}
exports.canSend = canSend;
/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */ function canReceive(rtpParameters, extendedRtpCapabilities) {
    // This may throw.
    validateRtpParameters(rtpParameters);
    if (rtpParameters.codecs.length === 0) return false;
    const firstMediaCodec = rtpParameters.codecs[0];
    return extendedRtpCapabilities.codecs.some((codec)=>codec.remotePayloadType === firstMediaCodec.payloadType);
}
exports.canReceive = canReceive;
function isRtxCodec(codec) {
    if (!codec) return false;
    return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec, { strict =false , modify =false  } = {}) {
    const aMimeType = aCodec.mimeType.toLowerCase();
    const bMimeType = bCodec.mimeType.toLowerCase();
    if (aMimeType !== bMimeType) return false;
    if (aCodec.clockRate !== bCodec.clockRate) return false;
    if (aCodec.channels !== bCodec.channels) return false;
    // Per codec special checks.
    switch(aMimeType){
        case "video/h264":
            if (strict) {
                const aPacketizationMode = aCodec.parameters["packetization-mode"] || 0;
                const bPacketizationMode = bCodec.parameters["packetization-mode"] || 0;
                if (aPacketizationMode !== bPacketizationMode) return false;
                if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) return false;
                let selectedProfileLevelId;
                try {
                    selectedProfileLevelId = h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);
                } catch (error) {
                    return false;
                }
                if (modify) {
                    if (selectedProfileLevelId) {
                        aCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                        bCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                    } else {
                        delete aCodec.parameters["profile-level-id"];
                        delete bCodec.parameters["profile-level-id"];
                    }
                }
            }
            break;
        case "video/vp9":
            if (strict) {
                const aProfileId = aCodec.parameters["profile-id"] || 0;
                const bProfileId = bCodec.parameters["profile-id"] || 0;
                if (aProfileId !== bProfileId) return false;
            }
            break;
    }
    return true;
}
function matchHeaderExtensions(aExt, bExt) {
    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) return false;
    if (aExt.uri !== bExt.uri) return false;
    return true;
}
function reduceRtcpFeedback(codecA, codecB) {
    const reducedRtcpFeedback = [];
    for (const aFb of codecA.rtcpFeedback || []){
        const matchingBFb = (codecB.rtcpFeedback || []).find((bFb)=>bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));
        if (matchingBFb) reducedRtcpFeedback.push(matchingBFb);
    }
    return reducedRtcpFeedback;
}

},{"7f75b0114ee974ce":"g79by","d84998caa791f0ed":"6bv4j"}],"g79by":[function(require,module,exports) {
const debug = require("d3757ca6ae295cf8")("h264-profile-level-id");
/* eslint-disable no-console */ debug.log = console.info.bind(console);
/* eslint-enable no-console */ const ProfileConstrainedBaseline = 1;
const ProfileBaseline = 2;
const ProfileMain = 3;
const ProfileConstrainedHigh = 4;
const ProfileHigh = 5;
exports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;
exports.ProfileBaseline = ProfileBaseline;
exports.ProfileMain = ProfileMain;
exports.ProfileConstrainedHigh = ProfileConstrainedHigh;
exports.ProfileHigh = ProfileHigh;
// All values are equal to ten times the level number, except level 1b which is
// special.
const Level1_b = 0;
const Level1 = 10;
const Level1_1 = 11;
const Level1_2 = 12;
const Level1_3 = 13;
const Level2 = 20;
const Level2_1 = 21;
const Level2_2 = 22;
const Level3 = 30;
const Level3_1 = 31;
const Level3_2 = 32;
const Level4 = 40;
const Level4_1 = 41;
const Level4_2 = 42;
const Level5 = 50;
const Level5_1 = 51;
const Level5_2 = 52;
exports.Level1_b = Level1_b;
exports.Level1 = Level1;
exports.Level1_1 = Level1_1;
exports.Level1_2 = Level1_2;
exports.Level1_3 = Level1_3;
exports.Level2 = Level2;
exports.Level2_1 = Level2_1;
exports.Level2_2 = Level2_2;
exports.Level3 = Level3;
exports.Level3_1 = Level3_1;
exports.Level3_2 = Level3_2;
exports.Level4 = Level4;
exports.Level4_1 = Level4_1;
exports.Level4_2 = Level4_2;
exports.Level5 = Level5;
exports.Level5_1 = Level5_1;
exports.Level5_2 = Level5_2;
class ProfileLevelId {
    constructor(profile, level){
        this.profile = profile;
        this.level = level;
    }
}
exports.ProfileLevelId = ProfileLevelId;
// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
const DefaultProfileLevelId = new ProfileLevelId(ProfileConstrainedBaseline, Level3_1);
// For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
// flag specifies if level 1b or level 1.1 is used.
const ConstraintSet3Flag = 0x10;
// Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to be
// either 0 or 1.
class BitPattern {
    constructor(str){
        this._mask = ~byteMaskString("x", str);
        this._maskedValue = byteMaskString("1", str);
    }
    isMatch(value) {
        return this._maskedValue === (value & this._mask);
    }
}
// Class for converting between profile_idc/profile_iop to Profile.
class ProfilePattern {
    constructor(profile_idc, profile_iop, profile){
        this.profile_idc = profile_idc;
        this.profile_iop = profile_iop;
        this.profile = profile;
    }
}
// This is from https://tools.ietf.org/html/rfc6184#section-8.1.
const ProfilePatterns = [
    new ProfilePattern(0x42, new BitPattern("x1xx0000"), ProfileConstrainedBaseline),
    new ProfilePattern(0x4D, new BitPattern("1xxx0000"), ProfileConstrainedBaseline),
    new ProfilePattern(0x58, new BitPattern("11xx0000"), ProfileConstrainedBaseline),
    new ProfilePattern(0x42, new BitPattern("x0xx0000"), ProfileBaseline),
    new ProfilePattern(0x58, new BitPattern("10xx0000"), ProfileBaseline),
    new ProfilePattern(0x4D, new BitPattern("0x0x0000"), ProfileMain),
    new ProfilePattern(0x64, new BitPattern("00000000"), ProfileHigh),
    new ProfilePattern(0x64, new BitPattern("00001100"), ProfileConstrainedHigh)
];
/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 *
 * @param {String} str - profile-level-id value as a string of 3 hex bytes.
 *
 * @returns {ProfileLevelId}
 */ exports.parseProfileLevelId = function(str) {
    // The string should consist of 3 bytes in hexadecimal format.
    if (typeof str !== "string" || str.length !== 6) return null;
    const profile_level_id_numeric = parseInt(str, 16);
    if (profile_level_id_numeric === 0) return null;
    // Separate into three bytes.
    const level_idc = profile_level_id_numeric & 0xFF;
    const profile_iop = profile_level_id_numeric >> 8 & 0xFF;
    const profile_idc = profile_level_id_numeric >> 16 & 0xFF;
    // Parse level based on level_idc and constraint set 3 flag.
    let level;
    switch(level_idc){
        case Level1_1:
            level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;
            break;
        case Level1:
        case Level1_2:
        case Level1_3:
        case Level2:
        case Level2_1:
        case Level2_2:
        case Level3:
        case Level3_1:
        case Level3_2:
        case Level4:
        case Level4_1:
        case Level4_2:
        case Level5:
        case Level5_1:
        case Level5_2:
            level = level_idc;
            break;
        // Unrecognized level_idc.
        default:
            debug("parseProfileLevelId() | unrecognized level_idc:%s", level_idc);
            return null;
    }
    // Parse profile_idc/profile_iop into a Profile enum.
    for (const pattern of ProfilePatterns){
        if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) return new ProfileLevelId(pattern.profile, level);
    }
    debug("parseProfileLevelId() | unrecognized profile_idc/profile_iop combination");
    return null;
};
/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 *
 * @param {ProfileLevelId} profile_level_id
 *
 * @returns {String}
 */ exports.profileLevelIdToString = function(profile_level_id) {
    // Handle special case level == 1b.
    if (profile_level_id.level == Level1_b) switch(profile_level_id.profile){
        case ProfileConstrainedBaseline:
            return "42f00b";
        case ProfileBaseline:
            return "42100b";
        case ProfileMain:
            return "4d100b";
        // Level 1_b is not allowed for other profiles.
        default:
            debug("profileLevelIdToString() | Level 1_b not is allowed for profile:%s", profile_level_id.profile);
            return null;
    }
    let profile_idc_iop_string;
    switch(profile_level_id.profile){
        case ProfileConstrainedBaseline:
            profile_idc_iop_string = "42e0";
            break;
        case ProfileBaseline:
            profile_idc_iop_string = "4200";
            break;
        case ProfileMain:
            profile_idc_iop_string = "4d00";
            break;
        case ProfileConstrainedHigh:
            profile_idc_iop_string = "640c";
            break;
        case ProfileHigh:
            profile_idc_iop_string = "6400";
            break;
        default:
            debug("profileLevelIdToString() | unrecognized profile:%s", profile_level_id.profile);
            return null;
    }
    let levelStr = profile_level_id.level.toString(16);
    if (levelStr.length === 1) levelStr = `0${levelStr}`;
    return `${profile_idc_iop_string}${levelStr}`;
};
/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned if
 * the key is present but the string is invalid.
 *
 * @param {Object} [params={}] - Codec parameters object.
 *
 * @returns {ProfileLevelId}
 */ exports.parseSdpProfileLevelId = function(params = {}) {
    const profile_level_id = params["profile-level-id"];
    return !profile_level_id ? DefaultProfileLevelId : exports.parseProfileLevelId(profile_level_id);
};
/**
 * Returns true if the parameters have the same H264 profile, i.e. the same
 * H264 profile (Baseline, High, etc).
 *
 * @param {Object} [params1={}] - Codec parameters object.
 * @param {Object} [params2={}] - Codec parameters object.
 *
 * @returns {Boolean}
 */ exports.isSameProfile = function(params1 = {}, params2 = {}) {
    const profile_level_id_1 = exports.parseSdpProfileLevelId(params1);
    const profile_level_id_2 = exports.parseSdpProfileLevelId(params2);
    // Compare H264 profiles, but not levels.
    return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
};
/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict superset
 * of the profile in remote_offered_params, we could limit the profile in the
 * answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and level-asymmetry-allowed.
 *
 * @param {Object} [local_supported_params={}]
 * @param {Object} [remote_offered_params={}]
 *
 * @returns {String} Canonical string representation as three hex bytes of the
 *   profile level id, or null if no one of the params have profile-level-id.
 *
 * @throws {TypeError} If Profile mismatch or invalid params.
 */ exports.generateProfileLevelIdForAnswer = function(local_supported_params = {}, remote_offered_params = {}) {
    // If both local and remote params do not contain profile-level-id, they are
    // both using the default profile. In this case, don't return anything.
    if (!local_supported_params["profile-level-id"] && !remote_offered_params["profile-level-id"]) {
        debug("generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params");
        return null;
    }
    // Parse profile-level-ids.
    const local_profile_level_id = exports.parseSdpProfileLevelId(local_supported_params);
    const remote_profile_level_id = exports.parseSdpProfileLevelId(remote_offered_params);
    // The local and remote codec must have valid and equal H264 Profiles.
    if (!local_profile_level_id) throw new TypeError("invalid local_profile_level_id");
    if (!remote_profile_level_id) throw new TypeError("invalid remote_profile_level_id");
    if (local_profile_level_id.profile !== remote_profile_level_id.profile) throw new TypeError("H264 Profile mismatch");
    // Parse level information.
    const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
    const local_level = local_profile_level_id.level;
    const remote_level = remote_profile_level_id.level;
    const min_level = minLevel(local_level, remote_level);
    // Determine answer level. When level asymmetry is not allowed, level upgrade
    // is not allowed, i.e., the level in the answer must be equal to or lower
    // than the level in the offer.
    const answer_level = level_asymmetry_allowed ? local_level : min_level;
    debug("generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]", local_profile_level_id.profile, answer_level);
    // Return the resulting profile-level-id for the answer parameters.
    return exports.profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
};
// Convert a string of 8 characters into a byte where the positions containing
// character c will have their bit set. For example, c = 'x', str = "x1xx0000"
// will return 0b10110000.
function byteMaskString(c, str) {
    return (str[0] === c) << 7 | (str[1] === c) << 6 | (str[2] === c) << 5 | (str[3] === c) << 4 | (str[4] === c) << 3 | (str[5] === c) << 2 | (str[6] === c) << 1 | (str[7] === c) << 0;
}
// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b) {
    if (a === Level1_b) return b !== Level1 && b !== Level1_b;
    if (b === Level1_b) return a !== Level1;
    return a < b;
}
function minLevel(a, b) {
    return isLessLevel(a, b) ? a : b;
}
function isLevelAsymmetryAllowed(params = {}) {
    const level_asymmetry_allowed = params["level-asymmetry-allowed"];
    return level_asymmetry_allowed === 1 || level_asymmetry_allowed === "1";
}

},{"d3757ca6ae295cf8":"l0oUb"}],"cWahd":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Transport = void 0;
const awaitqueue_1 = require("6941e194db7b788");
const queue_microtask_1 = __importDefault(require("d22553ffc2b5238c"));
const Logger_1 = require("41ded07f469838a4");
const EnhancedEventEmitter_1 = require("4e7a025808aad0c2");
const errors_1 = require("c521fa6bff8e286f");
const utils = __importStar(require("aeec95bc37d931dc"));
const ortc = __importStar(require("e6c4d1693836558a"));
const Producer_1 = require("1f3c8612ab69ded9");
const Consumer_1 = require("a21e4015676461ae");
const DataProducer_1 = require("2f8f2feeeeca60ff");
const DataConsumer_1 = require("a3c3ea736ed8e454");
const logger = new Logger_1.Logger("Transport");
class ConsumerCreationTask {
    constructor(consumerOptions){
        this.consumerOptions = consumerOptions;
        this.promise = new Promise((resolve, reject)=>{
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
class Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    constructor({ direction , id , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , appData , handlerFactory , extendedRtpCapabilities , canProduceByKind  }){
        super();
        // Closed flag.
        this._closed = false;
        // Transport connection state.
        this._connectionState = "new";
        // Map of Producers indexed by id.
        this._producers = new Map();
        // Map of Consumers indexed by id.
        this._consumers = new Map();
        // Map of DataProducers indexed by id.
        this._dataProducers = new Map();
        // Map of DataConsumers indexed by id.
        this._dataConsumers = new Map();
        // Whether the Consumer for RTP probation has been created.
        this._probatorConsumerCreated = false;
        // AwaitQueue instance to make async tasks happen sequentially.
        this._awaitQueue = new awaitqueue_1.AwaitQueue();
        // Consumer creation tasks awaiting to be processed.
        this._pendingConsumerTasks = [];
        // Consumer creation in progress flag.
        this._consumerCreationInProgress = false;
        // Consumers pending to be paused.
        this._pendingPauseConsumers = new Map();
        // Consumer pause in progress flag.
        this._consumerPauseInProgress = false;
        // Consumers pending to be resumed.
        this._pendingResumeConsumers = new Map();
        // Consumer resume in progress flag.
        this._consumerResumeInProgress = false;
        // Consumers pending to be closed.
        this._pendingCloseConsumers = new Map();
        // Consumer close in progress flag.
        this._consumerCloseInProgress = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug("constructor() [id:%s, direction:%s]", id, direction);
        this._id = id;
        this._direction = direction;
        this._extendedRtpCapabilities = extendedRtpCapabilities;
        this._canProduceByKind = canProduceByKind;
        this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
        // Clone and sanitize additionalSettings.
        additionalSettings = utils.clone(additionalSettings, {});
        delete additionalSettings.iceServers;
        delete additionalSettings.iceTransportPolicy;
        delete additionalSettings.bundlePolicy;
        delete additionalSettings.rtcpMuxPolicy;
        delete additionalSettings.sdpSemantics;
        this._handler = handlerFactory();
        this._handler.run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities
        });
        this._appData = appData || {};
        this.handleHandler();
    }
    /**
     * Transport id.
     */ get id() {
        return this._id;
    }
    /**
     * Whether the Transport is closed.
     */ get closed() {
        return this._closed;
    }
    /**
     * Transport direction.
     */ get direction() {
        return this._direction;
    }
    /**
     * RTC handler instance.
     */ get handler() {
        return this._handler;
    }
    /**
     * Connection state.
     */ get connectionState() {
        return this._connectionState;
    }
    /**
     * App custom data.
     */ get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    set appData(appData) {
        throw new Error("cannot override appData object");
    }
    get observer() {
        return this._observer;
    }
    /**
     * Close the Transport.
     */ close() {
        if (this._closed) return;
        logger.debug("close()");
        this._closed = true;
        // Stop the AwaitQueue.
        this._awaitQueue.stop();
        // Close the handler.
        this._handler.close();
        // Close all Producers.
        for (const producer of this._producers.values())producer.transportClosed();
        this._producers.clear();
        // Close all Consumers.
        for (const consumer of this._consumers.values())consumer.transportClosed();
        this._consumers.clear();
        // Close all DataProducers.
        for (const dataProducer of this._dataProducers.values())dataProducer.transportClosed();
        this._dataProducers.clear();
        // Close all DataConsumers.
        for (const dataConsumer of this._dataConsumers.values())dataConsumer.transportClosed();
        this._dataConsumers.clear();
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */ async getStats() {
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        return this._handler.getTransportStats();
    }
    /**
     * Restart ICE connection.
     */ async restartIce({ iceParameters  }) {
        logger.debug("restartIce()");
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        else if (!iceParameters) throw new TypeError("missing iceParameters");
        // Enqueue command.
        return this._awaitQueue.push(async ()=>this._handler.restartIce(iceParameters), "transport.restartIce()");
    }
    /**
     * Update ICE servers.
     */ async updateIceServers({ iceServers  } = {}) {
        logger.debug("updateIceServers()");
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        else if (!Array.isArray(iceServers)) throw new TypeError("missing iceServers");
        // Enqueue command.
        return this._awaitQueue.push(async ()=>this._handler.updateIceServers(iceServers), "transport.updateIceServers()");
    }
    /**
     * Create a Producer.
     */ async produce({ track , encodings , codecOptions , codec , stopTracks =true , disableTrackOnPause =true , zeroRtpOnPause =false , appData ={}  } = {}) {
        logger.debug("produce() [track:%o]", track);
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        else if (!track) throw new TypeError("missing track");
        else if (this._direction !== "send") throw new errors_1.UnsupportedError("not a sending Transport");
        else if (!this._canProduceByKind[track.kind]) throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
        else if (track.readyState === "ended") throw new errors_1.InvalidStateError("track ended");
        else if (this.listenerCount("connect") === 0 && this._connectionState === "new") throw new TypeError('no "connect" listener set into this transport');
        else if (this.listenerCount("produce") === 0) throw new TypeError('no "produce" listener set into this transport');
        else if (appData && typeof appData !== "object") throw new TypeError("if given, appData must be an object");
        // Enqueue command.
        return this._awaitQueue.push(async ()=>{
            let normalizedEncodings;
            if (encodings && !Array.isArray(encodings)) throw TypeError("encodings must be an array");
            else if (encodings && encodings.length === 0) normalizedEncodings = undefined;
            else if (encodings) normalizedEncodings = encodings.map((encoding)=>{
                const normalizedEncoding = {
                    active: true
                };
                if (encoding.active === false) normalizedEncoding.active = false;
                if (typeof encoding.dtx === "boolean") normalizedEncoding.dtx = encoding.dtx;
                if (typeof encoding.scalabilityMode === "string") normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                if (typeof encoding.scaleResolutionDownBy === "number") normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                if (typeof encoding.maxBitrate === "number") normalizedEncoding.maxBitrate = encoding.maxBitrate;
                if (typeof encoding.maxFramerate === "number") normalizedEncoding.maxFramerate = encoding.maxFramerate;
                if (typeof encoding.adaptivePtime === "boolean") normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                if (typeof encoding.priority === "string") normalizedEncoding.priority = encoding.priority;
                if (typeof encoding.networkPriority === "string") normalizedEncoding.networkPriority = encoding.networkPriority;
                return normalizedEncoding;
            });
            const { localId , rtpParameters , rtpSender  } = await this._handler.send({
                track,
                encodings: normalizedEncodings,
                codecOptions,
                codec
            });
            try {
                // This will fill rtpParameters's missing fields with default values.
                ortc.validateRtpParameters(rtpParameters);
                const { id  } = await new Promise((resolve, reject)=>{
                    this.safeEmit("produce", {
                        kind: track.kind,
                        rtpParameters,
                        appData
                    }, resolve, reject);
                });
                const producer = new Producer_1.Producer({
                    id,
                    localId,
                    rtpSender,
                    track,
                    rtpParameters,
                    stopTracks,
                    disableTrackOnPause,
                    zeroRtpOnPause,
                    appData
                });
                this._producers.set(producer.id, producer);
                this.handleProducer(producer);
                // Emit observer event.
                this._observer.safeEmit("newproducer", producer);
                return producer;
            } catch (error) {
                this._handler.stopSending(localId).catch(()=>{});
                throw error;
            }
        }, "transport.produce()")// This catch is needed to stop the given track if the command above
        // failed due to closed Transport.
        .catch((error)=>{
            if (stopTracks) try {
                track.stop();
            } catch (error2) {}
            throw error;
        });
    }
    /**
     * Create a Consumer to consume a remote Producer.
     */ async consume({ id , producerId , kind , rtpParameters , streamId , appData ={}  }) {
        logger.debug("consume()");
        rtpParameters = utils.clone(rtpParameters, undefined);
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        else if (this._direction !== "recv") throw new errors_1.UnsupportedError("not a receiving Transport");
        else if (typeof id !== "string") throw new TypeError("missing id");
        else if (typeof producerId !== "string") throw new TypeError("missing producerId");
        else if (kind !== "audio" && kind !== "video") throw new TypeError(`invalid kind '${kind}'`);
        else if (this.listenerCount("connect") === 0 && this._connectionState === "new") throw new TypeError('no "connect" listener set into this transport');
        else if (appData && typeof appData !== "object") throw new TypeError("if given, appData must be an object");
        // Ensure the device can consume it.
        const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);
        if (!canConsume) throw new errors_1.UnsupportedError("cannot consume this Producer");
        const consumerCreationTask = new ConsumerCreationTask({
            id,
            producerId,
            kind,
            rtpParameters,
            streamId,
            appData
        });
        // Store the Consumer creation task.
        this._pendingConsumerTasks.push(consumerCreationTask);
        // There is no Consumer creation in progress, create it now.
        (0, queue_microtask_1.default)(()=>{
            if (this._closed) throw new errors_1.InvalidStateError("closed");
            if (this._consumerCreationInProgress === false) this.createPendingConsumers();
        });
        return consumerCreationTask.promise;
    }
    /**
     * Create a DataProducer
     */ async produceData({ ordered =true , maxPacketLifeTime , maxRetransmits , label ="" , protocol ="" , appData ={}  } = {}) {
        logger.debug("produceData()");
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        else if (this._direction !== "send") throw new errors_1.UnsupportedError("not a sending Transport");
        else if (!this._maxSctpMessageSize) throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
        else if (this.listenerCount("connect") === 0 && this._connectionState === "new") throw new TypeError('no "connect" listener set into this transport');
        else if (this.listenerCount("producedata") === 0) throw new TypeError('no "producedata" listener set into this transport');
        else if (appData && typeof appData !== "object") throw new TypeError("if given, appData must be an object");
        if (maxPacketLifeTime || maxRetransmits) ordered = false;
        // Enqueue command.
        return this._awaitQueue.push(async ()=>{
            const { dataChannel , sctpStreamParameters  } = await this._handler.sendDataChannel({
                ordered,
                maxPacketLifeTime,
                maxRetransmits,
                label,
                protocol
            });
            // This will fill sctpStreamParameters's missing fields with default values.
            ortc.validateSctpStreamParameters(sctpStreamParameters);
            const { id  } = await new Promise((resolve, reject)=>{
                this.safeEmit("producedata", {
                    sctpStreamParameters,
                    label,
                    protocol,
                    appData
                }, resolve, reject);
            });
            const dataProducer = new DataProducer_1.DataProducer({
                id,
                dataChannel,
                sctpStreamParameters,
                appData
            });
            this._dataProducers.set(dataProducer.id, dataProducer);
            this.handleDataProducer(dataProducer);
            // Emit observer event.
            this._observer.safeEmit("newdataproducer", dataProducer);
            return dataProducer;
        }, "transport.produceData()");
    }
    /**
     * Create a DataConsumer
     */ async consumeData({ id , dataProducerId , sctpStreamParameters , label ="" , protocol ="" , appData ={}  }) {
        logger.debug("consumeData()");
        sctpStreamParameters = utils.clone(sctpStreamParameters, undefined);
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        else if (this._direction !== "recv") throw new errors_1.UnsupportedError("not a receiving Transport");
        else if (!this._maxSctpMessageSize) throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
        else if (typeof id !== "string") throw new TypeError("missing id");
        else if (typeof dataProducerId !== "string") throw new TypeError("missing dataProducerId");
        else if (this.listenerCount("connect") === 0 && this._connectionState === "new") throw new TypeError('no "connect" listener set into this transport');
        else if (appData && typeof appData !== "object") throw new TypeError("if given, appData must be an object");
        // This may throw.
        ortc.validateSctpStreamParameters(sctpStreamParameters);
        // Enqueue command.
        return this._awaitQueue.push(async ()=>{
            const { dataChannel  } = await this._handler.receiveDataChannel({
                sctpStreamParameters,
                label,
                protocol
            });
            const dataConsumer = new DataConsumer_1.DataConsumer({
                id,
                dataProducerId,
                dataChannel,
                sctpStreamParameters,
                appData
            });
            this._dataConsumers.set(dataConsumer.id, dataConsumer);
            this.handleDataConsumer(dataConsumer);
            // Emit observer event.
            this._observer.safeEmit("newdataconsumer", dataConsumer);
            return dataConsumer;
        }, "transport.consumeData()");
    }
    // This method is guaranteed to never throw.
    async createPendingConsumers() {
        this._consumerCreationInProgress = true;
        this._awaitQueue.push(async ()=>{
            if (this._pendingConsumerTasks.length === 0) {
                logger.debug("createPendingConsumers() | there is no Consumer to be created");
                return;
            }
            const pendingConsumerTasks = [
                ...this._pendingConsumerTasks
            ];
            // Clear pending Consumer tasks.
            this._pendingConsumerTasks = [];
            // Video Consumer in order to create the probator.
            let videoConsumerForProbator = undefined;
            // Fill options list.
            const optionsList = [];
            for (const task of pendingConsumerTasks){
                const { id , kind , rtpParameters , streamId  } = task.consumerOptions;
                optionsList.push({
                    trackId: id,
                    kind: kind,
                    rtpParameters,
                    streamId
                });
            }
            try {
                const results = await this._handler.receive(optionsList);
                for(let idx = 0; idx < results.length; idx++){
                    const task = pendingConsumerTasks[idx];
                    const result = results[idx];
                    const { id , producerId , kind , rtpParameters , appData  } = task.consumerOptions;
                    const { localId , rtpReceiver , track  } = result;
                    const consumer = new Consumer_1.Consumer({
                        id: id,
                        localId,
                        producerId: producerId,
                        rtpReceiver,
                        track,
                        rtpParameters,
                        appData
                    });
                    this._consumers.set(consumer.id, consumer);
                    this.handleConsumer(consumer);
                    // If this is the first video Consumer and the Consumer for RTP probation
                    // has not yet been created, it's time to create it.
                    if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === "video") videoConsumerForProbator = consumer;
                    // Emit observer event.
                    this._observer.safeEmit("newconsumer", consumer);
                    task.resolve(consumer);
                }
            } catch (error) {
                for (const task of pendingConsumerTasks)task.reject(error);
            }
            // If RTP probation must be handled, do it now.
            if (videoConsumerForProbator) try {
                const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                await this._handler.receive([
                    {
                        trackId: "probator",
                        kind: "video",
                        rtpParameters: probatorRtpParameters
                    }
                ]);
                logger.debug("createPendingConsumers() | Consumer for RTP probation created");
                this._probatorConsumerCreated = true;
            } catch (error) {
                logger.error("createPendingConsumers() | failed to create Consumer for RTP probation:%o", error);
            }
        }, "transport.createPendingConsumers()").then(()=>{
            this._consumerCreationInProgress = false;
            // There are pending Consumer tasks, enqueue their creation.
            if (this._pendingConsumerTasks.length > 0) this.createPendingConsumers();
        })// NOTE: We only get here when the await queue is closed.
        .catch(()=>{});
    }
    pausePendingConsumers() {
        this._consumerPauseInProgress = true;
        this._awaitQueue.push(async ()=>{
            if (this._pendingPauseConsumers.size === 0) {
                logger.debug("pausePendingConsumers() | there is no Consumer to be paused");
                return;
            }
            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
            // Clear pending pause Consumer map.
            this._pendingPauseConsumers.clear();
            try {
                const localIds = pendingPauseConsumers.map((consumer)=>consumer.localId);
                await this._handler.pauseReceiving(localIds);
            } catch (error) {
                logger.error("pausePendingConsumers() | failed to pause Consumers:", error);
            }
        }, "transport.pausePendingConsumers").then(()=>{
            this._consumerPauseInProgress = false;
            // There are pending Consumers to be paused, do it.
            if (this._pendingPauseConsumers.size > 0) this.pausePendingConsumers();
        })// NOTE: We only get here when the await queue is closed.
        .catch(()=>{});
    }
    resumePendingConsumers() {
        this._consumerResumeInProgress = true;
        this._awaitQueue.push(async ()=>{
            if (this._pendingResumeConsumers.size === 0) {
                logger.debug("resumePendingConsumers() | there is no Consumer to be resumed");
                return;
            }
            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
            // Clear pending resume Consumer map.
            this._pendingResumeConsumers.clear();
            try {
                const localIds = pendingResumeConsumers.map((consumer)=>consumer.localId);
                await this._handler.resumeReceiving(localIds);
            } catch (error) {
                logger.error("resumePendingConsumers() | failed to resume Consumers:", error);
            }
        }, "transport.resumePendingConsumers").then(()=>{
            this._consumerResumeInProgress = false;
            // There are pending Consumer to be resumed, do it.
            if (this._pendingResumeConsumers.size > 0) this.resumePendingConsumers();
        })// NOTE: We only get here when the await queue is closed.
        .catch(()=>{});
    }
    closePendingConsumers() {
        this._consumerCloseInProgress = true;
        this._awaitQueue.push(async ()=>{
            if (this._pendingCloseConsumers.size === 0) {
                logger.debug("closePendingConsumers() | there is no Consumer to be closed");
                return;
            }
            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
            // Clear pending close Consumer map.
            this._pendingCloseConsumers.clear();
            try {
                await this._handler.stopReceiving(pendingCloseConsumers.map((consumer)=>consumer.localId));
            } catch (error) {
                logger.error("closePendingConsumers() | failed to close Consumers:", error);
            }
        }, "transport.closePendingConsumers").then(()=>{
            this._consumerCloseInProgress = false;
            // There are pending Consumer to be resumed, do it.
            if (this._pendingCloseConsumers.size > 0) this.closePendingConsumers();
        })// NOTE: We only get here when the await queue is closed.
        .catch(()=>{});
    }
    handleHandler() {
        const handler = this._handler;
        handler.on("@connect", ({ dtlsParameters  }, callback, errback)=>{
            if (this._closed) {
                errback(new errors_1.InvalidStateError("closed"));
                return;
            }
            this.safeEmit("connect", {
                dtlsParameters
            }, callback, errback);
        });
        handler.on("@connectionstatechange", (connectionState)=>{
            if (connectionState === this._connectionState) return;
            logger.debug("connection state changed to %s", connectionState);
            this._connectionState = connectionState;
            if (!this._closed) this.safeEmit("connectionstatechange", connectionState);
        });
    }
    handleProducer(producer) {
        producer.on("@close", ()=>{
            this._producers.delete(producer.id);
            if (this._closed) return;
            this._awaitQueue.push(async ()=>this._handler.stopSending(producer.localId), "producer @close event").catch((error)=>logger.warn("producer.close() failed:%o", error));
        });
        producer.on("@pause", (callback, errback)=>{
            this._awaitQueue.push(async ()=>this._handler.pauseSending(producer.localId), "producer @pause event").then(callback).catch(errback);
        });
        producer.on("@resume", (callback, errback)=>{
            this._awaitQueue.push(async ()=>this._handler.resumeSending(producer.localId), "producer @resume event").then(callback).catch(errback);
        });
        producer.on("@replacetrack", (track, callback, errback)=>{
            this._awaitQueue.push(async ()=>this._handler.replaceTrack(producer.localId, track), "producer @replacetrack event").then(callback).catch(errback);
        });
        producer.on("@setmaxspatiallayer", (spatialLayer, callback, errback)=>{
            this._awaitQueue.push(async ()=>this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), "producer @setmaxspatiallayer event").then(callback).catch(errback);
        });
        producer.on("@setrtpencodingparameters", (params, callback, errback)=>{
            this._awaitQueue.push(async ()=>this._handler.setRtpEncodingParameters(producer.localId, params), "producer @setrtpencodingparameters event").then(callback).catch(errback);
        });
        producer.on("@getstats", (callback, errback)=>{
            if (this._closed) return errback(new errors_1.InvalidStateError("closed"));
            this._handler.getSenderStats(producer.localId).then(callback).catch(errback);
        });
    }
    handleConsumer(consumer) {
        consumer.on("@close", ()=>{
            this._consumers.delete(consumer.id);
            this._pendingPauseConsumers.delete(consumer.id);
            this._pendingResumeConsumers.delete(consumer.id);
            if (this._closed) return;
            // Store the Consumer into the close list.
            this._pendingCloseConsumers.set(consumer.id, consumer);
            // There is no Consumer close in progress, do it now.
            if (this._consumerCloseInProgress === false) this.closePendingConsumers();
        });
        consumer.on("@pause", ()=>{
            // If Consumer is pending to be resumed, remove from pending resume list.
            if (this._pendingResumeConsumers.has(consumer.id)) this._pendingResumeConsumers.delete(consumer.id);
            // Store the Consumer into the pending list.
            this._pendingPauseConsumers.set(consumer.id, consumer);
            // There is no Consumer pause in progress, do it now.
            (0, queue_microtask_1.default)(()=>{
                if (this._closed) return;
                if (this._consumerPauseInProgress === false) this.pausePendingConsumers();
            });
        });
        consumer.on("@resume", ()=>{
            // If Consumer is pending to be paused, remove from pending pause list.
            if (this._pendingPauseConsumers.has(consumer.id)) this._pendingPauseConsumers.delete(consumer.id);
            // Store the Consumer into the pending list.
            this._pendingResumeConsumers.set(consumer.id, consumer);
            // There is no Consumer resume in progress, do it now.
            (0, queue_microtask_1.default)(()=>{
                if (this._closed) return;
                if (this._consumerResumeInProgress === false) this.resumePendingConsumers();
            });
        });
        consumer.on("@getstats", (callback, errback)=>{
            if (this._closed) return errback(new errors_1.InvalidStateError("closed"));
            this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);
        });
    }
    handleDataProducer(dataProducer) {
        dataProducer.on("@close", ()=>{
            this._dataProducers.delete(dataProducer.id);
        });
    }
    handleDataConsumer(dataConsumer) {
        dataConsumer.on("@close", ()=>{
            this._dataConsumers.delete(dataConsumer.id);
        });
    }
}
exports.Transport = Transport;

},{"6941e194db7b788":"3j2hC","d22553ffc2b5238c":"fQqUJ","41ded07f469838a4":"co3ME","4e7a025808aad0c2":"4Z8Ic","c521fa6bff8e286f":"Xq57d","aeec95bc37d931dc":"6bv4j","e6c4d1693836558a":"jtITX","1f3c8612ab69ded9":"50WSJ","a21e4015676461ae":"fFe3n","2f8f2feeeeca60ff":"jIr6O","a3c3ea736ed8e454":"6C20m"}],"3j2hC":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
const Logger_1 = require("2f67388a911b7fc5");
const logger = new Logger_1.Logger();
/**
 * Custom Error derived class used to reject pending tasks once stop() method
 * has been called.
 */ class AwaitQueueStoppedError extends Error {
    constructor(message){
        super(message !== null && message !== void 0 ? message : "AwaitQueue stopped");
        this.name = "AwaitQueueStoppedError";
        // @ts-ignore
        if (typeof Error.captureStackTrace === "function") // @ts-ignore
        Error.captureStackTrace(this, AwaitQueueStoppedError);
    }
}
exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
/**
 * Custom Error derived class used to reject pending tasks once removeTask()
 * method has been called.
 */ class AwaitQueueRemovedTaskError extends Error {
    constructor(message){
        super(message !== null && message !== void 0 ? message : "AwaitQueue task removed");
        this.name = "AwaitQueueRemovedTaskError";
        // @ts-ignore
        if (typeof Error.captureStackTrace === "function") // @ts-ignore
        Error.captureStackTrace(this, AwaitQueueRemovedTaskError);
    }
}
exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
class AwaitQueue {
    constructor(){
        // Queue of pending tasks (map of PendingTasks indexed by id).
        this.pendingTasks = new Map();
        // Incrementing PendingTask id.
        this.nextTaskId = 0;
        // Whether stop() method is stopping all pending tasks.
        this.stopping = false;
    }
    get size() {
        return this.pendingTasks.size;
    }
    async push(task, name) {
        name = name !== null && name !== void 0 ? name : task.name;
        logger.debug(`push() [name:${name}]`);
        if (typeof task !== "function") throw new TypeError("given task is not a function");
        if (name) try {
            Object.defineProperty(task, "name", {
                value: name
            });
        } catch (error) {}
        return new Promise((resolve, reject)=>{
            const pendingTask = {
                id: this.nextTaskId++,
                task: task,
                name: name,
                enqueuedAt: Date.now(),
                executedAt: undefined,
                completed: false,
                resolve: (result)=>{
                    // pendingTask.resolve() can only be called in execute() method. Since
                    // resolve() was called it means that the task successfully completed.
                    // However the task may have been stopped before it completed (via
                    // stop() or remove()) so its completed flag was already set. If this
                    // is the case, abort here since next task (if any) is already being
                    // executed.
                    if (pendingTask.completed) return;
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    this.pendingTasks.delete(pendingTask.id);
                    logger.debug(`resolving task [name:${pendingTask.name}]`);
                    // Resolve the task with the obtained result.
                    resolve(result);
                    // Execute the next pending task (if any).
                    const [nextPendingTask] = this.pendingTasks.values();
                    // NOTE: During the resolve() callback the user app may have interacted
                    // with the queue. For instance, the app may have pushed a task while
                    // the queue was empty so such a task is already being executed. If so,
                    // don't execute it twice.
                    if (nextPendingTask && !nextPendingTask.executedAt) this.execute(nextPendingTask);
                },
                reject: (error)=>{
                    // pendingTask.reject() can be called within execute() method if the
                    // task completed with error. However it may have also been called in
                    // stop() or remove() methods (before or while being executed) so its
                    // completed flag was already set. If so, abort here since next task
                    // (if any) is already being executed.
                    if (pendingTask.completed) return;
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    this.pendingTasks.delete(pendingTask.id);
                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
                    // Reject the task with the obtained error.
                    reject(error);
                    // Execute the next pending task (if any) unless stop() is running.
                    if (!this.stopping) {
                        const [nextPendingTask] = this.pendingTasks.values();
                        // NOTE: During the reject() callback the user app may have interacted
                        // with the queue. For instance, the app may have pushed a task while
                        // the queue was empty so such a task is already being executed. If so,
                        // don't execute it twice.
                        if (nextPendingTask && !nextPendingTask.executedAt) this.execute(nextPendingTask);
                    }
                }
            };
            // Append task to the queue.
            this.pendingTasks.set(pendingTask.id, pendingTask);
            // And execute it if this is the only task in the queue.
            if (this.pendingTasks.size === 1) this.execute(pendingTask);
        });
    }
    stop() {
        logger.debug("stop()");
        this.stopping = true;
        for (const pendingTask of this.pendingTasks.values()){
            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);
            pendingTask.reject(new AwaitQueueStoppedError());
        }
        this.stopping = false;
    }
    remove(taskIdx) {
        logger.debug(`remove() [taskIdx:${taskIdx}]`);
        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
        if (!pendingTask) {
            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
            return;
        }
        pendingTask.reject(new AwaitQueueRemovedTaskError());
    }
    dump() {
        const now = Date.now();
        let idx = 0;
        return Array.from(this.pendingTasks.values()).map((pendingTask)=>({
                idx: idx++,
                task: pendingTask.task,
                name: pendingTask.name,
                enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
                executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
            }));
    }
    async execute(pendingTask) {
        logger.debug(`execute() [name:${pendingTask.name}]`);
        if (pendingTask.executedAt) throw new Error("task already being executed");
        pendingTask.executedAt = Date.now();
        try {
            const result = await pendingTask.task();
            // Resolve the task with its resolved result (if any).
            pendingTask.resolve(result);
        } catch (error) {
            // Reject the task with its rejected error.
            pendingTask.reject(error);
        }
    }
}
exports.AwaitQueue = AwaitQueue;

},{"2f67388a911b7fc5":"lyhd7"}],"lyhd7":[function(require,module,exports) {
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Logger = void 0;
const debug_1 = __importDefault(require("a10be7467674e5e7"));
const LIB_NAME = "awaitqueue";
class Logger {
    constructor(prefix){
        if (prefix) {
            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);
        } else {
            this._debug = (0, debug_1.default)(LIB_NAME);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);
        }
        /* eslint-disable no-console */ this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
    /* eslint-enable no-console */ }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;

},{"a10be7467674e5e7":"l0oUb"}],"fQqUJ":[function(require,module,exports) {
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var global = arguments[3];
let promise;
module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb)=>(promise || (promise = Promise.resolve())).then(cb).catch((err)=>setTimeout(()=>{
            throw err;
        }, 0));

},{}],"50WSJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Producer = void 0;
const Logger_1 = require("92a902144589025c");
const EnhancedEventEmitter_1 = require("eab20e0844c0e443");
const errors_1 = require("812de36ca48f40aa");
const logger = new Logger_1.Logger("Producer");
class Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    constructor({ id , localId , rtpSender , track , rtpParameters , stopTracks , disableTrackOnPause , zeroRtpOnPause , appData  }){
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug("constructor()");
        this._id = id;
        this._localId = localId;
        this._rtpSender = rtpSender;
        this._track = track;
        this._kind = track.kind;
        this._rtpParameters = rtpParameters;
        this._paused = disableTrackOnPause ? !track.enabled : false;
        this._maxSpatialLayer = undefined;
        this._stopTracks = stopTracks;
        this._disableTrackOnPause = disableTrackOnPause;
        this._zeroRtpOnPause = zeroRtpOnPause;
        this._appData = appData || {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
        // '@replacetrack' event here, so RTCRtpSender.track won't be null.
        this.handleTrack();
    }
    /**
     * Producer id.
     */ get id() {
        return this._id;
    }
    /**
     * Local id.
     */ get localId() {
        return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */ get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */ get kind() {
        return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */ get rtpSender() {
        return this._rtpSender;
    }
    /**
     * The associated track.
     */ get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */ get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */ get paused() {
        return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */ get maxSpatialLayer() {
        return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */ get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    set appData(appData) {
        throw new Error("cannot override appData object");
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Producer.
     */ close() {
        if (this._closed) return;
        logger.debug("close()");
        this._closed = true;
        this.destroyTrack();
        this.emit("@close");
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    /**
     * Transport was closed.
     */ transportClosed() {
        if (this._closed) return;
        logger.debug("transportClosed()");
        this._closed = true;
        this.destroyTrack();
        this.safeEmit("transportclose");
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    /**
     * Get associated RTCRtpSender stats.
     */ async getStats() {
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        return new Promise((resolve, reject)=>{
            this.safeEmit("@getstats", resolve, reject);
        });
    }
    /**
     * Pauses sending media.
     */ pause() {
        logger.debug("pause()");
        if (this._closed) {
            logger.error("pause() | Producer closed");
            return;
        }
        this._paused = true;
        if (this._track && this._disableTrackOnPause) this._track.enabled = false;
        if (this._zeroRtpOnPause) new Promise((resolve, reject)=>{
            this.safeEmit("@pause", resolve, reject);
        }).catch(()=>{});
        // Emit observer event.
        this._observer.safeEmit("pause");
    }
    /**
     * Resumes sending media.
     */ resume() {
        logger.debug("resume()");
        if (this._closed) {
            logger.error("resume() | Producer closed");
            return;
        }
        this._paused = false;
        if (this._track && this._disableTrackOnPause) this._track.enabled = true;
        if (this._zeroRtpOnPause) new Promise((resolve, reject)=>{
            this.safeEmit("@resume", resolve, reject);
        }).catch(()=>{});
        // Emit observer event.
        this._observer.safeEmit("resume");
    }
    /**
     * Replaces the current track with a new one or null.
     */ async replaceTrack({ track  }) {
        logger.debug("replaceTrack() [track:%o]", track);
        if (this._closed) {
            // This must be done here. Otherwise there is no chance to stop the given
            // track.
            if (track && this._stopTracks) try {
                track.stop();
            } catch (error) {}
            throw new errors_1.InvalidStateError("closed");
        } else if (track && track.readyState === "ended") throw new errors_1.InvalidStateError("track ended");
        // Do nothing if this is the same track as the current handled one.
        if (track === this._track) {
            logger.debug("replaceTrack() | same track, ignored");
            return;
        }
        await new Promise((resolve, reject)=>{
            this.safeEmit("@replacetrack", track, resolve, reject);
        });
        // Destroy the previous track.
        this.destroyTrack();
        // Set the new track.
        this._track = track;
        // If this Producer was paused/resumed and the state of the new
        // track does not match, fix it.
        if (this._track && this._disableTrackOnPause) {
            if (!this._paused) this._track.enabled = true;
            else if (this._paused) this._track.enabled = false;
        }
        // Handle the effective track.
        this.handleTrack();
    }
    /**
     * Sets the video max spatial layer to be sent.
     */ async setMaxSpatialLayer(spatialLayer) {
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        else if (this._kind !== "video") throw new errors_1.UnsupportedError("not a video Producer");
        else if (typeof spatialLayer !== "number") throw new TypeError("invalid spatialLayer");
        if (spatialLayer === this._maxSpatialLayer) return;
        await new Promise((resolve, reject)=>{
            this.safeEmit("@setmaxspatiallayer", spatialLayer, resolve, reject);
        }).catch(()=>{});
        this._maxSpatialLayer = spatialLayer;
    }
    async setRtpEncodingParameters(params) {
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        else if (typeof params !== "object") throw new TypeError("invalid params");
        await new Promise((resolve, reject)=>{
            this.safeEmit("@setrtpencodingparameters", params, resolve, reject);
        });
    }
    onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit("trackended");
        // Emit observer event.
        this._observer.safeEmit("trackended");
    }
    handleTrack() {
        if (!this._track) return;
        this._track.addEventListener("ended", this.onTrackEnded);
    }
    destroyTrack() {
        if (!this._track) return;
        try {
            this._track.removeEventListener("ended", this.onTrackEnded);
            // Just stop the track unless the app set stopTracks: false.
            if (this._stopTracks) this._track.stop();
        } catch (error) {}
    }
}
exports.Producer = Producer;

},{"92a902144589025c":"co3ME","eab20e0844c0e443":"4Z8Ic","812de36ca48f40aa":"Xq57d"}],"fFe3n":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Consumer = void 0;
const Logger_1 = require("12da7b66306fab3a");
const EnhancedEventEmitter_1 = require("50935573657c9ece");
const errors_1 = require("12c62b843a2aeba0");
const logger = new Logger_1.Logger("Consumer");
class Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    constructor({ id , localId , producerId , rtpReceiver , track , rtpParameters , appData  }){
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug("constructor()");
        this._id = id;
        this._localId = localId;
        this._producerId = producerId;
        this._rtpReceiver = rtpReceiver;
        this._track = track;
        this._rtpParameters = rtpParameters;
        this._paused = !track.enabled;
        this._appData = appData || {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        this.handleTrack();
    }
    /**
     * Consumer id.
     */ get id() {
        return this._id;
    }
    /**
     * Local id.
     */ get localId() {
        return this._localId;
    }
    /**
     * Associated Producer id.
     */ get producerId() {
        return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */ get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */ get kind() {
        return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */ get rtpReceiver() {
        return this._rtpReceiver;
    }
    /**
     * The associated track.
     */ get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */ get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */ get paused() {
        return this._paused;
    }
    /**
     * App custom data.
     */ get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    set appData(appData) {
        throw new Error("cannot override appData object");
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Consumer.
     */ close() {
        if (this._closed) return;
        logger.debug("close()");
        this._closed = true;
        this.destroyTrack();
        this.emit("@close");
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    /**
     * Transport was closed.
     */ transportClosed() {
        if (this._closed) return;
        logger.debug("transportClosed()");
        this._closed = true;
        this.destroyTrack();
        this.safeEmit("transportclose");
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */ async getStats() {
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        return new Promise((resolve, reject)=>{
            this.safeEmit("@getstats", resolve, reject);
        });
    }
    /**
     * Pauses receiving media.
     */ pause() {
        logger.debug("pause()");
        if (this._closed) {
            logger.error("pause() | Consumer closed");
            return;
        }
        if (this._paused) {
            logger.debug("pause() | Consumer is already paused");
            return;
        }
        this._paused = true;
        this._track.enabled = false;
        this.emit("@pause");
        // Emit observer event.
        this._observer.safeEmit("pause");
    }
    /**
     * Resumes receiving media.
     */ resume() {
        logger.debug("resume()");
        if (this._closed) {
            logger.error("resume() | Consumer closed");
            return;
        }
        if (!this._paused) {
            logger.debug("resume() | Consumer is already resumed");
            return;
        }
        this._paused = false;
        this._track.enabled = true;
        this.emit("@resume");
        // Emit observer event.
        this._observer.safeEmit("resume");
    }
    onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit("trackended");
        // Emit observer event.
        this._observer.safeEmit("trackended");
    }
    handleTrack() {
        this._track.addEventListener("ended", this.onTrackEnded);
    }
    destroyTrack() {
        try {
            this._track.removeEventListener("ended", this.onTrackEnded);
            this._track.stop();
        } catch (error) {}
    }
}
exports.Consumer = Consumer;

},{"12da7b66306fab3a":"co3ME","50935573657c9ece":"4Z8Ic","12c62b843a2aeba0":"Xq57d"}],"jIr6O":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataProducer = void 0;
const Logger_1 = require("6c35ac55a2fe664");
const EnhancedEventEmitter_1 = require("3b1d8a2fb8e07813");
const errors_1 = require("175c949828acb484");
const logger = new Logger_1.Logger("DataProducer");
class DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    constructor({ id , dataChannel , sctpStreamParameters , appData  }){
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug("constructor()");
        this._id = id;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData || {};
        this.handleDataChannel();
    }
    /**
     * DataProducer id.
     */ get id() {
        return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */ get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */ get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */ get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */ get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */ get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */ get bufferedAmount() {
        return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */ get bufferedAmountLowThreshold() {
        return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */ set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */ get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    set appData(appData) {
        throw new Error("cannot override appData object");
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataProducer.
     */ close() {
        if (this._closed) return;
        logger.debug("close()");
        this._closed = true;
        this._dataChannel.close();
        this.emit("@close");
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    /**
     * Transport was closed.
     */ transportClosed() {
        if (this._closed) return;
        logger.debug("transportClosed()");
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit("transportclose");
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */ send(data) {
        logger.debug("send()");
        if (this._closed) throw new errors_1.InvalidStateError("closed");
        this._dataChannel.send(data);
    }
    handleDataChannel() {
        this._dataChannel.addEventListener("open", ()=>{
            if (this._closed) return;
            logger.debug('DataChannel "open" event');
            this.safeEmit("open");
        });
        this._dataChannel.addEventListener("error", (event)=>{
            if (this._closed) return;
            let { error  } = event;
            if (!error) error = new Error("unknown DataChannel error");
            if (error.errorDetail === "sctp-failure") logger.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", error.sctpCauseCode, error.message);
            else logger.error('DataChannel "error" event: %o', error);
            this.safeEmit("error", error);
        });
        this._dataChannel.addEventListener("close", ()=>{
            if (this._closed) return;
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit("@close");
            this.safeEmit("close");
            // Emit observer event.
            this._observer.safeEmit("close");
        });
        this._dataChannel.addEventListener("message", ()=>{
            if (this._closed) return;
            logger.warn('DataChannel "message" event in a DataProducer, message discarded');
        });
        this._dataChannel.addEventListener("bufferedamountlow", ()=>{
            if (this._closed) return;
            this.safeEmit("bufferedamountlow");
        });
    }
}
exports.DataProducer = DataProducer;

},{"6c35ac55a2fe664":"co3ME","3b1d8a2fb8e07813":"4Z8Ic","175c949828acb484":"Xq57d"}],"6C20m":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataConsumer = void 0;
const Logger_1 = require("c734ea082cd848cf");
const EnhancedEventEmitter_1 = require("791c1bd51273c148");
const logger = new Logger_1.Logger("DataConsumer");
class DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    constructor({ id , dataProducerId , dataChannel , sctpStreamParameters , appData  }){
        super();
        // Closed flag.
        this._closed = false;
        // Observer instance.
        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
        logger.debug("constructor()");
        this._id = id;
        this._dataProducerId = dataProducerId;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData || {};
        this.handleDataChannel();
    }
    /**
     * DataConsumer id.
     */ get id() {
        return this._id;
    }
    /**
     * Associated DataProducer id.
     */ get dataProducerId() {
        return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */ get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */ get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */ get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */ get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */ get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */ get binaryType() {
        return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */ set binaryType(binaryType) {
        this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */ get appData() {
        return this._appData;
    }
    /**
     * Invalid setter.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    set appData(appData) {
        throw new Error("cannot override appData object");
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */ close() {
        if (this._closed) return;
        logger.debug("close()");
        this._closed = true;
        this._dataChannel.close();
        this.emit("@close");
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    /**
     * Transport was closed.
     */ transportClosed() {
        if (this._closed) return;
        logger.debug("transportClosed()");
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit("transportclose");
        // Emit observer event.
        this._observer.safeEmit("close");
    }
    handleDataChannel() {
        this._dataChannel.addEventListener("open", ()=>{
            if (this._closed) return;
            logger.debug('DataChannel "open" event');
            this.safeEmit("open");
        });
        this._dataChannel.addEventListener("error", (event)=>{
            if (this._closed) return;
            let { error  } = event;
            if (!error) error = new Error("unknown DataChannel error");
            if (error.errorDetail === "sctp-failure") logger.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", error.sctpCauseCode, error.message);
            else logger.error('DataChannel "error" event: %o', error);
            this.safeEmit("error", error);
        });
        this._dataChannel.addEventListener("close", ()=>{
            if (this._closed) return;
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit("@close");
            this.safeEmit("close");
            // Emit observer event.
            this._observer.safeEmit("close");
        });
        this._dataChannel.addEventListener("message", (event)=>{
            if (this._closed) return;
            this.safeEmit("message", event.data);
        });
    }
}
exports.DataConsumer = DataConsumer;

},{"c734ea082cd848cf":"co3ME","791c1bd51273c148":"4Z8Ic"}],"bmuYv":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chrome111 = void 0;
const sdpTransform = __importStar(require("ce77d6c9653c9ec1"));
const Logger_1 = require("83bc9166b1e42c45");
const utils = __importStar(require("453ee78bb1655e32"));
const ortc = __importStar(require("db511526b51baecd"));
const sdpCommonUtils = __importStar(require("83c8b7e9475dad2"));
const sdpUnifiedPlanUtils = __importStar(require("1f4bfed84362f47f"));
const ortcUtils = __importStar(require("f5f7df0f34ca7084"));
const HandlerInterface_1 = require("957d9cd5dbb6d264");
const RemoteSdp_1 = require("a36335ed678558c8");
const scalabilityModes_1 = require("7b32278d83e83e3e");
const logger = new Logger_1.Logger("Chrome111");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class Chrome111 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Chrome111();
    }
    constructor(){
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Chrome111";
    }
    close() {
        logger.debug("close()");
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
        });
        try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else {
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            this._pc.addEventListener("iceconnectionstatechange", ()=>{
                switch(this._pc.iceConnectionState){
                    case "checking":
                        this.emit("@connectionstatechange", "connecting");
                        break;
                    case "connected":
                    case "completed":
                        this.emit("@connectionstatechange", "connected");
                        break;
                    case "failed":
                        this.emit("@connectionstatechange", "failed");
                        break;
                    case "disconnected":
                        this.emit("@connectionstatechange", "disconnected");
                        break;
                    case "closed":
                        this.emit("@connectionstatechange", "closed");
                        break;
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx)=>{
                encoding.rid = `r${idx}`;
            });
            // Set rid and verify scalabilityMode in each encoding.
            // NOTE: Even if WebRTC allows different scalabilityMode (different number
            // of temporal layers) per simulcast stream, we need that those are the
            // same in all them, so let's pick up the highest value.
            // NOTE: If scalabilityMode is not given, Chrome will use L1T3.
            let nextRid = 1;
            let maxTemporalLayers = 1;
            for (const encoding of encodings){
                const temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
                if (temporalLayers > maxTemporalLayers) maxTemporalLayers = temporalLayers;
            }
            for (const encoding of encodings){
                encoding.rid = `r${nextRid++}`;
                encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
            }
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [
                this._sendStream
            ],
            sendEncodings: encodings
        });
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
        });
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        } else sendingRtpParameters.encodings = encodings;
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) try {
            transceiver.stop();
        } catch (error) {}
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "sendonly";
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx <= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { trackId , rtpParameters  } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { trackId  } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t)=>t.mid === localId);
            if (!transceiver) throw new Error("new RTCRtpTransceiver not found");
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds)this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.Chrome111 = Chrome111;

},{"ce77d6c9653c9ec1":"8vPQN","83bc9166b1e42c45":"co3ME","453ee78bb1655e32":"6bv4j","db511526b51baecd":"jtITX","83c8b7e9475dad2":"f6oEu","1f4bfed84362f47f":"3n46G","f5f7df0f34ca7084":"jQP2l","957d9cd5dbb6d264":"50jj4","a36335ed678558c8":"fsxdK","7b32278d83e83e3e":"hE1NO"}],"f6oEu":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;
const sdpTransform = __importStar(require("a92b233ce8707f8"));
/**
 * This function must be called with an SDP with 1 m=audio and 1 m=video
 * sections.
 */ function extractRtpCapabilities({ sdpObject  }) {
    // Map of RtpCodecParameters indexed by payload type.
    const codecsMap = new Map();
    // Array of RtpHeaderExtensions.
    const headerExtensions = [];
    // Whether a m=audio/video section has been already found.
    let gotAudio = false;
    let gotVideo = false;
    for (const m of sdpObject.media){
        const kind = m.type;
        switch(kind){
            case "audio":
                if (gotAudio) continue;
                gotAudio = true;
                break;
            case "video":
                if (gotVideo) continue;
                gotVideo = true;
                break;
            default:
                continue;
        }
        // Get codecs.
        for (const rtp of m.rtp){
            const codec = {
                kind: kind,
                mimeType: `${kind}/${rtp.codec}`,
                preferredPayloadType: rtp.payload,
                clockRate: rtp.rate,
                channels: rtp.encoding,
                parameters: {},
                rtcpFeedback: []
            };
            codecsMap.set(codec.preferredPayloadType, codec);
        }
        // Get codec parameters.
        for (const fmtp of m.fmtp || []){
            const parameters = sdpTransform.parseParams(fmtp.config);
            const codec = codecsMap.get(fmtp.payload);
            if (!codec) continue;
            // Specials case to convert parameter value to string.
            if (parameters && parameters.hasOwnProperty("profile-level-id")) parameters["profile-level-id"] = String(parameters["profile-level-id"]);
            codec.parameters = parameters;
        }
        // Get RTCP feedback for each codec.
        for (const fb of m.rtcpFb || []){
            const feedback = {
                type: fb.type,
                parameter: fb.subtype
            };
            if (!feedback.parameter) delete feedback.parameter;
            // rtcp-fb payload is not '*', so just apply it to its corresponding
            // codec.
            if (fb.payload !== "*") {
                const codec = codecsMap.get(fb.payload);
                if (!codec) continue;
                codec.rtcpFeedback.push(feedback);
            } else {
                for (const codec of codecsMap.values())if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) codec.rtcpFeedback.push(feedback);
            }
        }
        // Get RTP header extensions.
        for (const ext of m.ext || []){
            // Ignore encrypted extensions (not yet supported in mediasoup).
            if (ext["encrypt-uri"]) continue;
            const headerExtension = {
                kind: kind,
                uri: ext.uri,
                preferredId: ext.value
            };
            headerExtensions.push(headerExtension);
        }
    }
    const rtpCapabilities = {
        codecs: Array.from(codecsMap.values()),
        headerExtensions: headerExtensions
    };
    return rtpCapabilities;
}
exports.extractRtpCapabilities = extractRtpCapabilities;
function extractDtlsParameters({ sdpObject  }) {
    const mediaObject = (sdpObject.media || []).find((m)=>m.iceUfrag && m.port !== 0);
    if (!mediaObject) throw new Error("no active media section found");
    const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;
    let role;
    switch(mediaObject.setup){
        case "active":
            role = "client";
            break;
        case "passive":
            role = "server";
            break;
        case "actpass":
            role = "auto";
            break;
    }
    const dtlsParameters = {
        role,
        fingerprints: [
            {
                algorithm: fingerprint.type,
                value: fingerprint.hash
            }
        ]
    };
    return dtlsParameters;
}
exports.extractDtlsParameters = extractDtlsParameters;
function getCname({ offerMediaObject  }) {
    const ssrcCnameLine = (offerMediaObject.ssrcs || []).find((line)=>line.attribute === "cname");
    if (!ssrcCnameLine) return "";
    return ssrcCnameLine.value;
}
exports.getCname = getCname;
/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */ function applyCodecParameters({ offerRtpParameters , answerMediaObject  }) {
    for (const codec of offerRtpParameters.codecs){
        const mimeType = codec.mimeType.toLowerCase();
        // Avoid parsing codec parameters for unhandled codecs.
        if (mimeType !== "audio/opus") continue;
        const rtp = (answerMediaObject.rtp || []).find((r)=>r.payload === codec.payloadType);
        if (!rtp) continue;
        // Just in case.
        answerMediaObject.fmtp = answerMediaObject.fmtp || [];
        let fmtp = answerMediaObject.fmtp.find((f)=>f.payload === codec.payloadType);
        if (!fmtp) {
            fmtp = {
                payload: codec.payloadType,
                config: ""
            };
            answerMediaObject.fmtp.push(fmtp);
        }
        const parameters = sdpTransform.parseParams(fmtp.config);
        switch(mimeType){
            case "audio/opus":
                {
                    const spropStereo = codec.parameters["sprop-stereo"];
                    if (spropStereo !== undefined) parameters.stereo = spropStereo ? 1 : 0;
                    break;
                }
        }
        // Write the codec fmtp.config back.
        fmtp.config = "";
        for (const key of Object.keys(parameters)){
            if (fmtp.config) fmtp.config += ";";
            fmtp.config += `${key}=${parameters[key]}`;
        }
    }
}
exports.applyCodecParameters = applyCodecParameters;

},{"a92b233ce8707f8":"8vPQN"}],"3n46G":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
function getRtpEncodings({ offerMediaObject  }) {
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs || []){
        const ssrc = line.id;
        ssrcs.add(ssrc);
    }
    if (ssrcs.size === 0) throw new Error("no a=ssrc lines found");
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups || []){
        if (line.semantics !== "FID") continue;
        let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
        ssrc = Number(ssrc);
        rtxSsrc = Number(rtxSsrc);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know
            // that they are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so
    // take media SSRCs from there.
    for (const ssrc of ssrcs)// Add to the map.
    ssrcToRtxSsrc.set(ssrc, null);
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc){
        const encoding = {
            ssrc
        };
        if (rtxSsrc) encoding.rtx = {
            ssrc: rtxSsrc
        };
        encodings.push(encoding);
    }
    return encodings;
}
exports.getRtpEncodings = getRtpEncodings;
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */ function addLegacySimulcast({ offerMediaObject , numStreams  }) {
    if (numStreams <= 1) throw new TypeError("numStreams must be greater than 1");
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line)=>line.attribute === "msid");
    if (!ssrcMsidLine) throw new Error("a=ssrc line with msid information not found");
    const [streamId, trackId] = ssrcMsidLine.value.split(" ");
    const firstSsrc = ssrcMsidLine.id;
    let firstRtxSsrc;
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups || []).some((line)=>{
        if (line.semantics !== "FID") return false;
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        } else return false;
    });
    const ssrcCnameLine = offerMediaObject.ssrcs.find((line)=>line.attribute === "cname");
    if (!ssrcCnameLine) throw new Error("a=ssrc line with cname information not found");
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for(let i = 0; i < numStreams; ++i){
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc) rtxSsrcs.push(firstRtxSsrc + i);
    }
    offerMediaObject.ssrcGroups = [];
    offerMediaObject.ssrcs = [];
    offerMediaObject.ssrcGroups.push({
        semantics: "SIM",
        ssrcs: ssrcs.join(" ")
    });
    for(let i = 0; i < ssrcs.length; ++i){
        const ssrc = ssrcs[i];
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: cname
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId} ${trackId}`
        });
    }
    for(let i = 0; i < rtxSsrcs.length; ++i){
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "cname",
            value: cname
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "msid",
            value: `${streamId} ${trackId}`
        });
        offerMediaObject.ssrcGroups.push({
            semantics: "FID",
            ssrcs: `${ssrc} ${rtxSsrc}`
        });
    }
}
exports.addLegacySimulcast = addLegacySimulcast;

},{}],"jQP2l":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addNackSuppportForOpus = void 0;
/**
 * This function adds RTCP NACK support for OPUS codec in given capabilities.
 */ function addNackSuppportForOpus(rtpCapabilities) {
    var _a;
    for (const codec of rtpCapabilities.codecs || [])if ((codec.mimeType.toLowerCase() === "audio/opus" || codec.mimeType.toLowerCase() === "audio/multiopus") && !((_a = codec.rtcpFeedback) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.type === "nack" && !fb.parameter))) {
        if (!codec.rtcpFeedback) codec.rtcpFeedback = [];
        codec.rtcpFeedback.push({
            type: "nack"
        });
    }
}
exports.addNackSuppportForOpus = addNackSuppportForOpus;

},{}],"50jj4":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HandlerInterface = void 0;
const EnhancedEventEmitter_1 = require("1de87aa4c98b74ff");
class HandlerInterface extends EnhancedEventEmitter_1.EnhancedEventEmitter {
    constructor(){
        super();
    }
}
exports.HandlerInterface = HandlerInterface;

},{"1de87aa4c98b74ff":"4Z8Ic"}],"fsxdK":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RemoteSdp = void 0;
const sdpTransform = __importStar(require("a2998991374042f0"));
const Logger_1 = require("b87974ee2835d072");
const MediaSection_1 = require("ceb6834c32de46a0");
const logger = new Logger_1.Logger("RemoteSdp");
class RemoteSdp {
    constructor({ iceParameters , iceCandidates , dtlsParameters , sctpParameters , plainRtpParameters , planB =false  }){
        // MediaSection instances with same order as in the SDP.
        this._mediaSections = [];
        // MediaSection indices indexed by MID.
        this._midToIndex = new Map();
        this._iceParameters = iceParameters;
        this._iceCandidates = iceCandidates;
        this._dtlsParameters = dtlsParameters;
        this._sctpParameters = sctpParameters;
        this._plainRtpParameters = plainRtpParameters;
        this._planB = planB;
        this._sdpObject = {
            version: 0,
            origin: {
                address: "0.0.0.0",
                ipVer: 4,
                netType: "IN",
                sessionId: 10000,
                sessionVersion: 0,
                username: "mediasoup-client"
            },
            name: "-",
            timing: {
                start: 0,
                stop: 0
            },
            media: []
        };
        // If ICE parameters are given, add ICE-Lite indicator.
        if (iceParameters && iceParameters.iceLite) this._sdpObject.icelite = "ice-lite";
        // If DTLS parameters are given, assume WebRTC and BUNDLE.
        if (dtlsParameters) {
            this._sdpObject.msidSemantic = {
                semantic: "WMS",
                token: "*"
            };
            // NOTE: We take the latest fingerprint.
            const numFingerprints = this._dtlsParameters.fingerprints.length;
            this._sdpObject.fingerprint = {
                type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
                hash: dtlsParameters.fingerprints[numFingerprints - 1].value
            };
            this._sdpObject.groups = [
                {
                    type: "BUNDLE",
                    mids: ""
                }
            ];
        }
        // If there are plain RPT parameters, override SDP origin.
        if (plainRtpParameters) {
            this._sdpObject.origin.address = plainRtpParameters.ip;
            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
        }
    }
    updateIceParameters(iceParameters) {
        logger.debug("updateIceParameters() [iceParameters:%o]", iceParameters);
        this._iceParameters = iceParameters;
        this._sdpObject.icelite = iceParameters.iceLite ? "ice-lite" : undefined;
        for (const mediaSection of this._mediaSections)mediaSection.setIceParameters(iceParameters);
    }
    updateDtlsRole(role) {
        logger.debug("updateDtlsRole() [role:%s]", role);
        this._dtlsParameters.role = role;
        for (const mediaSection of this._mediaSections)mediaSection.setDtlsRole(role);
    }
    getNextMediaSectionIdx() {
        // If a closed media section is found, return its index.
        for(let idx = 0; idx < this._mediaSections.length; ++idx){
            const mediaSection = this._mediaSections[idx];
            if (mediaSection.closed) return {
                idx,
                reuseMid: mediaSection.mid
            };
        }
        // If no closed media section is found, return next one.
        return {
            idx: this._mediaSections.length
        };
    }
    send({ offerMediaObject , reuseMid , offerRtpParameters , answerRtpParameters , codecOptions , extmapAllowMixed =false  }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            planB: this._planB,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed
        });
        // Unified-Plan with closed media section replacement.
        if (reuseMid) this._replaceMediaSection(mediaSection, reuseMid);
        else if (!this._midToIndex.has(mediaSection.mid)) this._addMediaSection(mediaSection);
        else this._replaceMediaSection(mediaSection);
    }
    receive({ mid , kind , offerRtpParameters , streamId , trackId  }) {
        const idx = this._midToIndex.get(mid);
        let mediaSection;
        if (idx !== undefined) mediaSection = this._mediaSections[idx];
        // Unified-Plan or different media kind.
        if (!mediaSection) {
            mediaSection = new MediaSection_1.OfferMediaSection({
                iceParameters: this._iceParameters,
                iceCandidates: this._iceCandidates,
                dtlsParameters: this._dtlsParameters,
                plainRtpParameters: this._plainRtpParameters,
                planB: this._planB,
                mid,
                kind,
                offerRtpParameters,
                streamId,
                trackId
            });
            // Let's try to recycle a closed media section (if any).
            // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
            const oldMediaSection = this._mediaSections.find((m)=>m.closed);
            if (oldMediaSection) this._replaceMediaSection(mediaSection, oldMediaSection.mid);
            else this._addMediaSection(mediaSection);
        } else {
            mediaSection.planBReceive({
                offerRtpParameters,
                streamId,
                trackId
            });
            this._replaceMediaSection(mediaSection);
        }
    }
    pauseMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.pause();
    }
    resumeSendingMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.resume();
    }
    resumeReceivingMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.resume();
    }
    disableMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.disable();
    }
    /**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */ closeMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        // NOTE: Closing the first m section is a pain since it invalidates the
        // bundled transport, so let's avoid it.
        if (mid === this._firstMid) {
            logger.debug("closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]", mid);
            this.disableMediaSection(mid);
            return false;
        }
        mediaSection.close();
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
        return true;
    }
    muxMediaSectionSimulcast(mid, encodings) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.muxSimulcastStreams(encodings);
        this._replaceMediaSection(mediaSection);
    }
    planBStopReceiving({ mid , offerRtpParameters  }) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.planBStopReceiving({
            offerRtpParameters
        });
        this._replaceMediaSection(mediaSection);
    }
    sendSctpAssociation({ offerMediaObject  }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject
        });
        this._addMediaSection(mediaSection);
    }
    receiveSctpAssociation({ oldDataChannelSpec =false  } = {}) {
        const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid: "datachannel",
            kind: "application",
            oldDataChannelSpec
        });
        this._addMediaSection(mediaSection);
    }
    getSdp() {
        // Increase SDP version.
        this._sdpObject.origin.sessionVersion++;
        return sdpTransform.write(this._sdpObject);
    }
    _addMediaSection(newMediaSection) {
        if (!this._firstMid) this._firstMid = newMediaSection.mid;
        // Add to the vector.
        this._mediaSections.push(newMediaSection);
        // Add to the map.
        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
        // Add to the SDP object.
        this._sdpObject.media.push(newMediaSection.getObject());
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
    }
    _replaceMediaSection(newMediaSection, reuseMid) {
        // Store it in the map.
        if (typeof reuseMid === "string") {
            const idx = this._midToIndex.get(reuseMid);
            if (idx === undefined) throw new Error(`no media section found for reuseMid '${reuseMid}'`);
            const oldMediaSection = this._mediaSections[idx];
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the map.
            this._midToIndex.delete(oldMediaSection.mid);
            this._midToIndex.set(newMediaSection.mid, idx);
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
            // Regenerate BUNDLE mids.
            this._regenerateBundleMids();
        } else {
            const idx = this._midToIndex.get(newMediaSection.mid);
            if (idx === undefined) throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
        }
    }
    _findMediaSection(mid) {
        const idx = this._midToIndex.get(mid);
        if (idx === undefined) throw new Error(`no media section found with mid '${mid}'`);
        return this._mediaSections[idx];
    }
    _regenerateBundleMids() {
        if (!this._dtlsParameters) return;
        this._sdpObject.groups[0].mids = this._mediaSections.filter((mediaSection)=>!mediaSection.closed).map((mediaSection)=>mediaSection.mid).join(" ");
    }
}
exports.RemoteSdp = RemoteSdp;

},{"a2998991374042f0":"8vPQN","b87974ee2835d072":"co3ME","ceb6834c32de46a0":"fDLc0"}],"fDLc0":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
const sdpTransform = __importStar(require("6bde0efc360abd1f"));
const utils = __importStar(require("b77a70503e3a1506"));
class MediaSection {
    constructor({ iceParameters , iceCandidates , dtlsParameters , planB =false  }){
        this._mediaObject = {};
        this._planB = planB;
        if (iceParameters) this.setIceParameters(iceParameters);
        if (iceCandidates) {
            this._mediaObject.candidates = [];
            for (const candidate of iceCandidates){
                const candidateObject = {};
                // mediasoup does mandates rtcp-mux so candidates component is always
                // RTP (1).
                candidateObject.component = 1;
                candidateObject.foundation = candidate.foundation;
                candidateObject.ip = candidate.ip;
                candidateObject.port = candidate.port;
                candidateObject.priority = candidate.priority;
                candidateObject.transport = candidate.protocol;
                candidateObject.type = candidate.type;
                if (candidate.tcpType) candidateObject.tcptype = candidate.tcpType;
                this._mediaObject.candidates.push(candidateObject);
            }
            this._mediaObject.endOfCandidates = "end-of-candidates";
            this._mediaObject.iceOptions = "renomination";
        }
        if (dtlsParameters) this.setDtlsRole(dtlsParameters.role);
    }
    get mid() {
        return String(this._mediaObject.mid);
    }
    get closed() {
        return this._mediaObject.port === 0;
    }
    getObject() {
        return this._mediaObject;
    }
    setIceParameters(iceParameters) {
        this._mediaObject.iceUfrag = iceParameters.usernameFragment;
        this._mediaObject.icePwd = iceParameters.password;
    }
    pause() {
        this._mediaObject.direction = "inactive";
    }
    disable() {
        this.pause();
        delete this._mediaObject.ext;
        delete this._mediaObject.ssrcs;
        delete this._mediaObject.ssrcGroups;
        delete this._mediaObject.simulcast;
        delete this._mediaObject.simulcast_03;
        delete this._mediaObject.rids;
        delete this._mediaObject.extmapAllowMixed;
    }
    close() {
        this.disable();
        this._mediaObject.port = 0;
    }
}
exports.MediaSection = MediaSection;
class AnswerMediaSection extends MediaSection {
    constructor({ iceParameters , iceCandidates , dtlsParameters , sctpParameters , plainRtpParameters , planB =false , offerMediaObject , offerRtpParameters , answerRtpParameters , codecOptions , extmapAllowMixed =false  }){
        super({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            planB
        });
        this._mediaObject.mid = String(offerMediaObject.mid);
        this._mediaObject.type = offerMediaObject.type;
        this._mediaObject.protocol = offerMediaObject.protocol;
        if (!plainRtpParameters) {
            this._mediaObject.connection = {
                ip: "127.0.0.1",
                version: 4
            };
            this._mediaObject.port = 7;
        } else {
            this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion
            };
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch(offerMediaObject.type){
            case "audio":
            case "video":
                this._mediaObject.direction = "recvonly";
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                for (const codec of answerRtpParameters.codecs){
                    const rtp = {
                        payload: codec.payloadType,
                        codec: getCodecName(codec),
                        rate: codec.clockRate
                    };
                    if (codec.channels > 1) rtp.encoding = codec.channels;
                    this._mediaObject.rtp.push(rtp);
                    const codecParameters = utils.clone(codec.parameters, {});
                    let codecRtcpFeedback = utils.clone(codec.rtcpFeedback, []);
                    if (codecOptions) {
                        const { opusStereo , opusFec , opusDtx , opusMaxPlaybackRate , opusMaxAverageBitrate , opusPtime , opusNack , videoGoogleStartBitrate , videoGoogleMaxBitrate , videoGoogleMinBitrate  } = codecOptions;
                        const offerCodec = offerRtpParameters.codecs.find((c)=>c.payloadType === codec.payloadType);
                        switch(codec.mimeType.toLowerCase()){
                            case "audio/opus":
                            case "audio/multiopus":
                                if (opusStereo !== undefined) {
                                    offerCodec.parameters["sprop-stereo"] = opusStereo ? 1 : 0;
                                    codecParameters.stereo = opusStereo ? 1 : 0;
                                }
                                if (opusFec !== undefined) {
                                    offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                                    codecParameters.useinbandfec = opusFec ? 1 : 0;
                                }
                                if (opusDtx !== undefined) {
                                    offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                                    codecParameters.usedtx = opusDtx ? 1 : 0;
                                }
                                if (opusMaxPlaybackRate !== undefined) codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                                if (opusMaxAverageBitrate !== undefined) codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                                if (opusPtime !== undefined) {
                                    offerCodec.parameters.ptime = opusPtime;
                                    codecParameters.ptime = opusPtime;
                                }
                                // If opusNack is not set, we must remove NACK support for OPUS.
                                // Otherwise it would be enabled for those handlers that artificially
                                // announce it in their RTP capabilities.
                                if (!opusNack) {
                                    offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter((fb)=>fb.type !== "nack" || fb.parameter);
                                    codecRtcpFeedback = codecRtcpFeedback.filter((fb)=>fb.type !== "nack" || fb.parameter);
                                }
                                break;
                            case "video/vp8":
                            case "video/vp9":
                            case "video/h264":
                            case "video/h265":
                                if (videoGoogleStartBitrate !== undefined) codecParameters["x-google-start-bitrate"] = videoGoogleStartBitrate;
                                if (videoGoogleMaxBitrate !== undefined) codecParameters["x-google-max-bitrate"] = videoGoogleMaxBitrate;
                                if (videoGoogleMinBitrate !== undefined) codecParameters["x-google-min-bitrate"] = videoGoogleMinBitrate;
                                break;
                        }
                    }
                    const fmtp = {
                        payload: codec.payloadType,
                        config: ""
                    };
                    for (const key of Object.keys(codecParameters)){
                        if (fmtp.config) fmtp.config += ";";
                        fmtp.config += `${key}=${codecParameters[key]}`;
                    }
                    if (fmtp.config) this._mediaObject.fmtp.push(fmtp);
                    for (const fb of codecRtcpFeedback)this._mediaObject.rtcpFb.push({
                        payload: codec.payloadType,
                        type: fb.type,
                        subtype: fb.parameter
                    });
                }
                this._mediaObject.payloads = answerRtpParameters.codecs.map((codec)=>codec.payloadType).join(" ");
                this._mediaObject.ext = [];
                for (const ext of answerRtpParameters.headerExtensions){
                    // Don't add a header extension if not present in the offer.
                    const found = (offerMediaObject.ext || []).some((localExt)=>localExt.uri === ext.uri);
                    if (!found) continue;
                    this._mediaObject.ext.push({
                        uri: ext.uri,
                        value: ext.id
                    });
                }
                // Allow both 1 byte and 2 bytes length header extensions.
                if (extmapAllowMixed && offerMediaObject.extmapAllowMixed === "extmap-allow-mixed") this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
                // Simulcast.
                if (offerMediaObject.simulcast) {
                    this._mediaObject.simulcast = {
                        dir1: "recv",
                        list1: offerMediaObject.simulcast.list1
                    };
                    this._mediaObject.rids = [];
                    for (const rid of offerMediaObject.rids || []){
                        if (rid.direction !== "send") continue;
                        this._mediaObject.rids.push({
                            id: rid.id,
                            direction: "recv"
                        });
                    }
                } else if (offerMediaObject.simulcast_03) {
                    // eslint-disable-next-line camelcase
                    this._mediaObject.simulcast_03 = {
                        value: offerMediaObject.simulcast_03.value.replace(/send/g, "recv")
                    };
                    this._mediaObject.rids = [];
                    for (const rid of offerMediaObject.rids || []){
                        if (rid.direction !== "send") continue;
                        this._mediaObject.rids.push({
                            id: rid.id,
                            direction: "recv"
                        });
                    }
                }
                this._mediaObject.rtcpMux = "rtcp-mux";
                this._mediaObject.rtcpRsize = "rtcp-rsize";
                if (this._planB && this._mediaObject.type === "video") this._mediaObject.xGoogleFlag = "conference";
                break;
            case "application":
                // New spec.
                if (typeof offerMediaObject.sctpPort === "number") {
                    this._mediaObject.payloads = "webrtc-datachannel";
                    this._mediaObject.sctpPort = sctpParameters.port;
                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                } else if (offerMediaObject.sctpmap) {
                    this._mediaObject.payloads = sctpParameters.port;
                    this._mediaObject.sctpmap = {
                        app: "webrtc-datachannel",
                        sctpmapNumber: sctpParameters.port,
                        maxMessageSize: sctpParameters.maxMessageSize
                    };
                }
                break;
        }
    }
    setDtlsRole(role) {
        switch(role){
            case "client":
                this._mediaObject.setup = "active";
                break;
            case "server":
                this._mediaObject.setup = "passive";
                break;
            case "auto":
                this._mediaObject.setup = "actpass";
                break;
        }
    }
    resume() {
        this._mediaObject.direction = "recvonly";
    }
    muxSimulcastStreams(encodings) {
        var _a;
        if (!this._mediaObject.simulcast || !this._mediaObject.simulcast.list1) return;
        const layers = {};
        for (const encoding of encodings)if (encoding.rid) layers[encoding.rid] = encoding;
        const raw = this._mediaObject.simulcast.list1;
        // NOTE: Ignore bug in @types/sdp-transform.
        // Ongoing PR: https://github.com/DefinitelyTyped/DefinitelyTyped/pull/64119
        // @ts-ignore
        const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
        for (const simulcastStream of simulcastStreams)for (const simulcastFormat of simulcastStream)simulcastFormat.paused = !((_a = layers[simulcastFormat.scid]) === null || _a === void 0 ? void 0 : _a.active);
        this._mediaObject.simulcast.list1 = simulcastStreams.map((simulcastFormats)=>simulcastFormats.map((f)=>`${f.paused ? "~" : ""}${f.scid}`).join(",")).join(";");
    }
}
exports.AnswerMediaSection = AnswerMediaSection;
class OfferMediaSection extends MediaSection {
    constructor({ iceParameters , iceCandidates , dtlsParameters , sctpParameters , plainRtpParameters , planB =false , mid , kind , offerRtpParameters , streamId , trackId , oldDataChannelSpec =false  }){
        super({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            planB
        });
        this._mediaObject.mid = String(mid);
        this._mediaObject.type = kind;
        if (!plainRtpParameters) {
            this._mediaObject.connection = {
                ip: "127.0.0.1",
                version: 4
            };
            if (!sctpParameters) this._mediaObject.protocol = "UDP/TLS/RTP/SAVPF";
            else this._mediaObject.protocol = "UDP/DTLS/SCTP";
            this._mediaObject.port = 7;
        } else {
            this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion
            };
            this._mediaObject.protocol = "RTP/AVP";
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch(kind){
            case "audio":
            case "video":
                {
                    this._mediaObject.direction = "sendonly";
                    this._mediaObject.rtp = [];
                    this._mediaObject.rtcpFb = [];
                    this._mediaObject.fmtp = [];
                    if (!this._planB) this._mediaObject.msid = `${streamId || "-"} ${trackId}`;
                    for (const codec of offerRtpParameters.codecs){
                        const rtp = {
                            payload: codec.payloadType,
                            codec: getCodecName(codec),
                            rate: codec.clockRate
                        };
                        if (codec.channels > 1) rtp.encoding = codec.channels;
                        this._mediaObject.rtp.push(rtp);
                        const fmtp = {
                            payload: codec.payloadType,
                            config: ""
                        };
                        for (const key of Object.keys(codec.parameters)){
                            if (fmtp.config) fmtp.config += ";";
                            fmtp.config += `${key}=${codec.parameters[key]}`;
                        }
                        if (fmtp.config) this._mediaObject.fmtp.push(fmtp);
                        for (const fb of codec.rtcpFeedback)this._mediaObject.rtcpFb.push({
                            payload: codec.payloadType,
                            type: fb.type,
                            subtype: fb.parameter
                        });
                    }
                    this._mediaObject.payloads = offerRtpParameters.codecs.map((codec)=>codec.payloadType).join(" ");
                    this._mediaObject.ext = [];
                    for (const ext of offerRtpParameters.headerExtensions)this._mediaObject.ext.push({
                        uri: ext.uri,
                        value: ext.id
                    });
                    this._mediaObject.rtcpMux = "rtcp-mux";
                    this._mediaObject.rtcpRsize = "rtcp-rsize";
                    const encoding = offerRtpParameters.encodings[0];
                    const ssrc = encoding.ssrc;
                    const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;
                    this._mediaObject.ssrcs = [];
                    this._mediaObject.ssrcGroups = [];
                    if (offerRtpParameters.rtcp.cname) this._mediaObject.ssrcs.push({
                        id: ssrc,
                        attribute: "cname",
                        value: offerRtpParameters.rtcp.cname
                    });
                    if (this._planB) this._mediaObject.ssrcs.push({
                        id: ssrc,
                        attribute: "msid",
                        value: `${streamId || "-"} ${trackId}`
                    });
                    if (rtxSsrc) {
                        if (offerRtpParameters.rtcp.cname) this._mediaObject.ssrcs.push({
                            id: rtxSsrc,
                            attribute: "cname",
                            value: offerRtpParameters.rtcp.cname
                        });
                        if (this._planB) this._mediaObject.ssrcs.push({
                            id: rtxSsrc,
                            attribute: "msid",
                            value: `${streamId || "-"} ${trackId}`
                        });
                        // Associate original and retransmission SSRCs.
                        this._mediaObject.ssrcGroups.push({
                            semantics: "FID",
                            ssrcs: `${ssrc} ${rtxSsrc}`
                        });
                    }
                    break;
                }
            case "application":
                // New spec.
                if (!oldDataChannelSpec) {
                    this._mediaObject.payloads = "webrtc-datachannel";
                    this._mediaObject.sctpPort = sctpParameters.port;
                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                } else {
                    this._mediaObject.payloads = sctpParameters.port;
                    this._mediaObject.sctpmap = {
                        app: "webrtc-datachannel",
                        sctpmapNumber: sctpParameters.port,
                        maxMessageSize: sctpParameters.maxMessageSize
                    };
                }
                break;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setDtlsRole(role) {
        // Always 'actpass'.
        this._mediaObject.setup = "actpass";
    }
    resume() {
        this._mediaObject.direction = "sendonly";
    }
    planBReceive({ offerRtpParameters , streamId , trackId  }) {
        const encoding = offerRtpParameters.encodings[0];
        const ssrc = encoding.ssrc;
        const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;
        const payloads = this._mediaObject.payloads.split(" ");
        for (const codec of offerRtpParameters.codecs){
            if (payloads.includes(String(codec.payloadType))) continue;
            const rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
            };
            if (codec.channels > 1) rtp.encoding = codec.channels;
            this._mediaObject.rtp.push(rtp);
            const fmtp = {
                payload: codec.payloadType,
                config: ""
            };
            for (const key of Object.keys(codec.parameters)){
                if (fmtp.config) fmtp.config += ";";
                fmtp.config += `${key}=${codec.parameters[key]}`;
            }
            if (fmtp.config) this._mediaObject.fmtp.push(fmtp);
            for (const fb of codec.rtcpFeedback)this._mediaObject.rtcpFb.push({
                payload: codec.payloadType,
                type: fb.type,
                subtype: fb.parameter
            });
        }
        this._mediaObject.payloads += ` ${offerRtpParameters.codecs.filter((codec)=>!this._mediaObject.payloads.includes(codec.payloadType)).map((codec)=>codec.payloadType).join(" ")}`;
        this._mediaObject.payloads = this._mediaObject.payloads.trim();
        if (offerRtpParameters.rtcp.cname) this._mediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: offerRtpParameters.rtcp.cname
        });
        this._mediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId || "-"} ${trackId}`
        });
        if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: "cname",
                value: offerRtpParameters.rtcp.cname
            });
            this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: "msid",
                value: `${streamId || "-"} ${trackId}`
            });
            // Associate original and retransmission SSRCs.
            this._mediaObject.ssrcGroups.push({
                semantics: "FID",
                ssrcs: `${ssrc} ${rtxSsrc}`
            });
        }
    }
    planBStopReceiving({ offerRtpParameters  }) {
        const encoding = offerRtpParameters.encodings[0];
        const ssrc = encoding.ssrc;
        const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;
        this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter((s)=>s.id !== ssrc && s.id !== rtxSsrc);
        if (rtxSsrc) this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter((group)=>group.ssrcs !== `${ssrc} ${rtxSsrc}`);
    }
}
exports.OfferMediaSection = OfferMediaSection;
function getCodecName(codec) {
    const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) throw new TypeError("invalid codec.mimeType");
    return mimeTypeMatch[2];
}

},{"6bde0efc360abd1f":"8vPQN","b77a70503e3a1506":"6bv4j"}],"hE1NO":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parse = void 0;
const ScalabilityModeRegex = new RegExp("^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})");
function parse(scalabilityMode) {
    const match = ScalabilityModeRegex.exec(scalabilityMode || "");
    if (match) return {
        spatialLayers: Number(match[1]),
        temporalLayers: Number(match[2])
    };
    else return {
        spatialLayers: 1,
        temporalLayers: 1
    };
}
exports.parse = parse;

},{}],"6XG5D":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chrome74 = void 0;
const sdpTransform = __importStar(require("4cf9ff8ad652f4e1"));
const Logger_1 = require("5869130664541ffb");
const utils = __importStar(require("10df7f8daaf12d23"));
const ortc = __importStar(require("f0844f655ae7c3"));
const sdpCommonUtils = __importStar(require("f5581b1dbe6e3a1e"));
const sdpUnifiedPlanUtils = __importStar(require("47147a07f0d47cb8"));
const ortcUtils = __importStar(require("241ab08fb3d1af67"));
const HandlerInterface_1 = require("39d462112cd8a36b");
const RemoteSdp_1 = require("d654a1bf21b8627b");
const scalabilityModes_1 = require("50fa0ee14f23b55");
const logger = new Logger_1.Logger("Chrome74");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class Chrome74 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Chrome74();
    }
    constructor(){
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Chrome74";
    }
    close() {
        logger.debug("close()");
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
        });
        try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else {
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            this._pc.addEventListener("iceconnectionstatechange", ()=>{
                switch(this._pc.iceConnectionState){
                    case "checking":
                        this.emit("@connectionstatechange", "connecting");
                        break;
                    case "connected":
                    case "completed":
                        this.emit("@connectionstatechange", "connected");
                        break;
                    case "failed":
                        this.emit("@connectionstatechange", "failed");
                        break;
                    case "disconnected":
                        this.emit("@connectionstatechange", "disconnected");
                        break;
                    case "closed":
                        this.emit("@connectionstatechange", "closed");
                        break;
                }
            });
        }
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (encodings && encodings.length > 1) encodings.forEach((encoding, idx)=>{
            encoding.rid = `r${idx}`;
        });
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [
                this._sendStream
            ],
            sendEncodings: encodings
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings || [
            {}
        ])[0].scalabilityMode);
        if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
        });
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc) newEncodings = [
                newEncodings[0]
            ];
            sendingRtpParameters.encodings = newEncodings;
        } else sendingRtpParameters.encodings = encodings;
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings)if (encoding.scalabilityMode) encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
            else encoding.scalabilityMode = "L1T3";
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) try {
            transceiver.stop();
        } catch (error) {}
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "sendonly";
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx <= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { trackId , rtpParameters  } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { trackId  } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t)=>t.mid === localId);
            if (!transceiver) throw new Error("new RTCRtpTransceiver not found");
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds)this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.Chrome74 = Chrome74;

},{"4cf9ff8ad652f4e1":"8vPQN","5869130664541ffb":"co3ME","10df7f8daaf12d23":"6bv4j","f0844f655ae7c3":"jtITX","f5581b1dbe6e3a1e":"f6oEu","47147a07f0d47cb8":"3n46G","241ab08fb3d1af67":"jQP2l","39d462112cd8a36b":"50jj4","d654a1bf21b8627b":"fsxdK","50fa0ee14f23b55":"hE1NO"}],"h1bb1":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chrome70 = void 0;
const sdpTransform = __importStar(require("ef3e618696ab9624"));
const Logger_1 = require("bb9c083b1ade1d94");
const utils = __importStar(require("f354416ca84145b2"));
const ortc = __importStar(require("586f788a15ce2593"));
const sdpCommonUtils = __importStar(require("b2dd4cca156fe24d"));
const sdpUnifiedPlanUtils = __importStar(require("b49714d8de4e4d34"));
const HandlerInterface_1 = require("e9d25d08eb699eca");
const RemoteSdp_1 = require("e5edf481d3e7d70e");
const scalabilityModes_1 = require("fcd4cdf09978827a");
const logger = new Logger_1.Logger("Chrome70");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class Chrome70 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Chrome70();
    }
    constructor(){
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Chrome70";
    }
    close() {
        logger.debug("close()");
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
        });
        try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else this._pc.addEventListener("iceconnectionstatechange", ()=>{
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            switch(this._pc.iceConnectionState){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [
                this._sendStream
            ]
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        if (encodings && encodings.length > 1) {
            logger.debug("send() | enabling legacy simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings || [
            {}
        ])[0].scalabilityMode);
        if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        // If encodings are given, apply them now.
        if (encodings) {
            logger.debug("send() | applying given encodings");
            const parameters = transceiver.sender.getParameters();
            for(let idx = 0; idx < (parameters.encodings || []).length; ++idx){
                const encoding = parameters.encodings[idx];
                const desiredEncoding = encodings[idx];
                // Should not happen but just in case.
                if (!desiredEncoding) break;
                parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
            }
            await transceiver.sender.setParameters(parameters);
        }
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
        });
        // Complete encodings with given values.
        if (encodings) {
            for(let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx)if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
        }
        // Hack for VP9 SVC.
        if (hackVp9Svc) sendingRtpParameters.encodings = [
            sendingRtpParameters.encodings[0]
        ];
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) for (const encoding of sendingRtpParameters.encodings)encoding.scalabilityMode = "L1T3";
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) try {
            transceiver.stop();
        } catch (error) {}
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
    // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
    // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx <= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { trackId , rtpParameters  } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { trackId  } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t)=>t.mid === localId);
            if (!transceiver) throw new Error("new RTCRtpTransceiver not found");
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds)this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async resumeReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.Chrome70 = Chrome70;

},{"ef3e618696ab9624":"8vPQN","bb9c083b1ade1d94":"co3ME","f354416ca84145b2":"6bv4j","586f788a15ce2593":"jtITX","b2dd4cca156fe24d":"f6oEu","b49714d8de4e4d34":"3n46G","e9d25d08eb699eca":"50jj4","e5edf481d3e7d70e":"fsxdK","fcd4cdf09978827a":"hE1NO"}],"leQQE":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chrome67 = void 0;
const sdpTransform = __importStar(require("ba63c4a0eea74b19"));
const Logger_1 = require("aba0393c75f8343c");
const utils = __importStar(require("965173bc486b45cf"));
const ortc = __importStar(require("60cd52d9c45a1564"));
const sdpCommonUtils = __importStar(require("4d2c37120f3d35ae"));
const sdpPlanBUtils = __importStar(require("61ae9f0a42694cdf"));
const HandlerInterface_1 = require("bb879af0f49892b1");
const RemoteSdp_1 = require("6d23582b26f1743e");
const logger = new Logger_1.Logger("Chrome67");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class Chrome67 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Chrome67();
    }
    constructor(){
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of RTCRtpSender indexed by localId.
        this._mapSendLocalIdRtpSender = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Chrome67";
    }
    close() {
        logger.debug("close()");
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else this._pc.addEventListener("iceconnectionstatechange", ()=>{
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            switch(this._pc.iceConnectionState){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (codec) logger.warn("send() | codec selection is not available in %s handler", this.name);
        this._sendStream.addTrack(track);
        this._pc.addTrack(track, this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        if (track.kind === "video" && encodings && encodings.length > 1) {
            logger.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m)=>m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m)=>m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
        });
        // Complete encodings with given values.
        if (encodings) {
            for(let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx)if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") for (const encoding of sendingRtpParameters.encodings)encoding.scalabilityMode = "L1T3";
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        const rtpSender = this._pc.getSenders().find((s)=>s.track === track);
        // Insert into the map.
        this._mapSendLocalIdRtpSender.set(localId, rtpSender);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        this._pc.removeTrack(rtpSender);
        if (rtpSender.track) this._sendStream.removeTrack(rtpSender.track);
        this._mapSendLocalIdRtpSender.delete(localId);
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        try {
            await this._pc.setLocalDescription(offer);
        } catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === "stable") return;
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
    // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
    // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        const oldTrack = rtpSender.track;
        await rtpSender.replaceTrack(track);
        // Remove the old track from the local stream.
        if (oldTrack) this._sendStream.removeTrack(oldTrack);
        // Add the new track to the local stream.
        if (track) this._sendStream.addTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx <= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        return rtpSender.getStats();
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { kind , rtpParameters  } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { kind , trackId , rtpParameters  } = options;
            const localId = trackId;
            const mid = kind;
            const rtpReceiver = this._pc.getReceivers().find((r)=>r.track && r.track.id === localId);
            if (!rtpReceiver) throw new Error("new RTCRtpReceiver not");
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters,
                rtpReceiver
            });
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const { mid , rtpParameters  } = this._mapRecvLocalIdInfo.get(localId) || {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async resumeReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const { rtpReceiver  } = this._mapRecvLocalIdInfo.get(localId) || {};
        if (!rtpReceiver) throw new Error("associated RTCRtpReceiver not found");
        return rtpReceiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
            });
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.Chrome67 = Chrome67;

},{"ba63c4a0eea74b19":"8vPQN","aba0393c75f8343c":"co3ME","965173bc486b45cf":"6bv4j","60cd52d9c45a1564":"jtITX","4d2c37120f3d35ae":"f6oEu","61ae9f0a42694cdf":"dHdjJ","bb879af0f49892b1":"50jj4","6d23582b26f1743e":"fsxdK"}],"dHdjJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
function getRtpEncodings({ offerMediaObject , track  }) {
    // First media SSRC (or the only one).
    let firstSsrc;
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs || []){
        if (line.attribute !== "msid") continue;
        const trackId = line.value.split(" ")[1];
        if (trackId === track.id) {
            const ssrc = line.id;
            ssrcs.add(ssrc);
            if (!firstSsrc) firstSsrc = ssrc;
        }
    }
    if (ssrcs.size === 0) throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups || []){
        if (line.semantics !== "FID") continue;
        let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
        ssrc = Number(ssrc);
        rtxSsrc = Number(rtxSsrc);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know that they
            // are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so take
    // media SSRCs from there.
    for (const ssrc of ssrcs)// Add to the map.
    ssrcToRtxSsrc.set(ssrc, null);
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc){
        const encoding = {
            ssrc
        };
        if (rtxSsrc) encoding.rtx = {
            ssrc: rtxSsrc
        };
        encodings.push(encoding);
    }
    return encodings;
}
exports.getRtpEncodings = getRtpEncodings;
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */ function addLegacySimulcast({ offerMediaObject , track , numStreams  }) {
    if (numStreams <= 1) throw new TypeError("numStreams must be greater than 1");
    let firstSsrc;
    let firstRtxSsrc;
    let streamId;
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line)=>{
        if (line.attribute !== "msid") return false;
        const trackId = line.value.split(" ")[1];
        if (trackId === track.id) {
            firstSsrc = line.id;
            streamId = line.value.split(" ")[0];
            return true;
        } else return false;
    });
    if (!ssrcMsidLine) throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups || []).some((line)=>{
        if (line.semantics !== "FID") return false;
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        } else return false;
    });
    const ssrcCnameLine = offerMediaObject.ssrcs.find((line)=>line.attribute === "cname" && line.id === firstSsrc);
    if (!ssrcCnameLine) throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for(let i = 0; i < numStreams; ++i){
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc) rtxSsrcs.push(firstRtxSsrc + i);
    }
    offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
    offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
    offerMediaObject.ssrcGroups.push({
        semantics: "SIM",
        ssrcs: ssrcs.join(" ")
    });
    for(let i = 0; i < ssrcs.length; ++i){
        const ssrc = ssrcs[i];
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: cname
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId} ${track.id}`
        });
    }
    for(let i = 0; i < rtxSsrcs.length; ++i){
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "cname",
            value: cname
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "msid",
            value: `${streamId} ${track.id}`
        });
        offerMediaObject.ssrcGroups.push({
            semantics: "FID",
            ssrcs: `${ssrc} ${rtxSsrc}`
        });
    }
}
exports.addLegacySimulcast = addLegacySimulcast;

},{}],"a0ORI":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chrome55 = void 0;
const sdpTransform = __importStar(require("db24dfd1886ce0dc"));
const Logger_1 = require("4a66dc2833503817");
const errors_1 = require("98473d81617953ec");
const utils = __importStar(require("1e37b3b2f08cbd13"));
const ortc = __importStar(require("e8085698a28f2185"));
const sdpCommonUtils = __importStar(require("c35aaa0d13c6f675"));
const sdpPlanBUtils = __importStar(require("83b16fbc3e3ada0c"));
const HandlerInterface_1 = require("300293b627da85e9");
const RemoteSdp_1 = require("797c36b4d9f2ff24");
const logger = new Logger_1.Logger("Chrome55");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class Chrome55 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Chrome55();
    }
    constructor(){
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of sending MediaStreamTracks indexed by localId.
        this._mapSendLocalIdTrack = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Chrome55";
    }
    close() {
        logger.debug("close()");
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else this._pc.addEventListener("iceconnectionstatechange", ()=>{
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            switch(this._pc.iceConnectionState){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (codec) logger.warn("send() | codec selection is not available in %s handler", this.name);
        this._sendStream.addTrack(track);
        this._pc.addStream(this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        if (track.kind === "video" && encodings && encodings.length > 1) {
            logger.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m)=>m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m)=>m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
        });
        // Complete encodings with given values.
        if (encodings) {
            for(let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx)if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") for (const encoding of sendingRtpParameters.encodings)encoding.scalabilityMode = "L1T3";
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Insert into the map.
        this._mapSendLocalIdTrack.set(localId, track);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        const track = this._mapSendLocalIdTrack.get(localId);
        if (!track) throw new Error("track not found");
        this._mapSendLocalIdTrack.delete(localId);
        this._sendStream.removeTrack(track);
        this._pc.addStream(this._sendStream);
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        try {
            await this._pc.setLocalDescription(offer);
        } catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === "stable") return;
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
    // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
    // Unimplemented.
    }
    async replaceTrack(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, track) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setMaxSpatialLayer(localId, spatialLayer) {
        throw new errors_1.UnsupportedError(" not implemented");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setRtpEncodingParameters(localId, params) {
        throw new errors_1.UnsupportedError("not supported");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { kind , rtpParameters  } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { kind , trackId , rtpParameters  } = options;
            const mid = kind;
            const localId = trackId;
            const streamId = options.streamId || rtpParameters.rtcp.cname;
            const stream = this._pc.getRemoteStreams().find((s)=>s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) throw new Error("remote track not found");
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters
            });
            results.push({
                localId,
                track
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const { mid , rtpParameters  } = this._mapRecvLocalIdInfo.get(localId) || {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async resumeReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
            });
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.Chrome55 = Chrome55;

},{"db24dfd1886ce0dc":"8vPQN","4a66dc2833503817":"co3ME","98473d81617953ec":"Xq57d","1e37b3b2f08cbd13":"6bv4j","e8085698a28f2185":"jtITX","c35aaa0d13c6f675":"f6oEu","83b16fbc3e3ada0c":"dHdjJ","300293b627da85e9":"50jj4","797c36b4d9f2ff24":"fsxdK"}],"1E5rC":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Firefox60 = void 0;
const sdpTransform = __importStar(require("10bc1f8110fb752e"));
const Logger_1 = require("fda3f8391318b35");
const errors_1 = require("af186b9fc6fd9976");
const utils = __importStar(require("238548c87cf347f7"));
const ortc = __importStar(require("1fcd847a0b56bce7"));
const sdpCommonUtils = __importStar(require("ca3cbe52bc73a9f"));
const sdpUnifiedPlanUtils = __importStar(require("a0bc00bd8ea8e244"));
const HandlerInterface_1 = require("746221cdc3d8777c");
const RemoteSdp_1 = require("5d9899c7f0f3a469");
const scalabilityModes_1 = require("ed975282ce5bdc88");
const logger = new Logger_1.Logger("Firefox60");
const SCTP_NUM_STREAMS = {
    OS: 16,
    MIS: 2048
};
class Firefox60 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Firefox60();
    }
    constructor(){
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Firefox60";
    }
    close() {
        logger.debug("close()");
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
        });
        // NOTE: We need to add a real video track to get the RID extension mapping.
        const canvas = document.createElement("canvas");
        // NOTE: Otherwise Firefox fails in next line.
        canvas.getContext("2d");
        const fakeStream = canvas.captureStream();
        const fakeVideoTrack = fakeStream.getVideoTracks()[0];
        try {
            pc.addTransceiver("audio", {
                direction: "sendrecv"
            });
            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
                direction: "sendrecv"
            });
            const parameters = videoTransceiver.sender.getParameters();
            const encodings = [
                {
                    rid: "r0",
                    maxBitrate: 100000
                },
                {
                    rid: "r1",
                    maxBitrate: 500000
                }
            ];
            parameters.encodings = encodings;
            await videoTransceiver.sender.setParameters(parameters);
            const offer = await pc.createOffer();
            try {
                canvas.remove();
            } catch (error) {}
            try {
                fakeVideoTrack.stop();
            } catch (error) {}
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                canvas.remove();
            } catch (error2) {}
            try {
                fakeVideoTrack.stop();
            } catch (error2) {}
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else this._pc.addEventListener("iceconnectionstatechange", ()=>{
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            switch(this._pc.iceConnectionState){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        // NOTE: Firefox does not implement pc.setConfiguration().
        throw new errors_1.UnsupportedError("not supported");
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (encodings) {
            encodings = utils.clone(encodings, []);
            if (encodings.length > 1) {
                encodings.forEach((encoding, idx)=>{
                    encoding.rid = `r${idx}`;
                });
                // Clone the encodings and reverse them because Firefox likes them
                // from high to low.
                encodings.reverse();
            }
        }
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        // NOTE: Firefox fails sometimes to properly anticipate the closed media
        // section that it should use, so don't reuse closed media sections.
        //   https://github.com/versatica/mediasoup-client/issues/104
        //
        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [
                this._sendStream
            ]
        });
        // NOTE: This is not spec compliants. Encodings should be given in addTransceiver
        // second argument, but Firefox does not support it.
        if (encodings) {
            const parameters = transceiver.sender.getParameters();
            parameters.encodings = encodings;
            await transceiver.sender.setParameters(parameters);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        // In Firefox use DTLS role client even if we are the "offerer" since
        // Firefox does not respect ICE-Lite.
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: "client",
            localSdpObject
        });
        const layers = (0, scalabilityModes_1.parse)((encodings || [
            {}
        ])[0].scalabilityMode);
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
        });
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        } else sendingRtpParameters.encodings = encodings.reverse();
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings)if (encoding.scalabilityMode) encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
            else encoding.scalabilityMode = "L1T3";
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        logger.debug("stopSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated transceiver not found");
        transceiver.sender.replaceTrack(null);
        // NOTE: Cannot use stop() the transceiver due to the the note above in
        // send() method.
        // try
        // {
        // 	transceiver.stop();
        // }
        // catch (error)
        // {}
        this._pc.removeTrack(transceiver.sender);
        // NOTE: Cannot use closeMediaSection() due to the the note above in send()
        // method.
        // this._remoteSdp!.closeMediaSection(transceiver.mid);
        this._remoteSdp.disableMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "sendonly";
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated transceiver not found");
        const parameters = transceiver.sender.getParameters();
        // NOTE: We require encodings given from low to high, however Firefox
        // requires them in reverse order, so do magic here.
        spatialLayer = parameters.encodings.length - 1 - spatialLayer;
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx >= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    optionsList) {
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { trackId , rtpParameters  } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
            answer = {
                type: "answer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { trackId  } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t)=>t.mid === localId);
            if (!transceiver) throw new Error("new RTCRtpTransceiver not found");
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds)this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.Firefox60 = Firefox60;

},{"10bc1f8110fb752e":"8vPQN","fda3f8391318b35":"co3ME","af186b9fc6fd9976":"Xq57d","238548c87cf347f7":"6bv4j","1fcd847a0b56bce7":"jtITX","ca3cbe52bc73a9f":"f6oEu","a0bc00bd8ea8e244":"3n46G","746221cdc3d8777c":"50jj4","5d9899c7f0f3a469":"fsxdK","ed975282ce5bdc88":"hE1NO"}],"c427S":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Safari12 = void 0;
const sdpTransform = __importStar(require("118ae5ebda5e0dc8"));
const Logger_1 = require("75d031c01da68a4");
const utils = __importStar(require("efdbcf3660788ed1"));
const ortc = __importStar(require("cbc642e82b2c2d8b"));
const sdpCommonUtils = __importStar(require("1163d2eb28c5f47c"));
const sdpUnifiedPlanUtils = __importStar(require("a6793e87ba945737"));
const ortcUtils = __importStar(require("bb6833effe49453d"));
const HandlerInterface_1 = require("77d572fb84403a3c");
const RemoteSdp_1 = require("916c9a2c1375724b");
const scalabilityModes_1 = require("42971ad2b5af5b8a");
const logger = new Logger_1.Logger("Safari12");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class Safari12 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Safari12();
    }
    constructor(){
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Safari12";
    }
    close() {
        logger.debug("close()");
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
        });
        try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else this._pc.addEventListener("iceconnectionstatechange", ()=>{
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            switch(this._pc.iceConnectionState){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [
                this._sendStream
            ]
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        const layers = (0, scalabilityModes_1.parse)((encodings || [
            {}
        ])[0].scalabilityMode);
        if (encodings && encodings.length > 1) {
            logger.debug("send() | enabling legacy simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
        });
        // Complete encodings with given values.
        if (encodings) {
            for(let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx)if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings)if (encoding.scalabilityMode) encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
            else encoding.scalabilityMode = "L1T3";
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) try {
            transceiver.stop();
        } catch (error) {}
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "sendonly";
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx <= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { trackId , rtpParameters  } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { trackId  } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t)=>t.mid === localId);
            if (!transceiver) throw new Error("new RTCRtpTransceiver not found");
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds)this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.Safari12 = Safari12;

},{"118ae5ebda5e0dc8":"8vPQN","75d031c01da68a4":"co3ME","efdbcf3660788ed1":"6bv4j","cbc642e82b2c2d8b":"jtITX","1163d2eb28c5f47c":"f6oEu","a6793e87ba945737":"3n46G","bb6833effe49453d":"jQP2l","77d572fb84403a3c":"50jj4","916c9a2c1375724b":"fsxdK","42971ad2b5af5b8a":"hE1NO"}],"6eg0I":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Safari11 = void 0;
const sdpTransform = __importStar(require("a0d0133515496956"));
const Logger_1 = require("a5e5bf87d87753ee");
const utils = __importStar(require("e6bf60d7806b87d8"));
const ortc = __importStar(require("ccf1f3a9f6bcd375"));
const sdpCommonUtils = __importStar(require("18025d744818751e"));
const sdpPlanBUtils = __importStar(require("b9d28c9f78cfb6f0"));
const HandlerInterface_1 = require("903caa9885739960");
const RemoteSdp_1 = require("dd4bdbec0e17188");
const logger = new Logger_1.Logger("Safari11");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class Safari11 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Safari11();
    }
    constructor(){
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of RTCRtpSender indexed by localId.
        this._mapSendLocalIdRtpSender = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Safari11";
    }
    close() {
        logger.debug("close()");
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else this._pc.addEventListener("iceconnectionstatechange", ()=>{
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            switch(this._pc.iceConnectionState){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (codec) logger.warn("send() | codec selection is not available in %s handler", this.name);
        this._sendStream.addTrack(track);
        this._pc.addTrack(track, this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        if (track.kind === "video" && encodings && encodings.length > 1) {
            logger.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m)=>m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m)=>m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
        });
        // Complete encodings with given values.
        if (encodings) {
            for(let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx)if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
        }
        // If VP8 and there is effective simulcast, add scalabilityMode to each
        // encoding.
        if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") for (const encoding of sendingRtpParameters.encodings)encoding.scalabilityMode = "L1T3";
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        const rtpSender = this._pc.getSenders().find((s)=>s.track === track);
        // Insert into the map.
        this._mapSendLocalIdRtpSender.set(localId, rtpSender);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        if (rtpSender.track) this._sendStream.removeTrack(rtpSender.track);
        this._mapSendLocalIdRtpSender.delete(localId);
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        try {
            await this._pc.setLocalDescription(offer);
        } catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === "stable") return;
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
    // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
    // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        const oldTrack = rtpSender.track;
        await rtpSender.replaceTrack(track);
        // Remove the old track from the local stream.
        if (oldTrack) this._sendStream.removeTrack(oldTrack);
        // Add the new track to the local stream.
        if (track) this._sendStream.addTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx <= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
        if (!rtpSender) throw new Error("associated RTCRtpSender not found");
        return rtpSender.getStats();
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { kind , rtpParameters  } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { kind , trackId , rtpParameters  } = options;
            const mid = kind;
            const localId = trackId;
            const rtpReceiver = this._pc.getReceivers().find((r)=>r.track && r.track.id === localId);
            if (!rtpReceiver) throw new Error("new RTCRtpReceiver not");
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters,
                rtpReceiver
            });
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const { mid , rtpParameters  } = this._mapRecvLocalIdInfo.get(localId) || {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const { rtpReceiver  } = this._mapRecvLocalIdInfo.get(localId) || {};
        if (!rtpReceiver) throw new Error("associated RTCRtpReceiver not found");
        return rtpReceiver.getStats();
    }
    async pauseReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async resumeReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
            });
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.Safari11 = Safari11;

},{"a0d0133515496956":"8vPQN","a5e5bf87d87753ee":"co3ME","e6bf60d7806b87d8":"6bv4j","ccf1f3a9f6bcd375":"jtITX","18025d744818751e":"f6oEu","b9d28c9f78cfb6f0":"dHdjJ","903caa9885739960":"50jj4","dd4bdbec0e17188":"fsxdK"}],"2IvZ5":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Edge11 = void 0;
const Logger_1 = require("3cbecf0e1044efef");
const errors_1 = require("b9edea659772db88");
const utils = __importStar(require("9b76c74e1fbe2f38"));
const ortc = __importStar(require("4aeaffb71931147a"));
const edgeUtils = __importStar(require("a0eddd9cbfd62c7c"));
const HandlerInterface_1 = require("ee819c510b7d98f3");
const logger = new Logger_1.Logger("Edge11");
class Edge11 extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new Edge11();
    }
    constructor(){
        super();
        // Map of RTCRtpSenders indexed by id.
        this._rtpSenders = new Map();
        // Map of RTCRtpReceivers indexed by id.
        this._rtpReceivers = new Map();
        // Next localId for sending tracks.
        this._nextSendLocalId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "Edge11";
    }
    close() {
        logger.debug("close()");
        // Close the ICE gatherer.
        // NOTE: Not yet implemented by Edge.
        try {
            this._iceGatherer.close();
        } catch (error) {}
        // Close the ICE transport.
        try {
            this._iceTransport.stop();
        } catch (error) {}
        // Close the DTLS transport.
        try {
            this._dtlsTransport.stop();
        } catch (error) {}
        // Close RTCRtpSenders.
        for (const rtpSender of this._rtpSenders.values())try {
            rtpSender.stop();
        } catch (error) {}
        // Close RTCRtpReceivers.
        for (const rtpReceiver of this._rtpReceivers.values())try {
            rtpReceiver.stop();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        return edgeUtils.getCapabilities();
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: {
                OS: 0,
                MIS: 0
            }
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._remoteIceParameters = iceParameters;
        this._remoteIceCandidates = iceCandidates;
        this._remoteDtlsParameters = dtlsParameters;
        this._cname = `CNAME-${utils.generateRandomNumber()}`;
        this.setIceGatherer({
            iceServers,
            iceTransportPolicy
        });
        this.setIceTransport();
        this.setDtlsTransport();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        // NOTE: Edge 11 does not implement iceGatherer.gater().
        throw new errors_1.UnsupportedError("not supported");
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        this._remoteIceParameters = iceParameters;
        if (!this._transportReady) return;
        logger.debug("restartIce() | calling iceTransport.start()");
        this._iceTransport.start(this._iceGatherer, iceParameters, "controlling");
        for (const candidate of this._remoteIceCandidates)this._iceTransport.addRemoteCandidate(candidate);
        this._iceTransport.addRemoteCandidate({});
    }
    async getTransportStats() {
        return this._iceTransport.getStats();
    }
    async send(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    { track , encodings , codecOptions , codec  }) {
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: "server"
        });
        logger.debug("send() | calling new RTCRtpSender()");
        const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
        const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
        const useRtx = rtpParameters.codecs.some((_codec)=>/.+\/rtx$/i.test(_codec.mimeType));
        if (!encodings) encodings = [
            {}
        ];
        for (const encoding of encodings){
            encoding.ssrc = utils.generateRandomNumber();
            if (useRtx) encoding.rtx = {
                ssrc: utils.generateRandomNumber()
            };
        }
        rtpParameters.encodings = encodings;
        // Fill RTCRtpParameters.rtcp.
        rtpParameters.rtcp = {
            cname: this._cname,
            reducedSize: true,
            mux: true
        };
        // NOTE: Convert our standard RTCRtpParameters into those that Edge
        // expects.
        const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
        logger.debug("send() | calling rtpSender.send() [params:%o]", edgeRtpParameters);
        await rtpSender.send(edgeRtpParameters);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Store it.
        this._rtpSenders.set(localId, rtpSender);
        return {
            localId,
            rtpParameters,
            rtpSender
        };
    }
    async stopSending(localId) {
        logger.debug("stopSending() [localId:%s]", localId);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) throw new Error("RTCRtpSender not found");
        this._rtpSenders.delete(localId);
        try {
            logger.debug("stopSending() | calling rtpSender.stop()");
            rtpSender.stop();
        } catch (error) {
            logger.warn("stopSending() | rtpSender.stop() failed:%o", error);
            throw error;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
    // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
    // Unimplemented.
    }
    async replaceTrack(localId, track) {
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) throw new Error("RTCRtpSender not found");
        rtpSender.setTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) throw new Error("RTCRtpSender not found");
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx <= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await rtpSender.setParameters(parameters);
    }
    async setRtpEncodingParameters(localId, params) {
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) throw new Error("RTCRtpSender not found");
        const parameters = rtpSender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await rtpSender.setParameters(parameters);
    }
    async getSenderStats(localId) {
        const rtpSender = this._rtpSenders.get(localId);
        if (!rtpSender) throw new Error("RTCRtpSender not found");
        return rtpSender.getStats();
    }
    async sendDataChannel(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    async receive(optionsList) {
        const results = [];
        for (const options of optionsList){
            const { trackId , kind  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
        }
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: "server"
        });
        for (const options of optionsList){
            const { trackId , kind , rtpParameters  } = options;
            logger.debug("receive() | calling new RTCRtpReceiver()");
            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
            rtpReceiver.addEventListener("error", (event)=>{
                logger.error('rtpReceiver "error" event [event:%o]', event);
            });
            // NOTE: Convert our standard RTCRtpParameters into those that Edge
            // expects.
            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
            logger.debug("receive() | calling rtpReceiver.receive() [params:%o]", edgeRtpParameters);
            await rtpReceiver.receive(edgeRtpParameters);
            const localId = trackId;
            // Store it.
            this._rtpReceivers.set(localId, rtpReceiver);
            results.push({
                localId,
                track: rtpReceiver.track,
                rtpReceiver
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const rtpReceiver = this._rtpReceivers.get(localId);
            if (!rtpReceiver) throw new Error("RTCRtpReceiver not found");
            this._rtpReceivers.delete(localId);
            try {
                logger.debug("stopReceiving() | calling rtpReceiver.stop()");
                rtpReceiver.stop();
            } catch (error) {
                logger.warn("stopReceiving() | rtpReceiver.stop() failed:%o", error);
            }
        }
    }
    async pauseReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async resumeReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async getReceiverStats(localId) {
        const rtpReceiver = this._rtpReceivers.get(localId);
        if (!rtpReceiver) throw new Error("RTCRtpReceiver not found");
        return rtpReceiver.getStats();
    }
    async receiveDataChannel(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    setIceGatherer({ iceServers , iceTransportPolicy  }) {
        // @ts-ignore
        const iceGatherer = new RTCIceGatherer({
            iceServers: iceServers || [],
            gatherPolicy: iceTransportPolicy || "all"
        });
        iceGatherer.addEventListener("error", (event)=>{
            logger.error('iceGatherer "error" event [event:%o]', event);
        });
        // NOTE: Not yet implemented by Edge, which starts gathering automatically.
        try {
            iceGatherer.gather();
        } catch (error) {
            logger.debug("setIceGatherer() | iceGatherer.gather() failed: %s", error.toString());
        }
        this._iceGatherer = iceGatherer;
    }
    setIceTransport() {
        const iceTransport = new RTCIceTransport(this._iceGatherer);
        // NOTE: Not yet implemented by Edge.
        iceTransport.addEventListener("statechange", ()=>{
            switch(iceTransport.state){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
        // NOTE: Not standard, but implemented by Edge.
        iceTransport.addEventListener("icestatechange", ()=>{
            switch(iceTransport.state){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
        iceTransport.addEventListener("candidatepairchange", (event)=>{
            logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
        });
        this._iceTransport = iceTransport;
    }
    setDtlsTransport() {
        const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
        // NOTE: Not yet implemented by Edge.
        dtlsTransport.addEventListener("statechange", ()=>{
            logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
        });
        // NOTE: Not standard, but implemented by Edge.
        dtlsTransport.addEventListener("dtlsstatechange", ()=>{
            logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
            if (dtlsTransport.state === "closed") this.emit("@connectionstatechange", "closed");
        });
        dtlsTransport.addEventListener("error", (event)=>{
            logger.error('dtlsTransport "error" event [event:%o]', event);
        });
        this._dtlsTransport = dtlsTransport;
    }
    async setupTransport({ localDtlsRole  }) {
        logger.debug("setupTransport()");
        // Get our local DTLS parameters.
        const dtlsParameters = this._dtlsTransport.getLocalParameters();
        dtlsParameters.role = localDtlsRole;
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        // Start the RTCIceTransport.
        this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, "controlling");
        // Add remote ICE candidates.
        for (const candidate of this._remoteIceCandidates)this._iceTransport.addRemoteCandidate(candidate);
        // Also signal a 'complete' candidate as per spec.
        // NOTE: It should be {complete: true} but Edge prefers {}.
        // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
        // won't enter the 'completed' state.
        this._iceTransport.addRemoteCandidate({});
        // NOTE: Edge does not like SHA less than 256.
        this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints.filter((fingerprint)=>{
            return fingerprint.algorithm === "sha-256" || fingerprint.algorithm === "sha-384" || fingerprint.algorithm === "sha-512";
        });
        // Start the RTCDtlsTransport.
        this._dtlsTransport.start(this._remoteDtlsParameters);
        this._transportReady = true;
    }
}
exports.Edge11 = Edge11;

},{"3cbecf0e1044efef":"co3ME","b9edea659772db88":"Xq57d","9b76c74e1fbe2f38":"6bv4j","4aeaffb71931147a":"jtITX","a0eddd9cbfd62c7c":"fUbEN","ee819c510b7d98f3":"50jj4"}],"fUbEN":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mangleRtpParameters = exports.getCapabilities = void 0;
const utils = __importStar(require("84713645536aa1e5"));
/**
 * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
 * compliant ORTC RTCRtpCapabilities.
 */ function getCapabilities() {
    const nativeCaps = RTCRtpReceiver.getCapabilities();
    const caps = utils.clone(nativeCaps, {});
    for (const codec of caps.codecs){
        // Rename numChannels to channels.
        codec.channels = codec.numChannels;
        delete codec.numChannels;
        // Add mimeType.
        codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;
        // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
        if (codec.parameters) {
            const parameters = codec.parameters;
            if (parameters.apt) parameters.apt = Number(parameters.apt);
            if (parameters["packetization-mode"]) parameters["packetization-mode"] = Number(parameters["packetization-mode"]);
        }
        // Delete emty parameter String in rtcpFeedback.
        for (const feedback of codec.rtcpFeedback || [])if (!feedback.parameter) feedback.parameter = "";
    }
    return caps;
}
exports.getCapabilities = getCapabilities;
/**
 * Generate RTCRtpParameters as ORTC based Edge likes.
 */ function mangleRtpParameters(rtpParameters) {
    const params = utils.clone(rtpParameters, {});
    // Rename mid to muxId.
    if (params.mid) {
        params.muxId = params.mid;
        delete params.mid;
    }
    for (const codec of params.codecs){
        // Rename channels to numChannels.
        if (codec.channels) {
            codec.numChannels = codec.channels;
            delete codec.channels;
        }
        // Add codec.name (requried by Edge).
        if (codec.mimeType && !codec.name) codec.name = codec.mimeType.split("/")[1];
        // Remove mimeType.
        delete codec.mimeType;
    }
    return params;
}
exports.mangleRtpParameters = mangleRtpParameters;

},{"84713645536aa1e5":"6bv4j"}],"uwD4F":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReactNativeUnifiedPlan = void 0;
const sdpTransform = __importStar(require("e0c2efe7fdc3fc28"));
const Logger_1 = require("ffd6c5b428e4bc68");
const utils = __importStar(require("6553d755b46438ef"));
const ortc = __importStar(require("ff931c52db674f93"));
const sdpCommonUtils = __importStar(require("a7d46613589662b0"));
const sdpUnifiedPlanUtils = __importStar(require("2d2c869bd50bda00"));
const ortcUtils = __importStar(require("5fddc8cf6e3d2890"));
const HandlerInterface_1 = require("8e2ed892b31445aa");
const RemoteSdp_1 = require("342397a569e5182f");
const scalabilityModes_1 = require("2ed7968ce9bff475");
const logger = new Logger_1.Logger("ReactNativeUnifiedPlan");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class ReactNativeUnifiedPlan extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new ReactNativeUnifiedPlan();
    }
    constructor(){
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "ReactNativeUnifiedPlan";
    }
    close() {
        logger.debug("close()");
        // Free/dispose native MediaStream but DO NOT free/dispose native
        // MediaStreamTracks (that is parent's business).
        // @ts-ignore (proprietary API in react-native-webrtc).
        this._sendStream.release(/* releaseTracks */ false);
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
        });
        try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            // libwebrtc supports NACK for OPUS but doesn't announce it.
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else this._pc.addEventListener("iceconnectionstatechange", ()=>{
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            switch(this._pc.iceConnectionState){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (encodings && encodings.length > 1) encodings.forEach((encoding, idx)=>{
            encoding.rid = `r${idx}`;
        });
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [
                this._sendStream
            ],
            sendEncodings: encodings
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings || [
            {}
        ])[0].scalabilityMode);
        if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
        });
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc) newEncodings = [
                newEncodings[0]
            ];
            sendingRtpParameters.encodings = newEncodings;
        } else sendingRtpParameters.encodings = encodings;
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings)if (encoding.scalabilityMode) encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
            else encoding.scalabilityMode = "L1T3";
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) try {
            transceiver.stop();
        } catch (error) {}
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        transceiver.direction = "sendonly";
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertSendDirection();
        if (track) logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        else logger.debug("replaceTrack() [localId:%s, no track]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            if (idx <= spatialLayer) encoding.active = true;
            else encoding.active = false;
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx)=>{
            parameters.encodings[idx] = {
                ...encoding,
                ...params
            };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList){
            const { trackId , kind , rtpParameters , streamId  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId || rtpParameters.rtcp.cname,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { trackId , rtpParameters  } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { trackId  } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t)=>t.mid === localId);
            if (!transceiver) throw new Error("new RTCRtpTransceiver not found");
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds)this._mapMidTransceiver.delete(localId);
    }
    async pauseReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) throw new Error("associated RTCRtpTransceiver not found");
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;

},{"e0c2efe7fdc3fc28":"8vPQN","ffd6c5b428e4bc68":"co3ME","6553d755b46438ef":"6bv4j","ff931c52db674f93":"jtITX","a7d46613589662b0":"f6oEu","2d2c869bd50bda00":"3n46G","5fddc8cf6e3d2890":"jQP2l","8e2ed892b31445aa":"50jj4","342397a569e5182f":"fsxdK","2ed7968ce9bff475":"hE1NO"}],"8x6NC":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReactNative = void 0;
const sdpTransform = __importStar(require("1d0985ec8416d18b"));
const Logger_1 = require("7aa44d30929fa28b");
const errors_1 = require("a316190c443ea4ba");
const utils = __importStar(require("7c0cea6e687736ec"));
const ortc = __importStar(require("669cbc34e8175cb2"));
const sdpCommonUtils = __importStar(require("5082c0799977902b"));
const sdpPlanBUtils = __importStar(require("d08d93ec1f0634d3"));
const HandlerInterface_1 = require("ec86edcf34d86f2b");
const RemoteSdp_1 = require("12e6d2c4ea2a93d6");
const logger = new Logger_1.Logger("ReactNative");
const SCTP_NUM_STREAMS = {
    OS: 1024,
    MIS: 1024
};
class ReactNative extends HandlerInterface_1.HandlerInterface {
    /**
     * Creates a factory function.
     */ static createFactory() {
        return ()=>new ReactNative();
    }
    constructor(){
        super();
        // Local stream for sending.
        this._sendStream = new MediaStream();
        // Map of sending MediaStreamTracks indexed by localId.
        this._mapSendLocalIdTrack = new Map();
        // Next sending localId.
        this._nextSendLocalId = 0;
        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
        // Value is an Object with mid, rtpParameters and rtpReceiver.
        this._mapRecvLocalIdInfo = new Map();
        // Whether a DataChannel m=application section has been created.
        this._hasDataChannelMediaSection = false;
        // Sending DataChannel id value counter. Incremented for each new DataChannel.
        this._nextSendSctpStreamId = 0;
        // Got transport local and remote parameters.
        this._transportReady = false;
    }
    get name() {
        return "ReactNative";
    }
    close() {
        logger.debug("close()");
        // Free/dispose native MediaStream but DO NOT free/dispose native
        // MediaStreamTracks (that is parent's business).
        // @ts-ignore (proprietary API in react-native-webrtc).
        this._sendStream.release(/* releaseTracks */ false);
        // Close RTCPeerConnection.
        if (this._pc) try {
            this._pc.close();
        } catch (error) {}
        this.emit("@close");
    }
    async getNativeRtpCapabilities() {
        logger.debug("getNativeRtpCapabilities()");
        const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
        });
        try {
            const offer = await pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });
            try {
                pc.close();
            } catch (error) {}
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                sdpObject
            });
            return nativeRtpCapabilities;
        } catch (error) {
            try {
                pc.close();
            } catch (error2) {}
            throw error;
        }
    }
    async getNativeSctpCapabilities() {
        logger.debug("getNativeSctpCapabilities()");
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction , iceParameters , iceCandidates , dtlsParameters , sctpParameters , iceServers , iceTransportPolicy , additionalSettings , proprietaryConstraints , extendedRtpCapabilities  }) {
        logger.debug("run()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
        };
        if (dtlsParameters.role && dtlsParameters.role !== "auto") this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
        }, proprietaryConstraints);
        if (this._pc.connectionState) this._pc.addEventListener("connectionstatechange", ()=>{
            this.emit("@connectionstatechange", this._pc.connectionState);
        });
        else this._pc.addEventListener("iceconnectionstatechange", ()=>{
            logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            switch(this._pc.iceConnectionState){
                case "checking":
                    this.emit("@connectionstatechange", "connecting");
                    break;
                case "connected":
                case "completed":
                    this.emit("@connectionstatechange", "connected");
                    break;
                case "failed":
                    this.emit("@connectionstatechange", "failed");
                    break;
                case "disconnected":
                    this.emit("@connectionstatechange", "disconnected");
                    break;
                case "closed":
                    this.emit("@connectionstatechange", "closed");
                    break;
            }
        });
    }
    async updateIceServers(iceServers) {
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        logger.debug("restartIce()");
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) return;
        if (this._direction === "send") {
            const offer = await this._pc.createOffer({
                iceRestart: true
            });
            logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
        } else {
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        return this._pc.getStats();
    }
    async send({ track , encodings , codecOptions , codec  }) {
        var _a;
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (codec) logger.warn("send() | codec selection is not available in %s handler", this.name);
        this._sendStream.addTrack(track);
        this._pc.addStream(this._sendStream);
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        let offerMediaObject;
        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        if (track.kind === "video" && encodings && encodings.length > 1) {
            logger.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m)=>m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
                offerMediaObject,
                track,
                numStreams: encodings.length
            });
            offer = {
                type: "offer",
                sdp: sdpTransform.write(localSdpObject)
            };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media.find((m)=>m.type === track.kind);
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
        });
        // Complete encodings with given values.
        if (encodings) {
            for(let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx)if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) for (const encoding of sendingRtpParameters.encodings)encoding.scalabilityMode = "L1T3";
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
        });
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        const localId = String(this._nextSendLocalId);
        this._nextSendLocalId++;
        // Insert into the map.
        this._mapSendLocalIdTrack.set(localId, track);
        return {
            localId: localId,
            rtpParameters: sendingRtpParameters
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        const track = this._mapSendLocalIdTrack.get(localId);
        if (!track) throw new Error("track not found");
        this._mapSendLocalIdTrack.delete(localId);
        this._sendStream.removeTrack(track);
        this._pc.addStream(this._sendStream);
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        try {
            await this._pc.setLocalDescription(offer);
        } catch (error) {
            // NOTE: If there are no sending tracks, setLocalDescription() will fail with
            // "Failed to create channels". If so, ignore it.
            if (this._sendStream.getTracks().length === 0) {
                logger.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
                return;
            }
            throw error;
        }
        if (this._pc.signalingState === "stable") return;
        const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
    // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
    // Unimplemented.
    }
    async replaceTrack(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localId, track) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setMaxSpatialLayer(localId, spatialLayer) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setRtpEncodingParameters(localId, params) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    async sendDataChannel({ ordered , maxPacketLifeTime , maxRetransmits , label , protocol  }) {
        var _a;
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m)=>m.type === "application");
            if (!this._transportReady) await this.setupTransport({
                localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                localSdpObject
            });
            logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({
                offerMediaObject
            });
            const answer = {
                type: "answer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
        };
        return {
            dataChannel,
            sctpStreamParameters
        };
    }
    async receive(optionsList) {
        var _a;
        this.assertRecvDirection();
        const results = [];
        const mapStreamId = new Map();
        for (const options of optionsList){
            const { trackId , kind , rtpParameters  } = options;
            logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            let streamId = options.streamId || rtpParameters.rtcp.cname;
            // NOTE: In React-Native we cannot reuse the same remote MediaStream for new
            // remote tracks. This is because react-native-webrtc does not react on new
            // tracks generated within already existing streams, so force the streamId
            // to be different. See:
            // https://github.com/react-native-webrtc/react-native-webrtc/issues/401
            logger.debug("receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc");
            streamId += `-hack-${utils.generateRandomNumber()}`;
            mapStreamId.set(trackId, streamId);
            this._remoteSdp.receive({
                mid,
                kind,
                offerRtpParameters: rtpParameters,
                streamId,
                trackId
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList){
            const { kind , rtpParameters  } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m)=>String(m.mid) === mid);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject
            });
        }
        answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) await this.setupTransport({
            localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
            localSdpObject
        });
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList){
            const { kind , trackId , rtpParameters  } = options;
            const localId = trackId;
            const mid = kind;
            const streamId = mapStreamId.get(trackId);
            const stream = this._pc.getRemoteStreams().find((s)=>s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) throw new Error("remote track not found");
            // Insert into the map.
            this._mapRecvLocalIdInfo.set(localId, {
                mid,
                rtpParameters
            });
            results.push({
                localId,
                track
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        for (const localId of localIds){
            logger.debug("stopReceiving() [localId:%s]", localId);
            const { mid , rtpParameters  } = this._mapRecvLocalIdInfo.get(localId) || {};
            // Remove from the map.
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
                mid: mid,
                offerRtpParameters: rtpParameters
            });
        }
        const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
    }
    async pauseReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    async resumeReceiving(// eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
    // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        throw new errors_1.UnsupportedError("not implemented");
    }
    async receiveDataChannel({ sctpStreamParameters , label , protocol  }) {
        var _a;
        this.assertRecvDirection();
        const { streamId , ordered , maxPacketLifeTime , maxRetransmits  } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({
                oldDataChannelSpec: true
            });
            const offer = {
                type: "offer",
                sdp: this._remoteSdp.getSdp()
            };
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: (_a = this._forcedLocalDtlsRole) !== null && _a !== void 0 ? _a : "client",
                    localSdpObject
                });
            }
            logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return {
            dataChannel
        };
    }
    async setupTransport({ localDtlsRole , localSdpObject  }) {
        if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject)=>{
            this.safeEmit("@connect", {
                dtlsParameters
            }, resolve, reject);
        });
        this._transportReady = true;
    }
    assertSendDirection() {
        if (this._direction !== "send") throw new Error('method can just be called for handlers with "send" direction');
    }
    assertRecvDirection() {
        if (this._direction !== "recv") throw new Error('method can just be called for handlers with "recv" direction');
    }
}
exports.ReactNative = ReactNative;

},{"1d0985ec8416d18b":"8vPQN","7aa44d30929fa28b":"co3ME","a316190c443ea4ba":"Xq57d","7c0cea6e687736ec":"6bv4j","669cbc34e8175cb2":"jtITX","5082c0799977902b":"f6oEu","d08d93ec1f0634d3":"dHdjJ","ec86edcf34d86f2b":"50jj4","12e6d2c4ea2a93d6":"fsxdK"}],"03TIr":[function(require,module,exports) {
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(require("be4803e2e9cc262e"), exports);
__exportStar(require("790a668e39666492"), exports);
__exportStar(require("b9c0c85f24a7c554"), exports);
__exportStar(require("eab3fd92706a8510"), exports);
__exportStar(require("4a463bc9e4aa8a87"), exports);
__exportStar(require("88ca4116efe2fa9f"), exports);
__exportStar(require("54e5b57af9fffab9"), exports);
__exportStar(require("8f05a0d4dbb80bf3"), exports);
__exportStar(require("49e9b7d8e5fde93a"), exports);
__exportStar(require("b81fb18f9ed75eb8"), exports);

},{"be4803e2e9cc262e":"jvSOG","790a668e39666492":"cWahd","b9c0c85f24a7c554":"50WSJ","eab3fd92706a8510":"fFe3n","4a463bc9e4aa8a87":"jIr6O","88ca4116efe2fa9f":"6C20m","54e5b57af9fffab9":"7ue6H","8f05a0d4dbb80bf3":"5ErJ7","49e9b7d8e5fde93a":"50jj4","b81fb18f9ed75eb8":"Xq57d"}],"7ue6H":[function(require,module,exports) {
"use strict";
/**
 * The RTP capabilities define what mediasoup or an endpoint can receive at
 * media level.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"5ErJ7":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"gWOO4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SfuTransport", ()=>SfuTransport);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _errors = require("../../errors");
var _plugin = require("../../plugin");
var _util = require("../../util");
const log = new (0, _core.Logger)("packages/sfu-bot/src/connection/transport/transport.ts");
class SfuTransport {
    get pc() {
        return this.msTransport?._handler?._pc ?? {};
    }
    get id() {
        return this.msTransport.id;
    }
    get connectionState() {
        return this._connectionState;
    }
    constructor(msTransport, _bot, _iceManager, _sfuApi, _context, _analyticsSession){
        this.msTransport = msTransport;
        this._bot = _bot;
        this._iceManager = _iceManager;
        this._sfuApi = _sfuApi;
        this._context = _context;
        this._analyticsSession = _analyticsSession;
        this._backoffIceRestart = new (0, _common.BackOff)({
            times: 8,
            interval: 100,
            jitter: 100
        });
        this._connectionState = "new";
        this.onProduce = new (0, _common.Event)();
        this.onProduceData = new (0, _common.Event)();
        this.onMediasoupConnectionStateChanged = new (0, _common.Event)();
        this.onConnectionStateChanged = new (0, _common.Event)();
        this.restartIce = async ()=>{
            if (this._backoffIceRestart.exceeded) {
                log.error("_iceRestartedCount exceeded", (0, _core.createError)({
                    operationName: "SfuTransport.restartIce",
                    context: this._context,
                    info: (0, _errors.errors).netWorkError,
                    path: log.prefix
                }));
                this._setConnectionState("disconnected");
                return;
            }
            log.warn("[start] restartIce", (0, _util.createWarnPayload)({
                bot: this._bot,
                detail: "start restartIce",
                operationName: "SfuTransport.restartIce",
                payload: {
                    count: this._backoffIceRestart.count,
                    transport: this
                }
            }));
            const checkNeedEnd = ()=>{
                if (this._bot.state === "left") {
                    log.debug("bot already left", this);
                    this._setConnectionState("disconnected");
                    log.warn("[end] restartIce", (0, _util.createWarnPayload)({
                        bot: this._bot,
                        detail: "end restartIce",
                        operationName: "SfuTransport.restartIce",
                        payload: {
                            count: this._backoffIceRestart.count,
                            transport: this
                        }
                    }));
                    return true;
                }
                if (this.msTransport.connectionState === "connected") {
                    this._backoffIceRestart.reset();
                    this._setConnectionState("connected");
                    log.warn("[end] restartIce", (0, _util.createWarnPayload)({
                        bot: this._bot,
                        detail: "end restartIce",
                        operationName: "SfuTransport.restartIce",
                        payload: {
                            count: this._backoffIceRestart.count,
                            transport: this
                        }
                    }));
                    if (this._analyticsSession && !this._analyticsSession.isClosed()) this._analyticsSession.client.sendRtcPeerConnectionEventReport({
                        rtcPeerConnectionId: this.id,
                        type: "restartIce",
                        data: undefined,
                        createdAt: Date.now()
                    });
                    return true;
                }
            };
            this._setConnectionState("reconnecting");
            await this._backoffIceRestart.wait();
            if (checkNeedEnd()) return;
            let e = await this._iceManager.updateIceParams().catch((e)=>e);
            if (e) {
                log.warn("updateIceParams failed", (0, _util.createWarnPayload)({
                    operationName: "SfuTransport.restartIce",
                    detail: "updateIceParams failed",
                    bot: this._bot,
                    payload: {
                        transport: this
                    }
                }), e);
                await this.restartIce();
                return;
            }
            await this.msTransport.updateIceServers({
                iceServers: this._iceManager.iceServers
            });
            if (checkNeedEnd()) return;
            const iceParameters = await this._mediasoupRestartIce();
            e = await this._waitForMsConnectionState("connected", this._context.config.rtcConfig.iceDisconnectBufferTimeout).catch((e)=>e);
            if (!e && checkNeedEnd()) return iceParameters;
            await this.restartIce();
        };
        this._waitForMsConnectionState = async (state, /**ms */ timeout = 10000)=>{
            if (state === this.msTransport.connectionState) return;
            await this.onMediasoupConnectionStateChanged.watch(()=>state === this.msTransport.connectionState, timeout).catch((err)=>{
                throw (0, _core.createError)({
                    operationName: "SfuTransport._waitForMsConnectionState",
                    context: this._context,
                    info: {
                        ...(0, _errors.errors).timeout,
                        detail: "waitForConnectionState timeout"
                    },
                    error: err,
                    path: log.prefix
                });
            });
        };
        this._onConnect = (transportId)=>async ({ dtlsParameters  }, callback, errback)=>{
                try {
                    log.debug("[start] transport connect", {
                        transportId
                    });
                    await this._sfuApi.connect({
                        transportId,
                        dtlsParameters
                    });
                    log.debug("[end] transport connect", {
                        transportId
                    });
                    callback();
                } catch (error) {
                    log.error("[failed] transport connect", {
                        error,
                        transportId
                    });
                    errback(error);
                }
            };
        const sfuPlugin = _context.plugins.find((p)=>p.subtype === (0, _plugin.SfuBotPlugin).subtype);
        this._options = sfuPlugin.options;
        log.debug("peerConfig", this.pc?.getConfiguration?.() ?? {});
        msTransport.on("connect", (params, callback, errback)=>this._onConnect(msTransport.id)(params, callback, errback));
        msTransport.on("connectionstatechange", (e)=>{
            this.onMediasoupConnectionStateChanged.emit(e);
            if (this._analyticsSession && !this._analyticsSession.isClosed()) this._analyticsSession.client.sendRtcPeerConnectionEventReport({
                rtcPeerConnectionId: this.id,
                type: "connectionStateChange",
                data: {
                    connectionState: e
                },
                createdAt: Date.now()
            });
        });
        msTransport.on("produce", (producerOptions, callback, errback)=>{
            this.onProduce.emit({
                producerOptions,
                callback: callback,
                errback: errback
            });
        });
        msTransport.on("producedata", (producerOptions, callback, errback)=>{
            this.onProduceData.emit({
                producerOptions,
                callback: callback,
                errback: errback
            });
        });
        this.onMediasoupConnectionStateChanged.add(async (state)=>{
            (0, _core.createLogPayload)({
                operationName: "onMediasoupConnectionStateChanged",
                channel: this._bot.channel
            }).then((debug)=>{
                log.debug(debug, {
                    state,
                    transportId: this.id,
                    bot: _bot
                });
            }).catch(()=>{});
            switch(state){
                case "disconnected":
                case "failed":
                    {
                        if (this._connectionState === "reconnecting") return;
                        const e = await this._waitForMsConnectionState("connected", _context.config.rtcConfig.iceDisconnectBufferTimeout).catch((e)=>e);
                        if (e && this._connectionState !== "reconnecting" && _bot.options.disableRestartIce !== true) await this.restartIce();
                    }
                    break;
                case "connecting":
                case "connected":
                    this._setConnectionState(state);
                    break;
                case "closed":
                    this._setConnectionState("disconnected");
                    break;
            }
            log.debug("onMediasoupConnectionStateChanged", this);
        });
    }
    toJSON() {
        return {
            id: this.id,
            direction: this.msTransport.direction,
            connectionState: this._connectionState
        };
    }
    close() {
        log.debug("close", this.id);
        // suppress firefox [RTCPeerConnection is gone] Exception
        if (this.pc?.peerIdentity) this.pc.peerIdentity.catch(()=>{});
        this.msTransport.close();
        this._setConnectionState("disconnected");
    }
    _setConnectionState(state) {
        if (this._connectionState === state) return;
        log.debug("onConnectionStateChanged", this._connectionState, state, this);
        this._connectionState = state;
        this.onConnectionStateChanged.emit(state);
        if (this._analyticsSession && !this._analyticsSession.isClosed()) this._analyticsSession.client.sendRtcPeerConnectionEventReport({
            rtcPeerConnectionId: this.id,
            type: "skywayConnectionStateChange",
            data: {
                skywayConnectionState: state
            },
            createdAt: Date.now()
        });
    }
    /**@private */ async _mediasoupRestartIce() {
        const iceParameters = await this._sfuApi.iceRestart({
            transportId: this.id
        }).catch((e)=>e);
        if (iceParameters instanceof Error) {
            log.warn("iceRestart failed", (0, _util.createWarnPayload)({
                operationName: "SfuTransport._mediasoupRestartIce",
                detail: "iceRestart failed",
                bot: this._bot,
                payload: {
                    transport: this
                }
            }), iceParameters);
            await this.restartIce();
            return;
        }
        await this.msTransport.restartIce({
            iceParameters
        });
        return iceParameters;
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","../../errors":"7iQ6i","../../plugin":"dgOkC","../../util":"57OJM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cC3mT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PACKAGE_VERSION", ()=>PACKAGE_VERSION);
const PACKAGE_VERSION = "1.9.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"25K2E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "RoomMemberImpl", ()=>RoomMemberImpl);
var _common = require("@skyway-sdk/common");
class RoomMemberImpl {
    get id() {
        return this.member.id;
    }
    get name() {
        return this.member.name;
    }
    get roomId() {
        return this.room.id;
    }
    get roomName() {
        return this.room.name;
    }
    get roomType() {
        return this.room.type;
    }
    get state() {
        return this.member.state;
    }
    get metadata() {
        return this.member.metadata;
    }
    constructor(member, room){
        this.member = member;
        this.room = room;
        this.onLeft = new (0, _common.Event)();
        const { removeListener  } = room.onMemberLeft.add((e)=>{
            if (e.member.id === this.member.id) {
                removeListener();
                this.onLeft.emit();
            }
        });
        this.onMetadataUpdated = member.onMetadataUpdated;
    }
    /**@private */ get _member() {
        return this.member;
    }
    get publications() {
        return this.room.publications.filter((p)=>p.publisher.id === this.id);
    }
    get subscriptions() {
        return this.member.subscriptions.map((s)=>this.room._getSubscription(s.id));
    }
    updateMetadata(metadata) {
        return this.member.updateMetadata(metadata);
    }
    leave() {
        return this.member.leave();
    }
    /**@internal */ toJSON() {
        return {
            id: this.id,
            name: this.name,
            metadata: this.metadata
        };
    }
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gVaVo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "LocalRoomMemberImpl", ()=>LocalRoomMemberImpl);
var _common = require("@skyway-sdk/common");
var _member = require("../../member");
class LocalRoomMemberImpl extends (0, _member.RoomMemberImpl) {
    side = "local";
    _local = this._member;
    onStreamPublished = new (0, _common.Event)();
    onStreamUnpublished = new (0, _common.Event)();
    onPublicationListChanged = new (0, _common.Event)();
    onPublicationSubscribed = new (0, _common.Event)();
    onPublicationUnsubscribed = new (0, _common.Event)();
    onSubscriptionListChanged = new (0, _common.Event)();
    onFatalError = new (0, _common.Event)();
    _context = this.room._context;
    /**@private */ constructor(member, room){
        super(member, room);
        this._local.onPublicationSubscribed.add(async (e)=>{
            const roomSubscription = room._addSubscription(e.subscription);
            this.onPublicationSubscribed.emit({
                subscription: roomSubscription,
                stream: e.stream
            });
        });
        this._local.onFatalError.pipe(this.onFatalError);
        this._listenRoomEvent();
        this.onStreamPublished.add(()=>this.onPublicationListChanged.emit());
        this.onStreamUnpublished.add(()=>this.onPublicationListChanged.emit());
        this.onPublicationSubscribed.add(()=>this.onSubscriptionListChanged.emit());
        this.onPublicationUnsubscribed.add(()=>this.onSubscriptionListChanged.emit());
    }
    get subscriptions() {
        return this.member.subscriptions.map((s)=>this.room._getSubscription(s.id)).filter((s)=>s.stream);
    }
    _listenRoomEvent() {
        this.room.onPublicationUnsubscribed.add((e)=>{
            if (e.subscription.subscriber._member.id === this._local.id) this.onPublicationUnsubscribed.emit(e);
        });
    }
}

},{"@skyway-sdk/common":"3hyrG","../../member":"25K2E","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3Zkj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "LocalP2PRoomMemberImpl", ()=>LocalP2PRoomMemberImpl);
var _common = require("@skyway-sdk/common");
var _errors = require("../../errors");
var _util = require("../../util");
var _base = require("./base");
const log = new (0, _common.Logger)("packages/room/src/member/local/p2p.ts");
class LocalP2PRoomMemberImpl extends (0, _base.LocalRoomMemberImpl) {
    /**@private */ constructor(member, room){
        super(member, room);
    }
    async publish(stream, options = {}) {
        const publication = await this._local.publish(stream, options);
        const roomPublication = this.room._addPublication(publication);
        this.onStreamPublished.emit({
            publication: roomPublication
        });
        return roomPublication;
    }
    async unpublish(target) {
        const publicationId = typeof target === "string" ? target : target.id;
        this._local.unpublish(publicationId).catch((error)=>{
            log.error("unpublish", error, {
                target
            }, this.toJSON());
        });
        const { publication  } = await this.room.onStreamUnpublished.watch((e)=>e.publication.id === publicationId, this._context.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "LocalP2PRoomMemberImpl.unpublish",
                context: this._context,
                room: this.room,
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onStreamUnpublished"
                },
                path: log.prefix,
                error
            });
        });
        this.onStreamUnpublished.emit({
            publication
        });
    }
    async subscribe(target) {
        const publicationId = typeof target === "string" ? target : target.id;
        const { subscription , stream  } = await this._local.subscribe(publicationId);
        const roomSubscription = this.room._addSubscription(subscription);
        return {
            subscription: roomSubscription,
            stream: stream
        };
    }
    async unsubscribe(target) {
        const subscriptionId = typeof target === "string" ? target : target.id;
        this._local.unsubscribe(subscriptionId).catch((error)=>{
            log.error("unsubscribe", error, {
                target
            }, this.toJSON());
        });
        await this.room.onPublicationUnsubscribed.watch((e)=>e.subscription.id === subscriptionId, this._context.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "LocalP2PRoomMemberImpl.unsubscribe",
                context: this._context,
                room: this.room,
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onPublicationUnsubscribed"
                },
                path: log.prefix,
                error
            });
        });
    }
    _updateRoom(room) {
        log.debug("_updateRoom", {
            memberId: this.id
        });
        this.room = room;
        this._listenRoomEvent();
    }
}

},{"@skyway-sdk/common":"3hyrG","../../errors":"d7AJ6","../../util":"2QeGu","./base":"gVaVo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2QeGu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createError", ()=>createError);
var _common = require("@skyway-sdk/common");
function createError({ operationName , context , info , error , path , payload , room  }) {
    const errPayload = {
        operationName,
        payload
    };
    if (room) {
        errPayload["appId"] = room._channel.appId;
        errPayload["roomId"] = room.id;
        if (room.localRoomMember) errPayload["memberId"] = room.localRoomMember.id;
    }
    if (context) {
        errPayload["info"] = context.info;
        errPayload["plugins"] = context.plugins.map((p)=>p.subtype);
    }
    return new (0, _common.SkyWayError)({
        error,
        info,
        payload: errPayload,
        path
    });
}

},{"@skyway-sdk/common":"3hyrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Q67n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "LocalSFURoomMemberImpl", ()=>LocalSFURoomMemberImpl);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _sfuBot = require("@skyway-sdk/sfu-bot");
var _const = require("../../const");
var _errors = require("../../errors");
var _util = require("../../util");
var _base = require("./base");
const log = new (0, _common.Logger)("packages/room/src/member/local/sfu.ts");
class LocalSFURoomMemberImpl extends (0, _base.LocalRoomMemberImpl) {
    /**@private */ constructor(member, room){
        super(member, room);
    }
    async publish(stream, options = {}) {
        if (stream instanceof (0, _core.LocalDataStream)) throw (0, _util.createError)({
            operationName: "LocalSFURoomMemberImpl.publish",
            context: this._context,
            room: this.room,
            info: (0, _errors.errors).sfuRoomNotSupportDataStream,
            path: log.prefix
        });
        options.maxSubscribers = options.maxSubscribers ?? (0, _const.defaultMaxSubscribers);
        const origin = await this._local.publish(stream, options);
        const bot = this.room._channel.members.find((m)=>m.subtype === (0, _sfuBot.SfuBotMember).subtype);
        if (!bot) throw (0, _util.createError)({
            operationName: "LocalSFURoomMemberImpl.publish",
            context: this._context,
            room: this.room,
            info: (0, _sfuBot.errors).sfuBotNotInChannel,
            path: log.prefix
        });
        const forwarding = await bot.startForwarding(origin, {
            maxSubscribers: options.maxSubscribers
        });
        const relayingPublication = forwarding.relayingPublication;
        const roomPublication = this.room._addPublication(relayingPublication);
        this.onStreamPublished.emit({
            publication: roomPublication
        });
        return roomPublication;
    }
    /**
   * @description [japanese] Room上のStreamをUnPublishする
   */ async unpublish(target) {
        const publicationId = typeof target === "string" ? target : target.id;
        const publication = this.room._getPublication(publicationId);
        const origin = publication._publication.origin;
        if (!origin) throw (0, _util.createError)({
            operationName: "LocalSFURoomMemberImpl.unpublish",
            context: this._context,
            room: this.room,
            info: (0, _errors.errors).publicationNotHasOrigin,
            path: log.prefix
        });
        this._local.unpublish(origin.id).catch((error)=>{
            log.error("unpublish error", error, {
                target
            }, this.toJSON());
        });
        await this.room.onStreamUnpublished.watch((e)=>e.publication.id === publicationId, this._context.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "LocalSFURoomMemberImpl.unpublish",
                context: this._context,
                room: this.room,
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onStreamUnpublished"
                },
                path: log.prefix,
                error
            });
        });
        this.onStreamUnpublished.emit({
            publication
        });
    }
    /**
   * @description [japanese] MemberがRoom上のStreamのPublicationをSubscribeする
   */ async subscribe(target, options) {
        const publicationId = typeof target === "string" ? target : target.id;
        const { subscription , stream  } = await this._local.subscribe(publicationId, options);
        const roomSubscription = this.room._addSubscription(subscription);
        return {
            subscription: roomSubscription,
            stream: stream
        };
    }
    /**
   * @description [japanese] MemberがSubscribeしているStreamのSubscriptionをUnSubscribeする
   */ async unsubscribe(target) {
        const subscriptionId = typeof target === "string" ? target : target.id;
        this._local.unsubscribe(subscriptionId).catch((error)=>{
            log.error("unsubscribe error", error, {
                target
            }, this.toJSON());
        });
        await this.room.onPublicationUnsubscribed.watch((e)=>e.subscription.id === subscriptionId, this._context.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "LocalSFURoomMemberImpl.unsubscribe",
                context: this._context,
                room: this.room,
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onPublicationUnsubscribed"
                },
                path: log.prefix,
                error
            });
        });
    }
    _updateRoom(room) {
        log.debug("_updateRoom", {
            memberId: this.id
        });
        this.room = room;
        this._listenRoomEvent();
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","@skyway-sdk/sfu-bot":"fgRbl","../../const":"8k3XR","../../errors":"d7AJ6","../../util":"2QeGu","./base":"gVaVo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8k3XR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultMaxSubscribers", ()=>defaultMaxSubscribers);
const defaultMaxSubscribers = 10;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Diig":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "RemoteRoomMemberImpl", ()=>RemoteRoomMemberImpl);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _errors = require("../../errors");
var _member = require("../../member");
var _util = require("../../util");
const log = new (0, _common.Logger)("packages/room/src/member/remote/base.ts");
class RemoteRoomMemberImpl extends (0, _member.RoomMemberImpl) {
    side = "remote";
    onPublicationSubscribed = new (0, _common.Event)();
    onPublicationUnsubscribed = new (0, _common.Event)();
    onSubscriptionListChanged = new (0, _common.Event)();
    onPublicationListChanged = new (0, _common.Event)();
    _disposer = new (0, _common.EventDisposer)();
    constructor(member, room){
        super(member, room);
        room.onPublicationSubscribed.add((e)=>{
            if (e.subscription.subscriber._member.id === member.id) {
                this.onPublicationSubscribed.emit(e);
                this.onSubscriptionListChanged.emit();
            }
        }).disposer(this._disposer);
        room.onPublicationUnsubscribed.add((e)=>{
            if (e.subscription.subscriber._member.id === member.id) {
                this.onPublicationUnsubscribed.emit(e);
                this.onSubscriptionListChanged.emit();
            }
        }).disposer(this._disposer);
        if (member instanceof (0, _core.RemotePersonImpl)) member.onPublicationListChanged.pipe(this.onPublicationListChanged).disposer(this._disposer);
    }
    subscribe = (publicationId)=>new Promise((r, f)=>{
            if (!(this.member instanceof (0, _core.RemotePersonImpl))) {
                f((0, _util.createError)({
                    operationName: "RemoteRoomMemberImpl.subscribe",
                    context: this.room._context,
                    room: this.room,
                    info: (0, _errors.errors).subscribeOtherMemberType,
                    path: log.prefix
                }));
                return;
            }
            let failed = false;
            this.member.subscribe(publicationId).catch((e)=>{
                failed = true;
                f(e);
            });
            this.onPublicationSubscribed.watch((e)=>e.subscription.publication.id === publicationId).then((e)=>r(e)).catch((e)=>{
                if (!failed) f(e);
            });
        });
    unsubscribe = (subscriptionId)=>new Promise((r, f)=>{
            if (!(this.member instanceof (0, _core.RemotePersonImpl))) {
                f((0, _util.createError)({
                    operationName: "RemoteRoomMemberImpl.unsubscribe",
                    context: this.room._context,
                    room: this.room,
                    info: (0, _errors.errors).subscribeOtherMemberType,
                    path: log.prefix
                }));
                return;
            }
            let failed = false;
            this.member.unsubscribe(subscriptionId).catch((e)=>{
                failed = true;
                f(e);
            });
            this.onPublicationUnsubscribed.watch((e)=>e.subscription.id === subscriptionId).then(()=>r()).catch((e)=>{
                if (!failed) f(e);
            });
        });
    /**@private */ _dispose() {
        this._disposer.dispose();
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","../../errors":"d7AJ6","../../member":"25K2E","../../util":"2QeGu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k9w39":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "RoomPublicationImpl", ()=>RoomPublicationImpl);
var _common = require("@skyway-sdk/common");
var _sfuBot = require("@skyway-sdk/sfu-bot");
var _errors = require("../errors");
var _util = require("../util");
const path = "packages/room/src/publication/index.ts";
const logger = new (0, _common.Logger)(path);
class RoomPublicationImpl {
    constructor(_publication, _room){
        this._publication = _publication;
        this._room = _room;
        this._disposer = new (0, _common.EventDisposer)();
        this._events = new (0, _common.Events)();
        this.onCanceled = this._events.make();
        this.onSubscribed = this._events.make();
        this.onUnsubscribed = this._events.make();
        this.onSubscriptionListChanged = this._events.make();
        this.onMetadataUpdated = this._events.make();
        this.onEnabled = this._events.make();
        this.onDisabled = this._events.make();
        this.onStateChanged = this._events.make();
        this.onConnectionStateChanged = new (0, _common.Event)();
        this.enable = ()=>new Promise((r, f)=>{
                if (this._origin) Promise.all([
                    this._origin.enable(),
                    this._publication.onEnabled.asPromise()
                ]).then(()=>r()).catch(f);
                else this._publication.enable().then(r).catch(f);
            });
        this.disable = ()=>new Promise((r, f)=>{
                if (this._origin) Promise.all([
                    this._origin.disable(),
                    this._publication.onDisabled.asPromise()
                ]).then(()=>r()).catch(f);
                else this._publication.disable().then(r).catch(f);
            });
        this.replaceStream = (stream, options = {})=>{
            this._preferredPublication.replaceStream(stream, options);
        };
        this.id = _publication.id;
        this.contentType = _publication.contentType;
        this._origin = _publication.origin;
        {
            const publication = this._origin ?? this._publication;
            this.publisher = this._room._getMember(publication.publisher.id);
        }
        this._setEvents();
    }
    _setEvents() {
        this._room.onStreamUnpublished.add((e)=>{
            if (e.publication.id === this.id) this._dispose();
        });
        this._room.onPublicationSubscribed.add((e)=>{
            if (e.subscription.publication.id === this.id) {
                this.onSubscribed.emit({
                    subscription: e.subscription
                });
                this.onSubscriptionListChanged.emit();
            }
        }).disposer(this._disposer);
        this._room.onPublicationUnsubscribed.add((e)=>{
            if (e.subscription.publication.id === this.id) {
                this.onUnsubscribed.emit({
                    subscription: e.subscription
                });
                this.onSubscriptionListChanged.emit();
            }
        }).disposer(this._disposer);
        this._publication.onEnabled.pipe(this.onEnabled);
        this._publication.onDisabled.pipe(this.onDisabled);
        this._publication.onStateChanged.pipe(this.onStateChanged);
        {
            const publication = this._origin ?? this._publication;
            publication.onMetadataUpdated.pipe(this.onMetadataUpdated);
        }
        if (this._origin) this._origin.onConnectionStateChanged.add((e)=>{
            logger.debug("this._origin.onConnectionStateChanged", this.id, e);
            this.onConnectionStateChanged.emit({
                state: e.state
            });
        });
        else this._publication.onConnectionStateChanged.add((e)=>{
            logger.debug("this._publication.onConnectionStateChanged", this.id, e);
            this.onConnectionStateChanged.emit({
                state: e.state,
                remoteMember: this._room._getMember(e.remoteMember.id)
            });
        });
    }
    get subscriptions() {
        return this._publication.subscriptions.map((s)=>this._room._getSubscription(s.id));
    }
    get _preferredPublication() {
        return this._origin ?? this._publication;
    }
    get codecCapabilities() {
        return this._preferredPublication.codecCapabilities;
    }
    get encodings() {
        return this._preferredPublication.encodings;
    }
    get stream() {
        return this._preferredPublication.stream;
    }
    get state() {
        return this._preferredPublication.state;
    }
    get metadata() {
        return this._preferredPublication.metadata;
    }
    async cancel() {
        await Promise.all([
            this._preferredPublication.cancel(),
            this.onCanceled.asPromise()
        ]);
    }
    async updateMetadata(metadata) {
        await this._preferredPublication.updateMetadata(metadata);
    }
    updateEncodings(encodings) {
        this._preferredPublication.updateEncodings(encodings);
    }
    _dispose() {
        this.onCanceled.emit();
        this._events.dispose();
        this._disposer.dispose();
    }
    getStats(selector) {
        if (this._origin) {
            const bot = this._origin.subscriptions.find((s)=>s.subscriber.subtype === (0, _sfuBot.SfuBotMember).subtype)?.subscriber;
            if (!bot) throw (0, _util.createError)({
                operationName: "RoomPublicationImpl.getStats",
                room: this._room,
                path,
                info: {
                    ...(0, _errors.errors).notFound,
                    detail: "bot not found"
                }
            });
            return this._origin.getStats(bot);
        } else {
            const id = typeof selector === "string" ? selector : selector.id;
            return this._publication.getStats(id);
        }
    }
    getRTCPeerConnection(selector) {
        if (this._origin) {
            const bot = this._origin.subscriptions.find((s)=>s.subscriber.subtype === (0, _sfuBot.SfuBotMember).subtype)?.subscriber;
            if (!bot) throw (0, _util.createError)({
                operationName: "RoomPublicationImpl.getRTCPeerConnection",
                room: this._room,
                path,
                info: {
                    ...(0, _errors.errors).notFound,
                    detail: "bot not found"
                }
            });
            return this._origin.getRTCPeerConnection(bot);
        } else {
            const id = typeof selector === "string" ? selector : selector.id;
            return this._publication.getRTCPeerConnection(id);
        }
    }
    getConnectionState(selector) {
        if (this._origin) {
            const bot = this._origin.subscriptions.find((s)=>s.subscriber.subtype === (0, _sfuBot.SfuBotMember).subtype)?.subscriber;
            if (!bot) throw (0, _util.createError)({
                operationName: "RoomPublicationImpl.getConnectionState",
                room: this._room,
                path,
                info: {
                    ...(0, _errors.errors).notFound,
                    detail: "bot not found"
                }
            });
            return this._origin.getConnectionState(bot);
        } else {
            const id = typeof selector === "string" ? selector : selector.id;
            return this._publication.getConnectionState(id);
        }
    }
    toJSON() {
        return {
            id: this.id,
            contentType: this.contentType,
            metadata: this.metadata,
            publisher: this.publisher,
            subscriptions: this.subscriptions,
            codecCapabilities: this.codecCapabilities,
            encodings: this.encodings,
            state: this.state
        };
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/sfu-bot":"fgRbl","../errors":"d7AJ6","../util":"2QeGu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"04C1D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SfuApiOptions", ()=>(0, _sfuBot.SfuApiOptions));
parcelHelpers.export(exports, "SfuBotPluginOptions", ()=>(0, _sfuBot.SfuBotPluginOptions));
parcelHelpers.export(exports, "SkyWayRoom", ()=>SkyWayRoom);
parcelHelpers.export(exports, "roomTypes", ()=>roomTypes);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _sfuBot = require("@skyway-sdk/sfu-bot");
var _uuid = require("uuid");
var _errors = require("../errors");
var _version = require("../version");
var _p2P = require("./p2p");
var _sfu = require("./sfu");
const log = new (0, _common.Logger)("packages/room/src/room/index.ts");
class SkyWayRoom {
    /**@private */ constructor(){}
    /**
   * @description [japanese] Roomの作成
   */ static Create = async (context, init)=>{
        log.info("room created", {
            operationName: "SkyWayRoom._Factory",
            sdkName: "room",
            sdkVersion: (0, _version.PACKAGE_VERSION),
            init
        });
        const plugin = new (0, _sfuBot.SfuBotPlugin)(init?.options?.sfu);
        context.registerPlugin(plugin);
        const channel = await (0, _core.SkyWayChannel).Create(context, {
            name: init.name ?? (0, _uuid.v4)(),
            metadata: init.metadata
        });
        const room = await SkyWayRoom._Factory(context, init.type, channel);
        return room;
    };
    /**
   * @description [japanese] 既存のRoomの取得
   */ static Find = async (context, query, roomType, options)=>{
        const plugin = new (0, _sfuBot.SfuBotPlugin)(options?.sfu);
        context.registerPlugin(plugin);
        const channel = await (0, _core.SkyWayChannel).Find(context, query);
        const room = await SkyWayRoom._Factory(context, roomType, channel);
        return room;
    };
    /**
   * @description [japanese] Roomの取得を試み、存在しなければ作成する
   */ static FindOrCreate = async (context, init)=>{
        const plugin = new (0, _sfuBot.SfuBotPlugin)(init?.options?.sfu);
        context.registerPlugin(plugin);
        const channel = await (0, _core.SkyWayChannel).FindOrCreate(context, {
            ...init
        });
        const room = await SkyWayRoom._Factory(context, init.type, channel);
        return room;
    };
    static _Factory = async (context, roomType, channel)=>{
        switch(roomType){
            case "p2p":
                return new (0, _p2P.P2PRoomImpl)(channel);
            case "sfu":
                return await (0, _sfu.SfuRoomImpl).Create(context, channel);
            default:
                throw (0, _core.createError)({
                    operationName: "SkyWayRoom._Factory",
                    context,
                    channel,
                    info: (0, _errors.errors).notImplemented,
                    path: log.prefix
                });
        }
    };
}
const roomTypes = [
    "sfu",
    "p2p"
];

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","@skyway-sdk/sfu-bot":"fgRbl","uuid":"3LhAe","../errors":"d7AJ6","../version":"67gDN","./p2p":"5YKHT","./sfu":"b6OSm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3LhAe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":false,"./v3.js":false,"./v4.js":"asHbd","./v5.js":false,"./nil.js":false,"./version.js":false,"./validate.js":"gZR9Y","./stringify.js":"e7iIf","./parse.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asHbd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeJs = require("./native.js");
var _nativeJsDefault = parcelHelpers.interopDefault(_nativeJs);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
function v4(options, buf, offset) {
    if ((0, _nativeJsDefault.default).randomUUID && !buf && !options) return (0, _nativeJsDefault.default).randomUUID();
    options = options || {};
    const rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJs.unsafeStringify)(rnds);
}
exports.default = v4;

},{"./native.js":"1onSZ","./rng.js":"iEUGy","./stringify.js":"e7iIf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1onSZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports.default = {
    randomUUID
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iEUGy":[function(require,module,exports) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    return getRandomValues(rnds8);
}
exports.default = rng;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e7iIf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeStringify", ()=>unsafeStringify);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"gZR9Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZR9Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === "string" && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"lPeEi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPeEi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"67gDN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PACKAGE_VERSION", ()=>PACKAGE_VERSION);
const PACKAGE_VERSION = "1.9.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5YKHT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "P2PRoomImpl", ()=>P2PRoomImpl);
var _common = require("@skyway-sdk/common");
var _p2P = require("../member/local/p2p");
var _base = require("../member/remote/base");
var _base1 = require("./base");
const log = new (0, _common.Logger)("packages/room/src/room/p2p.ts");
class P2PRoomImpl extends (0, _base1.RoomImpl) {
    constructor(channel){
        super("p2p", channel);
        this.setChannelState();
        this.setChannelListener();
    }
    setChannelState() {
        this._channel.members.forEach((m)=>{
            const member = new (0, _base.RemoteRoomMemberImpl)(m, this);
            this._members[m.id] = member;
        });
        this._channel.publications.forEach((p)=>{
            this._addPublication(p);
        });
        this._channel.subscriptions.forEach((s)=>{
            this._addSubscription(s);
        });
    }
    setChannelListener() {
        this._channel.onMemberJoined.add((e)=>this._handleOnMemberJoin(e.member));
        this._channel.onMemberLeft.add((e)=>this._handleOnMemberLeft(e.member));
        this._channel.onStreamPublished.add((e)=>this._handleOnStreamPublish(e.publication));
        this._channel.onStreamUnpublished.add((e)=>this._handleOnStreamUnpublish(e.publication));
        this._channel.onPublicationMetadataUpdated.add((e)=>{
            this._handleOnPublicationMetadataUpdate(e.publication);
        });
        this._channel.onPublicationEnabled.add((e)=>{
            this._handleOnPublicationEnabled(e.publication);
        });
        this._channel.onPublicationDisabled.add((e)=>{
            this._handleOnPublicationDisabled(e.publication);
        });
        this._channel.onPublicationSubscribed.add((e)=>this._handleOnStreamSubscribe(e.subscription));
        this._channel.onPublicationUnsubscribed.add((e)=>this._handleOnStreamUnsubscribe(e.subscription));
    }
    _handleOnMemberJoin(m) {
        if (this._getMember(m.id)) return;
        const member = new (0, _base.RemoteRoomMemberImpl)(m, this);
        this._members[m.id] = member;
        this.onMemberJoined.emit({
            member
        });
        this.onMemberListChanged.emit({});
    }
    _handleOnMemberLeft(m) {
        const member = this._getMember(m.id);
        delete this._members[m.id];
        member._dispose();
        this.onMemberLeft.emit({
            member
        });
        this.onMemberListChanged.emit({});
    }
    _handleOnStreamPublish(p) {
        if (this._getPublication(p.id)) return;
        const publication = this._addPublication(p);
        this.onStreamPublished.emit({
            publication
        });
        this.onPublicationListChanged.emit({});
    }
    _handleOnStreamUnpublish(p) {
        const publication = this._getPublication(p.id);
        delete this._publications[p.id];
        this.onStreamUnpublished.emit({
            publication
        });
        this.onPublicationListChanged.emit({});
    }
    _handleOnPublicationMetadataUpdate(p) {
        const publication = this._getPublication(p.id);
        this.onPublicationMetadataUpdated.emit({
            publication,
            metadata: publication.metadata
        });
    }
    _handleOnPublicationEnabled(p) {
        const publication = this._getPublication(p.id);
        this.onPublicationEnabled.emit({
            publication
        });
    }
    _handleOnPublicationDisabled(p) {
        const publication = this._getPublication(p.id);
        this.onPublicationDisabled.emit({
            publication
        });
    }
    _handleOnStreamSubscribe(s) {
        if (this._getSubscription(s.id)) return;
        const subscription = this._addSubscription(s);
        this.onPublicationSubscribed.emit({
            subscription
        });
        this.onSubscriptionListChanged.emit({});
    }
    _handleOnStreamUnsubscribe(s) {
        const subscription = this._getSubscription(s.id);
        delete this._subscriptions[s.id];
        this.onPublicationUnsubscribed.emit({
            subscription
        });
        this.onSubscriptionListChanged.emit({});
    }
    async join(memberInit = {}) {
        const local = await this.joinChannel(memberInit);
        const localRoomMember = new (0, _p2P.LocalP2PRoomMemberImpl)(local, this);
        log.debug("member joined", memberInit);
        this.localRoomMember = localRoomMember;
        localRoomMember.onLeft.once(()=>{
            this.localRoomMember = undefined;
        });
        return localRoomMember;
    }
}

},{"@skyway-sdk/common":"3hyrG","../member/local/p2p":"a3Zkj","../member/remote/base":"6Diig","./base":"6Kn8X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Kn8X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "RoomImpl", ()=>RoomImpl);
var _common = require("@skyway-sdk/common");
var _uuid = require("uuid");
var _errors = require("../errors");
var _publication = require("../publication");
var _subscription = require("../subscription");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/room/src/room/base.ts");
class RoomImpl {
    /**@private */ _getMember(id) {
        return this._members[id];
    }
    /**@private */ _getPublication(id) {
        return this._publications[id];
    }
    /**@private */ _addPublication(p) {
        const exist = this._publications[p.id];
        if (exist) return exist;
        const publication = new (0, _publication.RoomPublicationImpl)(p, this);
        this._publications[p.id] = publication;
        return publication;
    }
    /**@private */ _getSubscription(id) {
        return this._subscriptions[id];
    }
    /**@private */ _addSubscription(s) {
        const exist = this._subscriptions[s.id];
        if (exist) return exist;
        const subscription = new (0, _subscription.RoomSubscriptionImpl)(s, this);
        this._subscriptions[s.id] = subscription;
        return subscription;
    }
    get id() {
        return this._channel.id;
    }
    get name() {
        return this._channel.name;
    }
    get metadata() {
        return this._channel.metadata;
    }
    get state() {
        return this._channel.state;
    }
    get disposed() {
        return this._channel.disposed;
    }
    constructor(type, _channel){
        this._channel = _channel;
        this._members = {};
        this._publications = {};
        this._subscriptions = {};
        this._context = this._channel._context;
        this._events = new (0, _common.Events)();
        this.onClosed = this._events.make();
        this.onMetadataUpdated = this._events.make();
        this.onMemberJoined = this._events.make();
        this.onMemberLeft = this._events.make();
        this.onMemberListChanged = this._events.make();
        this.onMemberMetadataUpdated = this._events.make();
        this.onStreamPublished = this._events.make();
        this.onStreamUnpublished = this._events.make();
        this.onPublicationListChanged = this._events.make();
        this.onPublicationMetadataUpdated = this._events.make();
        this.onPublicationEnabled = this._events.make();
        this.onPublicationDisabled = this._events.make();
        this.onPublicationSubscribed = this._events.make();
        this.onPublicationUnsubscribed = this._events.make();
        this.onSubscriptionListChanged = this._events.make();
        this.type = type;
        this._channel.onClosed.pipe(this.onClosed);
        this._channel.onMetadataUpdated.pipe(this.onMetadataUpdated);
        this._channel.onMemberMetadataUpdated.add((e)=>{
            this._handleOnMemberMetadataUpdate(e);
        });
    }
    _handleOnMemberMetadataUpdate(e) {
        const member = this._getMember(e.member.id);
        this.onMemberMetadataUpdated.emit({
            member,
            metadata: e.metadata
        });
    }
    get members() {
        return Object.values(this._members);
    }
    get publications() {
        return Object.values(this._publications);
    }
    get subscriptions() {
        return Object.values(this._subscriptions);
    }
    async joinChannel(roomMemberInit = {}) {
        if (this.state !== "opened") throw (0, _util.createError)({
            operationName: "RoomImpl.joinChannel",
            context: this._context,
            room: this,
            info: (0, _errors.errors).roomNotOpened,
            path: log.prefix
        });
        roomMemberInit.name = roomMemberInit.name ?? (0, _uuid.v4)();
        const local = await this._channel.join(roomMemberInit);
        if (!this._getMember(local.id)) await this.onMemberJoined.watch((e)=>{
            return e.member._member.id === local.id;
        }, this._context.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "RoomImpl.joinChannel",
                context: this._context,
                room: this,
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "RoomImpl onMemberJoined"
                },
                path: log.prefix,
                error
            });
        });
        return local;
    }
    async leave(member) {
        await this._channel.leave(member._member);
    }
    async moveRoom(member) {
        await this._channel.moveChannel(member._local);
        member._updateRoom(this);
        return member;
    }
    updateMetadata(metadata) {
        return this._channel.updateMetadata(metadata);
    }
    async close() {
        await this._channel.close();
    }
    async dispose() {
        return this._channel.dispose();
    }
    toJSON() {
        return {
            type: this.type,
            id: this.id,
            name: this.name,
            metadata: this.metadata,
            members: this.members,
            publications: this.publications,
            subscriptions: this.subscriptions
        };
    }
}

},{"@skyway-sdk/common":"3hyrG","uuid":"3LhAe","../errors":"d7AJ6","../publication":"k9w39","../subscription":"3WOdj","../util":"2QeGu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3WOdj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "RoomSubscriptionImpl", ()=>RoomSubscriptionImpl);
var _common = require("@skyway-sdk/common");
var _core = require("@skyway-sdk/core");
var _errors = require("../errors");
var _util = require("../util");
const log = new (0, _common.Logger)("packages/room/src/subscription/index.ts");
class RoomSubscriptionImpl {
    constructor(_subscription, _room){
        this._subscription = _subscription;
        this._room = _room;
        this._context = this._room._context;
        this.onStreamAttached = new (0, _core.Event)();
        this.onCanceled = new (0, _core.Event)();
        this.onConnectionStateChanged = new (0, _core.Event)();
        this.id = _subscription.id;
        this.contentType = _subscription.contentType;
        this.publication = this._room._getPublication(_subscription.publication.id);
        this.subscriber = this._room._getMember(_subscription.subscriber.id);
        _subscription.onStreamAttached.pipe(this.onStreamAttached);
        _subscription.onCanceled.pipe(this.onCanceled);
        _subscription.onConnectionStateChanged.add((state)=>{
            log.debug("_subscription.onConnectionStateChanged", this.id, state);
            this.onConnectionStateChanged.emit(state);
        });
    }
    get stream() {
        return this._subscription.stream;
    }
    get state() {
        return this._subscription.state;
    }
    get codec() {
        return this._subscription.codec;
    }
    get preferredEncoding() {
        return this._subscription.preferredEncoding;
    }
    changePreferredEncoding(id) {
        this._subscription.changePreferredEncoding(id);
    }
    async cancel() {
        this._subscription.cancel().catch((error)=>{
            log.error("subscription.cancel", error, this.toJSON());
        });
        await this._room.onPublicationUnsubscribed.watch((e)=>e.subscription.id === this.id, this._context.config.rtcApi.timeout).catch((error)=>{
            throw (0, _util.createError)({
                operationName: "RoomSubscriptionImpl.cancel",
                context: this._context,
                room: this._room,
                info: {
                    ...(0, _errors.errors).timeout,
                    detail: "onPublicationUnsubscribed"
                },
                error,
                path: log.prefix
            });
        });
    }
    toJSON() {
        return {
            id: this.id,
            contentType: this.contentType,
            publication: this.publication,
            codec: this.codec
        };
    }
    getStats() {
        return this._subscription.getStats();
    }
    getRTCPeerConnection() {
        return this._subscription.getRTCPeerConnection();
    }
    getConnectionState() {
        return this._subscription.getConnectionState();
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/core":"kbrOO","../errors":"d7AJ6","../util":"2QeGu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6OSm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**@internal */ parcelHelpers.export(exports, "SfuRoomImpl", ()=>SfuRoomImpl);
var _common = require("@skyway-sdk/common");
var _sfuBot = require("@skyway-sdk/sfu-bot");
var _sfu = require("../member/local/sfu");
var _base = require("../member/remote/base");
var _base1 = require("./base");
const log = new (0, _common.Logger)("packages/room/src/room/sfu.ts");
class SfuRoomImpl extends (0, _base1.RoomImpl) {
    static async Create(context, channel) {
        const plugin = context.plugins.find((p)=>p.subtype === "sfu");
        const bot = channel.members.find((m)=>m.subtype === (0, _sfuBot.SfuBotMember).subtype);
        if (!bot) await plugin.createBot(channel);
        const room = new SfuRoomImpl(channel, plugin);
        return room;
    }
    constructor(channel, _plugin){
        super("sfu", channel);
        this._plugin = _plugin;
        this.setChannelState();
        this.setChannelListener();
    }
    setChannelState() {
        this._channel.members.forEach((m)=>{
            if (m.type === "bot") return;
            const member = new (0, _base.RemoteRoomMemberImpl)(m, this);
            this._members[m.id] = member;
        });
        this._channel.publications.forEach((p)=>{
            if (!p.origin) return;
            this._addPublication(p);
        });
        this._channel.subscriptions.forEach((s)=>{
            if (s.subscriber.type === "bot") return;
            this._addSubscription(s);
        });
    }
    setChannelListener() {
        this._channel.onMemberJoined.add((e)=>this._handleOnMemberJoin(e.member));
        this._channel.onMemberLeft.add((e)=>this._handleOnMemberLeft(e.member));
        this._channel.onStreamPublished.add((e)=>{
            this._handleOnStreamPublish(e.publication);
        });
        this._channel.onStreamUnpublished.add((e)=>this._handleOnStreamUnpublish(e.publication));
        this._channel.onPublicationMetadataUpdated.add((e)=>{
            this._handleOnPublicationMetadataUpdate(e.publication);
        });
        this._channel.onPublicationEnabled.add((e)=>{
            this._handleOnPublicationEnabled(e.publication);
        });
        this._channel.onPublicationDisabled.add((e)=>{
            this._handleOnPublicationDisabled(e.publication);
        });
        this._channel.onPublicationSubscribed.add((e)=>{
            this._handleOnStreamSubscribe(e.subscription);
        });
        this._channel.onPublicationUnsubscribed.add((e)=>this._handleOnStreamUnsubscribe(e.subscription));
    }
    _handleOnMemberJoin(m) {
        if (m.type === "bot") return;
        const member = new (0, _base.RemoteRoomMemberImpl)(m, this);
        this._members[m.id] = member;
        this.onMemberJoined.emit({
            member
        });
        this.onMemberListChanged.emit({});
    }
    _handleOnMemberLeft(m) {
        const member = this._getMember(m.id);
        if (!member) // should be sfu
        return;
        delete this._members[m.id];
        member._dispose();
        this.onMemberLeft.emit({
            member
        });
        this.onMemberListChanged.emit({});
    }
    _handleOnStreamPublish(p) {
        if (!p.origin?.id) return;
        const publication = this._addPublication(p);
        this.onStreamPublished.emit({
            publication
        });
        this.onPublicationListChanged.emit({});
    }
    _handleOnStreamUnpublish(p) {
        if (!p.origin?.id) return;
        const publication = this._getPublication(p.id);
        delete this._publications[p.id];
        this.onStreamUnpublished.emit({
            publication
        });
        this.onPublicationListChanged.emit({});
    }
    _getRelayedPublication(publicationId) {
        const relayed = this.publications.find((p)=>p._publication.origin?.id === publicationId);
        return relayed;
    }
    _handleOnPublicationMetadataUpdate(p) {
        const publication = this._getRelayedPublication(p.id);
        if (!publication) return;
        this.onPublicationMetadataUpdated.emit({
            publication,
            metadata: publication.metadata
        });
    }
    _handleOnPublicationEnabled(p) {
        const publication = this._getRelayedPublication(p.id);
        if (!publication) return;
        this.onPublicationEnabled.emit({
            publication
        });
    }
    _handleOnPublicationDisabled(p) {
        const publication = this._getRelayedPublication(p.id);
        if (!publication) return;
        this.onPublicationDisabled.emit({
            publication
        });
    }
    _handleOnStreamSubscribe(s) {
        if (s.subscriber.type === "bot") return;
        const subscription = this._addSubscription(s);
        this.onPublicationSubscribed.emit({
            subscription
        });
        this.onSubscriptionListChanged.emit({});
    }
    _handleOnStreamUnsubscribe(s) {
        if (s.subscriber.type === "bot") return;
        const subscription = this._getSubscription(s.id);
        delete this._subscriptions[s.id];
        this.onPublicationUnsubscribed.emit({
            subscription
        });
        this.onSubscriptionListChanged.emit({});
    }
    async join(memberInit = {}) {
        const local = await this.joinChannel({
            ...memberInit,
            disableSignaling: true
        });
        const localRoomMember = new (0, _sfu.LocalSFURoomMemberImpl)(local, this);
        this.localRoomMember = localRoomMember;
        localRoomMember.onLeft.once(()=>{
            this.localRoomMember = undefined;
        });
        log.debug("member joined", memberInit);
        return localRoomMember;
    }
}

},{"@skyway-sdk/common":"3hyrG","@skyway-sdk/sfu-bot":"fgRbl","../member/local/sfu":"9Q67n","../member/remote/base":"6Diig","./base":"6Kn8X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4XuZD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["55EVS","hMOu1"], "hMOu1", "parcelRequire641b")

//# sourceMappingURL=index.88ac1ca2.js.map
